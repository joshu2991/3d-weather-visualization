const yd=function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))i(r);new MutationObserver(r=>{for(const s of r)if(s.type==="childList")for(const o of s.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&i(o)}).observe(document,{childList:!0,subtree:!0});function e(r){const s={};return r.integrity&&(s.integrity=r.integrity),r.referrerpolicy&&(s.referrerPolicy=r.referrerpolicy),r.crossorigin==="use-credentials"?s.credentials="include":r.crossorigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function i(r){if(r.ep)return;r.ep=!0;const s=e(r);fetch(r.href,s)}};yd();function dn(n){if(n===void 0)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return n}function ph(n,t){n.prototype=Object.create(t.prototype),n.prototype.constructor=n,n.__proto__=t}/*!
 * GSAP 3.10.4
 * https://greensock.com
 *
 * @license Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/var Ce={autoSleep:120,force3D:"auto",nullTargetWarn:1,units:{lineHeight:""}},Ni={duration:.5,overwrite:!1,delay:0},Na,Ie=1e8,Bt=1/Ie,$o=Math.PI*2,vd=$o/4,bd=0,mh=Math.sqrt,wd=Math.cos,Md=Math.sin,ie=function(t){return typeof t=="string"},ee=function(t){return typeof t=="function"},mn=function(t){return typeof t=="number"},Oa=function(t){return typeof t=="undefined"},gn=function(t){return typeof t=="object"},ve=function(t){return t!==!1},gh=function(){return typeof window!="undefined"},Xr=function(t){return ee(t)||ie(t)},_h=typeof ArrayBuffer=="function"&&ArrayBuffer.isView||function(){},fe=Array.isArray,Ko=/(?:-?\.?\d|\.)+/gi,xh=/[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,Ei=/[-+=.]*\d+[.e-]*\d*[a-z%]*/g,co=/[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,yh=/[+-]=-?[.\d]+/,vh=/[^,'"\[\]\s]+/gi,Sd=/^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,qt,$e,ta,Ba,Re={},Es={},bh,wh=function(t){return(Es=ii(t,Re))&&Je},za=function(t,e){return console.warn("Invalid property",t,"set to",e,"Missing plugin? gsap.registerPlugin()")},As=function(t,e){return!e&&console.warn(t)},Mh=function(t,e){return t&&(Re[t]=e)&&Es&&(Es[t]=e)||Re},Er=function(){return 0},ka={},Rn=[],ea={},Sh,Ee={},ho={},Al=30,Ss=[],Ua="",Ha=function(t){var e=t[0],i,r;if(gn(e)||ee(e)||(t=[t]),!(i=(e._gsap||{}).harness)){for(r=Ss.length;r--&&!Ss[r].targetTest(e););i=Ss[r]}for(r=t.length;r--;)t[r]&&(t[r]._gsap||(t[r]._gsap=new jh(t[r],i)))||t.splice(r,1);return t},Jn=function(t){return t._gsap||Ha(Fe(t))[0]._gsap},Th=function(t,e,i){return(i=t[e])&&ee(i)?t[e]():Oa(i)&&t.getAttribute&&t.getAttribute(e)||i},be=function(t,e){return(t=t.split(",")).forEach(e)||t},Zt=function(t){return Math.round(t*1e5)/1e5||0},he=function(t){return Math.round(t*1e7)/1e7||0},Pi=function(t,e){var i=e.charAt(0),r=parseFloat(e.substr(2));return t=parseFloat(t),i==="+"?t+r:i==="-"?t-r:i==="*"?t*r:t/r},Td=function(t,e){for(var i=e.length,r=0;t.indexOf(e[r])<0&&++r<i;);return r<i},Ls=function(){var t=Rn.length,e=Rn.slice(0),i,r;for(ea={},Rn.length=0,i=0;i<t;i++)r=e[i],r&&r._lazy&&(r.render(r._lazy[0],r._lazy[1],!0)._lazy=0)},Eh=function(t,e,i,r){Rn.length&&Ls(),t.render(e,i,r),Rn.length&&Ls()},Ah=function(t){var e=parseFloat(t);return(e||e===0)&&(t+"").match(vh).length<2?e:ie(t)?t.trim():t},Lh=function(t){return t},ke=function(t,e){for(var i in e)i in t||(t[i]=e[i]);return t},Ed=function(t){return function(e,i){for(var r in i)r in e||r==="duration"&&t||r==="ease"||(e[r]=i[r])}},ii=function(t,e){for(var i in e)t[i]=e[i];return t},Ll=function n(t,e){for(var i in e)i!=="__proto__"&&i!=="constructor"&&i!=="prototype"&&(t[i]=gn(e[i])?n(t[i]||(t[i]={}),e[i]):e[i]);return t},Cs=function(t,e){var i={},r;for(r in t)r in e||(i[r]=t[r]);return i},gr=function(t){var e=t.parent||qt,i=t.keyframes?Ed(fe(t.keyframes)):ke;if(ve(t.inherit))for(;e;)i(t,e.vars.defaults),e=e.parent||e._dp;return t},Ad=function(t,e){for(var i=t.length,r=i===e.length;r&&i--&&t[i]===e[i];);return i<0},Ch=function(t,e,i,r,s){i===void 0&&(i="_first"),r===void 0&&(r="_last");var o=t[r],a;if(s)for(a=e[s];o&&o[s]>a;)o=o._prev;return o?(e._next=o._next,o._next=e):(e._next=t[i],t[i]=e),e._next?e._next._prev=e:t[r]=e,e._prev=o,e.parent=e._dp=t,e},Xs=function(t,e,i,r){i===void 0&&(i="_first"),r===void 0&&(r="_last");var s=e._prev,o=e._next;s?s._next=o:t[i]===e&&(t[i]=o),o?o._prev=s:t[r]===e&&(t[r]=s),e._next=e._prev=e.parent=null},fn=function(t,e){t.parent&&(!e||t.parent.autoRemoveChildren)&&t.parent.remove(t),t._act=0},Qn=function(t,e){if(t&&(!e||e._end>t._dur||e._start<0))for(var i=t;i;)i._dirty=1,i=i.parent;return t},Ld=function(t){for(var e=t.parent;e&&e.parent;)e._dirty=1,e.totalDuration(),e=e.parent;return t},Cd=function n(t){return!t||t._ts&&n(t.parent)},Cl=function(t){return t._repeat?Oi(t._tTime,t=t.duration()+t._rDelay)*t:0},Oi=function(t,e){var i=Math.floor(t/=e);return t&&i===t?i-1:i},Rs=function(t,e){return(t-e._start)*e._ts+(e._ts>=0?0:e._dirty?e.totalDuration():e._tDur)},Ys=function(t){return t._end=he(t._start+(t._tDur/Math.abs(t._ts||t._rts||Bt)||0))},Ga=function(t,e){var i=t._dp;return i&&i.smoothChildTiming&&t._ts&&(t._start=he(i._time-(t._ts>0?e/t._ts:((t._dirty?t.totalDuration():t._tDur)-e)/-t._ts)),Ys(t),i._dirty||Qn(i,t)),t},Rh=function(t,e){var i;if((e._time||e._initted&&!e._dur)&&(i=Rs(t.rawTime(),e),(!e._dur||Gr(0,e.totalDuration(),i)-e._tTime>Bt)&&e.render(i,!0)),Qn(t,e)._dp&&t._initted&&t._time>=t._dur&&t._ts){if(t._dur<t.duration())for(i=t;i._dp;)i.rawTime()>=0&&i.totalTime(i._tTime),i=i._dp;t._zTime=-Bt}},en=function(t,e,i,r){return e.parent&&fn(e),e._start=he((mn(i)?i:i||t!==qt?De(t,i,e):t._time)+e._delay),e._end=he(e._start+(e.totalDuration()/Math.abs(e.timeScale())||0)),Ch(t,e,"_first","_last",t._sort?"_start":0),na(e)||(t._recent=e),r||Rh(t,e),t},Ph=function(t,e){return(Re.ScrollTrigger||za("scrollTrigger",e))&&Re.ScrollTrigger.create(e,t)},Dh=function(t,e,i,r){if(Wa(t,e),!t._initted)return 1;if(!i&&t._pt&&(t._dur&&t.vars.lazy!==!1||!t._dur&&t.vars.lazy)&&Sh!==Ae.frame)return Rn.push(t),t._lazy=[e,r],1},Rd=function n(t){var e=t.parent;return e&&e._ts&&e._initted&&!e._lock&&(e.rawTime()<0||n(e))},na=function(t){var e=t.data;return e==="isFromStart"||e==="isStart"},Pd=function(t,e,i,r){var s=t.ratio,o=e<0||!e&&(!t._start&&Rd(t)&&!(!t._initted&&na(t))||(t._ts<0||t._dp._ts<0)&&!na(t))?0:1,a=t._rDelay,l=0,c,h,u;if(a&&t._repeat&&(l=Gr(0,t._tDur,e),h=Oi(l,a),t._yoyo&&h&1&&(o=1-o),h!==Oi(t._tTime,a)&&(s=1-o,t.vars.repeatRefresh&&t._initted&&t.invalidate())),o!==s||r||t._zTime===Bt||!e&&t._zTime){if(!t._initted&&Dh(t,e,r,i))return;for(u=t._zTime,t._zTime=e||(i?Bt:0),i||(i=e&&!u),t.ratio=o,t._from&&(o=1-o),t._time=0,t._tTime=l,c=t._pt;c;)c.r(o,c.d),c=c._next;t._startAt&&e<0&&t._startAt.render(e,!0,!0),t._onUpdate&&!i&&Ne(t,"onUpdate"),l&&t._repeat&&!i&&t.parent&&Ne(t,"onRepeat"),(e>=t._tDur||e<0)&&t.ratio===o&&(o&&fn(t,1),i||(Ne(t,o?"onComplete":"onReverseComplete",!0),t._prom&&t._prom()))}else t._zTime||(t._zTime=e)},Dd=function(t,e,i){var r;if(i>e)for(r=t._first;r&&r._start<=i;){if(r.data==="isPause"&&r._start>e)return r;r=r._next}else for(r=t._last;r&&r._start>=i;){if(r.data==="isPause"&&r._start<e)return r;r=r._prev}},Bi=function(t,e,i,r){var s=t._repeat,o=he(e)||0,a=t._tTime/t._tDur;return a&&!r&&(t._time*=o/t._dur),t._dur=o,t._tDur=s?s<0?1e10:he(o*(s+1)+t._rDelay*s):o,a>0&&!r?Ga(t,t._tTime=t._tDur*a):t.parent&&Ys(t),i||Qn(t.parent,t),t},Rl=function(t){return t instanceof ye?Qn(t):Bi(t,t._dur)},Id={_start:0,endTime:Er,totalDuration:Er},De=function n(t,e,i){var r=t.labels,s=t._recent||Id,o=t.duration()>=Ie?s.endTime(!1):t._dur,a,l,c;return ie(e)&&(isNaN(e)||e in r)?(l=e.charAt(0),c=e.substr(-1)==="%",a=e.indexOf("="),l==="<"||l===">"?(a>=0&&(e=e.replace(/=/,"")),(l==="<"?s._start:s.endTime(s._repeat>=0))+(parseFloat(e.substr(1))||0)*(c?(a<0?s:i).totalDuration()/100:1)):a<0?(e in r||(r[e]=o),r[e]):(l=parseFloat(e.charAt(a-1)+e.substr(a+1)),c&&i&&(l=l/100*(fe(i)?i[0]:i).totalDuration()),a>1?n(t,e.substr(0,a-1),i)+l:o+l)):e==null?o:+e},_r=function(t,e,i){var r=mn(e[1]),s=(r?2:1)+(t<2?0:1),o=e[s],a,l;if(r&&(o.duration=e[1]),o.parent=i,t){for(a=o,l=i;l&&!("immediateRender"in a);)a=l.vars.defaults||{},l=ve(l.vars.inherit)&&l.parent;o.immediateRender=ve(a.immediateRender),t<2?o.runBackwards=1:o.startAt=e[s-1]}return new te(e[0],o,e[s+1])},zn=function(t,e){return t||t===0?e(t):e},Gr=function(t,e,i){return i<t?t:i>e?e:i},de=function(t,e){return!ie(t)||!(e=Sd.exec(t))?"":e[1]},Fd=function(t,e,i){return zn(i,function(r){return Gr(t,e,r)})},ia=[].slice,Ih=function(t,e){return t&&gn(t)&&"length"in t&&(!e&&!t.length||t.length-1 in t&&gn(t[0]))&&!t.nodeType&&t!==$e},Nd=function(t,e,i){return i===void 0&&(i=[]),t.forEach(function(r){var s;return ie(r)&&!e||Ih(r,1)?(s=i).push.apply(s,Fe(r)):i.push(r)})||i},Fe=function(t,e,i){return ie(t)&&!i&&(ta||!zi())?ia.call((e||Ba).querySelectorAll(t),0):fe(t)?Nd(t,i):Ih(t)?ia.call(t,0):t?[t]:[]},Od=function(t){return t=Fe(t)[0]||As("Invalid scope")||{},function(e){var i=t.current||t.nativeElement||t;return Fe(e,i.querySelectorAll?i:i===t?As("Invalid scope")||Ba.createElement("div"):t)}},Fh=function(t){return t.sort(function(){return .5-Math.random()})},Nh=function(t){if(ee(t))return t;var e=gn(t)?t:{each:t},i=$n(e.ease),r=e.from||0,s=parseFloat(e.base)||0,o={},a=r>0&&r<1,l=isNaN(r)||a,c=e.axis,h=r,u=r;return ie(r)?h=u={center:.5,edges:.5,end:1}[r]||0:!a&&l&&(h=r[0],u=r[1]),function(d,f,p){var _=(p||e).length,x=o[_],g,m,S,M,v,y,T,D,L;if(!x){if(L=e.grid==="auto"?0:(e.grid||[1,Ie])[1],!L){for(T=-Ie;T<(T=p[L++].getBoundingClientRect().left)&&L<_;);L--}for(x=o[_]=[],g=l?Math.min(L,_)*h-.5:r%L,m=L===Ie?0:l?_*u/L-.5:r/L|0,T=0,D=Ie,y=0;y<_;y++)S=y%L-g,M=m-(y/L|0),x[y]=v=c?Math.abs(c==="y"?M:S):mh(S*S+M*M),v>T&&(T=v),v<D&&(D=v);r==="random"&&Fh(x),x.max=T-D,x.min=D,x.v=_=(parseFloat(e.amount)||parseFloat(e.each)*(L>_?_-1:c?c==="y"?_/L:L:Math.max(L,_/L))||0)*(r==="edges"?-1:1),x.b=_<0?s-_:s,x.u=de(e.amount||e.each)||0,i=i&&_<0?Vh(i):i}return _=(x[d]-x.min)/x.max||0,he(x.b+(i?i(_):_)*x.v)+x.u}},ra=function(t){var e=Math.pow(10,((t+"").split(".")[1]||"").length);return function(i){var r=Math.round(parseFloat(i)/t)*t*e;return(r-r%1)/e+(mn(i)?0:de(i))}},Oh=function(t,e){var i=fe(t),r,s;return!i&&gn(t)&&(r=i=t.radius||Ie,t.values?(t=Fe(t.values),(s=!mn(t[0]))&&(r*=r)):t=ra(t.increment)),zn(e,i?ee(t)?function(o){return s=t(o),Math.abs(s-o)<=r?s:o}:function(o){for(var a=parseFloat(s?o.x:o),l=parseFloat(s?o.y:0),c=Ie,h=0,u=t.length,d,f;u--;)s?(d=t[u].x-a,f=t[u].y-l,d=d*d+f*f):d=Math.abs(t[u]-a),d<c&&(c=d,h=u);return h=!r||c<=r?t[h]:o,s||h===o||mn(o)?h:h+de(o)}:ra(t))},Bh=function(t,e,i,r){return zn(fe(t)?!e:i===!0?!!(i=0):!r,function(){return fe(t)?t[~~(Math.random()*t.length)]:(i=i||1e-5)&&(r=i<1?Math.pow(10,(i+"").length-2):1)&&Math.floor(Math.round((t-i/2+Math.random()*(e-t+i*.99))/i)*i*r)/r})},Bd=function(){for(var t=arguments.length,e=new Array(t),i=0;i<t;i++)e[i]=arguments[i];return function(r){return e.reduce(function(s,o){return o(s)},r)}},zd=function(t,e){return function(i){return t(parseFloat(i))+(e||de(i))}},kd=function(t,e,i){return kh(t,e,0,1,i)},zh=function(t,e,i){return zn(i,function(r){return t[~~e(r)]})},Ud=function n(t,e,i){var r=e-t;return fe(t)?zh(t,n(0,t.length),e):zn(i,function(s){return(r+(s-t)%r)%r+t})},Hd=function n(t,e,i){var r=e-t,s=r*2;return fe(t)?zh(t,n(0,t.length-1),e):zn(i,function(o){return o=(s+(o-t)%s)%s||0,t+(o>r?s-o:o)})},Ar=function(t){for(var e=0,i="",r,s,o,a;~(r=t.indexOf("random(",e));)o=t.indexOf(")",r),a=t.charAt(r+7)==="[",s=t.substr(r+7,o-r-7).match(a?vh:Ko),i+=t.substr(e,r-e)+Bh(a?s:+s[0],a?0:+s[1],+s[2]||1e-5),e=o+1;return i+t.substr(e,t.length-e)},kh=function(t,e,i,r,s){var o=e-t,a=r-i;return zn(s,function(l){return i+((l-t)/o*a||0)})},Gd=function n(t,e,i,r){var s=isNaN(t+e)?0:function(f){return(1-f)*t+f*e};if(!s){var o=ie(t),a={},l,c,h,u,d;if(i===!0&&(r=1)&&(i=null),o)t={p:t},e={p:e};else if(fe(t)&&!fe(e)){for(h=[],u=t.length,d=u-2,c=1;c<u;c++)h.push(n(t[c-1],t[c]));u--,s=function(p){p*=u;var _=Math.min(d,~~p);return h[_](p-_)},i=e}else r||(t=ii(fe(t)?[]:{},t));if(!h){for(l in e)Va.call(a,t,l,"get",e[l]);s=function(p){return Xa(p,a)||(o?t.p:t)}}}return zn(i,s)},Pl=function(t,e,i){var r=t.labels,s=Ie,o,a,l;for(o in r)a=r[o]-e,a<0==!!i&&a&&s>(a=Math.abs(a))&&(l=o,s=a);return l},Ne=function(t,e,i){var r=t.vars,s=r[e],o,a;if(!!s)return o=r[e+"Params"],a=r.callbackScope||t,i&&Rn.length&&Ls(),o?s.apply(a,o):s.call(a)},ur=function(t){return fn(t),t.scrollTrigger&&t.scrollTrigger.kill(!1),t.progress()<1&&Ne(t,"onInterrupt"),t},Ai,Vd=function(t){t=!t.name&&t.default||t;var e=t.name,i=ee(t),r=e&&!i&&t.init?function(){this._props=[]}:t,s={init:Er,render:Xa,add:Va,kill:of,modifier:sf,rawVars:0},o={targetTest:0,get:0,getSetter:ja,aliases:{},register:0};if(zi(),t!==r){if(Ee[e])return;ke(r,ke(Cs(t,s),o)),ii(r.prototype,ii(s,Cs(t,o))),Ee[r.prop=e]=r,t.targetTest&&(Ss.push(r),ka[e]=1),e=(e==="css"?"CSS":e.charAt(0).toUpperCase()+e.substr(1))+"Plugin"}Mh(e,r),t.register&&t.register(Je,r,we)},Ot=255,dr={aqua:[0,Ot,Ot],lime:[0,Ot,0],silver:[192,192,192],black:[0,0,0],maroon:[128,0,0],teal:[0,128,128],blue:[0,0,Ot],navy:[0,0,128],white:[Ot,Ot,Ot],olive:[128,128,0],yellow:[Ot,Ot,0],orange:[Ot,165,0],gray:[128,128,128],purple:[128,0,128],green:[0,128,0],red:[Ot,0,0],pink:[Ot,192,203],cyan:[0,Ot,Ot],transparent:[Ot,Ot,Ot,0]},uo=function(t,e,i){return t+=t<0?1:t>1?-1:0,(t*6<1?e+(i-e)*t*6:t<.5?i:t*3<2?e+(i-e)*(2/3-t)*6:e)*Ot+.5|0},Uh=function(t,e,i){var r=t?mn(t)?[t>>16,t>>8&Ot,t&Ot]:0:dr.black,s,o,a,l,c,h,u,d,f,p;if(!r){if(t.substr(-1)===","&&(t=t.substr(0,t.length-1)),dr[t])r=dr[t];else if(t.charAt(0)==="#"){if(t.length<6&&(s=t.charAt(1),o=t.charAt(2),a=t.charAt(3),t="#"+s+s+o+o+a+a+(t.length===5?t.charAt(4)+t.charAt(4):"")),t.length===9)return r=parseInt(t.substr(1,6),16),[r>>16,r>>8&Ot,r&Ot,parseInt(t.substr(7),16)/255];t=parseInt(t.substr(1),16),r=[t>>16,t>>8&Ot,t&Ot]}else if(t.substr(0,3)==="hsl"){if(r=p=t.match(Ko),!e)l=+r[0]%360/360,c=+r[1]/100,h=+r[2]/100,o=h<=.5?h*(c+1):h+c-h*c,s=h*2-o,r.length>3&&(r[3]*=1),r[0]=uo(l+1/3,s,o),r[1]=uo(l,s,o),r[2]=uo(l-1/3,s,o);else if(~t.indexOf("="))return r=t.match(xh),i&&r.length<4&&(r[3]=1),r}else r=t.match(Ko)||dr.transparent;r=r.map(Number)}return e&&!p&&(s=r[0]/Ot,o=r[1]/Ot,a=r[2]/Ot,u=Math.max(s,o,a),d=Math.min(s,o,a),h=(u+d)/2,u===d?l=c=0:(f=u-d,c=h>.5?f/(2-u-d):f/(u+d),l=u===s?(o-a)/f+(o<a?6:0):u===o?(a-s)/f+2:(s-o)/f+4,l*=60),r[0]=~~(l+.5),r[1]=~~(c*100+.5),r[2]=~~(h*100+.5)),i&&r.length<4&&(r[3]=1),r},Hh=function(t){var e=[],i=[],r=-1;return t.split(Pn).forEach(function(s){var o=s.match(Ei)||[];e.push.apply(e,o),i.push(r+=o.length+1)}),e.c=i,e},Dl=function(t,e,i){var r="",s=(t+r).match(Pn),o=e?"hsla(":"rgba(",a=0,l,c,h,u;if(!s)return t;if(s=s.map(function(d){return(d=Uh(d,e,1))&&o+(e?d[0]+","+d[1]+"%,"+d[2]+"%,"+d[3]:d.join(","))+")"}),i&&(h=Hh(t),l=i.c,l.join(r)!==h.c.join(r)))for(c=t.replace(Pn,"1").split(Ei),u=c.length-1;a<u;a++)r+=c[a]+(~l.indexOf(a)?s.shift()||o+"0,0,0,0)":(h.length?h:s.length?s:i).shift());if(!c)for(c=t.split(Pn),u=c.length-1;a<u;a++)r+=c[a]+s[a];return r+c[u]},Pn=function(){var n="(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",t;for(t in dr)n+="|"+t+"\\b";return new RegExp(n+")","gi")}(),Wd=/hsl[a]?\(/,Gh=function(t){var e=t.join(" "),i;if(Pn.lastIndex=0,Pn.test(e))return i=Wd.test(e),t[1]=Dl(t[1],i),t[0]=Dl(t[0],i,Hh(t[1])),!0},Lr,Ae=function(){var n=Date.now,t=500,e=33,i=n(),r=i,s=1e3/240,o=s,a=[],l,c,h,u,d,f,p=function _(x){var g=n()-r,m=x===!0,S,M,v,y;if(g>t&&(i+=g-e),r+=g,v=r-i,S=v-o,(S>0||m)&&(y=++u.frame,d=v-u.time*1e3,u.time=v=v/1e3,o+=S+(S>=s?4:s-S),M=1),m||(l=c(_)),M)for(f=0;f<a.length;f++)a[f](v,d,y,x)};return u={time:0,frame:0,tick:function(){p(!0)},deltaRatio:function(x){return d/(1e3/(x||60))},wake:function(){bh&&(!ta&&gh()&&($e=ta=window,Ba=$e.document||{},Re.gsap=Je,($e.gsapVersions||($e.gsapVersions=[])).push(Je.version),wh(Es||$e.GreenSockGlobals||!$e.gsap&&$e||{}),h=$e.requestAnimationFrame),l&&u.sleep(),c=h||function(x){return setTimeout(x,o-u.time*1e3+1|0)},Lr=1,p(2))},sleep:function(){(h?$e.cancelAnimationFrame:clearTimeout)(l),Lr=0,c=Er},lagSmoothing:function(x,g){t=x||1/Bt,e=Math.min(g,t,0)},fps:function(x){s=1e3/(x||240),o=u.time*1e3+s},add:function(x,g,m){var S=g?function(M,v,y,T){x(M,v,y,T),u.remove(S)}:x;return u.remove(x),a[m?"unshift":"push"](S),zi(),S},remove:function(x,g){~(g=a.indexOf(x))&&a.splice(g,1)&&f>=g&&f--},_listeners:a},u}(),zi=function(){return!Lr&&Ae.wake()},At={},qd=/^[\d.\-M][\d.\-,\s]/,jd=/["']/g,Xd=function(t){for(var e={},i=t.substr(1,t.length-3).split(":"),r=i[0],s=1,o=i.length,a,l,c;s<o;s++)l=i[s],a=s!==o-1?l.lastIndexOf(","):l.length,c=l.substr(0,a),e[r]=isNaN(c)?c.replace(jd,"").trim():+c,r=l.substr(a+1).trim();return e},Yd=function(t){var e=t.indexOf("(")+1,i=t.indexOf(")"),r=t.indexOf("(",e);return t.substring(e,~r&&r<i?t.indexOf(")",i+1):i)},Zd=function(t){var e=(t+"").split("("),i=At[e[0]];return i&&e.length>1&&i.config?i.config.apply(null,~t.indexOf("{")?[Xd(e[1])]:Yd(t).split(",").map(Ah)):At._CE&&qd.test(t)?At._CE("",t):i},Vh=function(t){return function(e){return 1-t(1-e)}},Wh=function n(t,e){for(var i=t._first,r;i;)i instanceof ye?n(i,e):i.vars.yoyoEase&&(!i._yoyo||!i._repeat)&&i._yoyo!==e&&(i.timeline?n(i.timeline,e):(r=i._ease,i._ease=i._yEase,i._yEase=r,i._yoyo=e)),i=i._next},$n=function(t,e){return t&&(ee(t)?t:At[t]||Zd(t))||e},ri=function(t,e,i,r){i===void 0&&(i=function(l){return 1-e(1-l)}),r===void 0&&(r=function(l){return l<.5?e(l*2)/2:1-e((1-l)*2)/2});var s={easeIn:e,easeOut:i,easeInOut:r},o;return be(t,function(a){At[a]=Re[a]=s,At[o=a.toLowerCase()]=i;for(var l in s)At[o+(l==="easeIn"?".in":l==="easeOut"?".out":".inOut")]=At[a+"."+l]=s[l]}),s},qh=function(t){return function(e){return e<.5?(1-t(1-e*2))/2:.5+t((e-.5)*2)/2}},fo=function n(t,e,i){var r=e>=1?e:1,s=(i||(t?.3:.45))/(e<1?e:1),o=s/$o*(Math.asin(1/r)||0),a=function(h){return h===1?1:r*Math.pow(2,-10*h)*Md((h-o)*s)+1},l=t==="out"?a:t==="in"?function(c){return 1-a(1-c)}:qh(a);return s=$o/s,l.config=function(c,h){return n(t,c,h)},l},po=function n(t,e){e===void 0&&(e=1.70158);var i=function(o){return o?--o*o*((e+1)*o+e)+1:0},r=t==="out"?i:t==="in"?function(s){return 1-i(1-s)}:qh(i);return r.config=function(s){return n(t,s)},r};be("Linear,Quad,Cubic,Quart,Quint,Strong",function(n,t){var e=t<5?t+1:t;ri(n+",Power"+(e-1),t?function(i){return Math.pow(i,e)}:function(i){return i},function(i){return 1-Math.pow(1-i,e)},function(i){return i<.5?Math.pow(i*2,e)/2:1-Math.pow((1-i)*2,e)/2})});At.Linear.easeNone=At.none=At.Linear.easeIn;ri("Elastic",fo("in"),fo("out"),fo());(function(n,t){var e=1/t,i=2*e,r=2.5*e,s=function(a){return a<e?n*a*a:a<i?n*Math.pow(a-1.5/t,2)+.75:a<r?n*(a-=2.25/t)*a+.9375:n*Math.pow(a-2.625/t,2)+.984375};ri("Bounce",function(o){return 1-s(1-o)},s)})(7.5625,2.75);ri("Expo",function(n){return n?Math.pow(2,10*(n-1)):0});ri("Circ",function(n){return-(mh(1-n*n)-1)});ri("Sine",function(n){return n===1?1:-wd(n*vd)+1});ri("Back",po("in"),po("out"),po());At.SteppedEase=At.steps=Re.SteppedEase={config:function(t,e){t===void 0&&(t=1);var i=1/t,r=t+(e?0:1),s=e?1:0,o=1-Bt;return function(a){return((r*Gr(0,o,a)|0)+s)*i}}};Ni.ease=At["quad.out"];be("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt",function(n){return Ua+=n+","+n+"Params,"});var jh=function(t,e){this.id=bd++,t._gsap=this,this.target=t,this.harness=e,this.get=e?e.get:Th,this.set=e?e.getSetter:ja},Cr=function(){function n(e){this.vars=e,this._delay=+e.delay||0,(this._repeat=e.repeat===1/0?-2:e.repeat||0)&&(this._rDelay=e.repeatDelay||0,this._yoyo=!!e.yoyo||!!e.yoyoEase),this._ts=1,Bi(this,+e.duration,1,1),this.data=e.data,Lr||Ae.wake()}var t=n.prototype;return t.delay=function(i){return i||i===0?(this.parent&&this.parent.smoothChildTiming&&this.startTime(this._start+i-this._delay),this._delay=i,this):this._delay},t.duration=function(i){return arguments.length?this.totalDuration(this._repeat>0?i+(i+this._rDelay)*this._repeat:i):this.totalDuration()&&this._dur},t.totalDuration=function(i){return arguments.length?(this._dirty=0,Bi(this,this._repeat<0?i:(i-this._repeat*this._rDelay)/(this._repeat+1))):this._tDur},t.totalTime=function(i,r){if(zi(),!arguments.length)return this._tTime;var s=this._dp;if(s&&s.smoothChildTiming&&this._ts){for(Ga(this,i),!s._dp||s.parent||Rh(s,this);s&&s.parent;)s.parent._time!==s._start+(s._ts>=0?s._tTime/s._ts:(s.totalDuration()-s._tTime)/-s._ts)&&s.totalTime(s._tTime,!0),s=s.parent;!this.parent&&this._dp.autoRemoveChildren&&(this._ts>0&&i<this._tDur||this._ts<0&&i>0||!this._tDur&&!i)&&en(this._dp,this,this._start-this._delay)}return(this._tTime!==i||!this._dur&&!r||this._initted&&Math.abs(this._zTime)===Bt||!i&&!this._initted&&(this.add||this._ptLookup))&&(this._ts||(this._pTime=i),Eh(this,i,r)),this},t.time=function(i,r){return arguments.length?this.totalTime(Math.min(this.totalDuration(),i+Cl(this))%(this._dur+this._rDelay)||(i?this._dur:0),r):this._time},t.totalProgress=function(i,r){return arguments.length?this.totalTime(this.totalDuration()*i,r):this.totalDuration()?Math.min(1,this._tTime/this._tDur):this.ratio},t.progress=function(i,r){return arguments.length?this.totalTime(this.duration()*(this._yoyo&&!(this.iteration()&1)?1-i:i)+Cl(this),r):this.duration()?Math.min(1,this._time/this._dur):this.ratio},t.iteration=function(i,r){var s=this.duration()+this._rDelay;return arguments.length?this.totalTime(this._time+(i-1)*s,r):this._repeat?Oi(this._tTime,s)+1:1},t.timeScale=function(i){if(!arguments.length)return this._rts===-Bt?0:this._rts;if(this._rts===i)return this;var r=this.parent&&this._ts?Rs(this.parent._time,this):this._tTime;return this._rts=+i||0,this._ts=this._ps||i===-Bt?0:this._rts,this.totalTime(Gr(-this._delay,this._tDur,r),!0),Ys(this),Ld(this)},t.paused=function(i){return arguments.length?(this._ps!==i&&(this._ps=i,i?(this._pTime=this._tTime||Math.max(-this._delay,this.rawTime()),this._ts=this._act=0):(zi(),this._ts=this._rts,this.totalTime(this.parent&&!this.parent.smoothChildTiming?this.rawTime():this._tTime||this._pTime,this.progress()===1&&Math.abs(this._zTime)!==Bt&&(this._tTime-=Bt)))),this):this._ps},t.startTime=function(i){if(arguments.length){this._start=i;var r=this.parent||this._dp;return r&&(r._sort||!this.parent)&&en(r,this,i-this._delay),this}return this._start},t.endTime=function(i){return this._start+(ve(i)?this.totalDuration():this.duration())/Math.abs(this._ts||1)},t.rawTime=function(i){var r=this.parent||this._dp;return r?i&&(!this._ts||this._repeat&&this._time&&this.totalProgress()<1)?this._tTime%(this._dur+this._rDelay):this._ts?Rs(r.rawTime(i),this):this._tTime:this._tTime},t.globalTime=function(i){for(var r=this,s=arguments.length?i:r.rawTime();r;)s=r._start+s/(r._ts||1),r=r._dp;return s},t.repeat=function(i){return arguments.length?(this._repeat=i===1/0?-2:i,Rl(this)):this._repeat===-2?1/0:this._repeat},t.repeatDelay=function(i){if(arguments.length){var r=this._time;return this._rDelay=i,Rl(this),r?this.time(r):this}return this._rDelay},t.yoyo=function(i){return arguments.length?(this._yoyo=i,this):this._yoyo},t.seek=function(i,r){return this.totalTime(De(this,i),ve(r))},t.restart=function(i,r){return this.play().totalTime(i?-this._delay:0,ve(r))},t.play=function(i,r){return i!=null&&this.seek(i,r),this.reversed(!1).paused(!1)},t.reverse=function(i,r){return i!=null&&this.seek(i||this.totalDuration(),r),this.reversed(!0).paused(!1)},t.pause=function(i,r){return i!=null&&this.seek(i,r),this.paused(!0)},t.resume=function(){return this.paused(!1)},t.reversed=function(i){return arguments.length?(!!i!==this.reversed()&&this.timeScale(-this._rts||(i?-Bt:0)),this):this._rts<0},t.invalidate=function(){return this._initted=this._act=0,this._zTime=-Bt,this},t.isActive=function(){var i=this.parent||this._dp,r=this._start,s;return!!(!i||this._ts&&this._initted&&i.isActive()&&(s=i.rawTime(!0))>=r&&s<this.endTime(!0)-Bt)},t.eventCallback=function(i,r,s){var o=this.vars;return arguments.length>1?(r?(o[i]=r,s&&(o[i+"Params"]=s),i==="onUpdate"&&(this._onUpdate=r)):delete o[i],this):o[i]},t.then=function(i){var r=this;return new Promise(function(s){var o=ee(i)?i:Lh,a=function(){var c=r.then;r.then=null,ee(o)&&(o=o(r))&&(o.then||o===r)&&(r.then=c),s(o),r.then=c};r._initted&&r.totalProgress()===1&&r._ts>=0||!r._tTime&&r._ts<0?a():r._prom=a})},t.kill=function(){ur(this)},n}();ke(Cr.prototype,{_time:0,_start:0,_end:0,_tTime:0,_tDur:0,_dirty:0,_repeat:0,_yoyo:!1,parent:null,_initted:!1,_rDelay:0,_ts:1,_dp:0,ratio:0,_zTime:-Bt,_prom:0,_ps:!1,_rts:1});var ye=function(n){ph(t,n);function t(i,r){var s;return i===void 0&&(i={}),s=n.call(this,i)||this,s.labels={},s.smoothChildTiming=!!i.smoothChildTiming,s.autoRemoveChildren=!!i.autoRemoveChildren,s._sort=ve(i.sortChildren),qt&&en(i.parent||qt,dn(s),r),i.reversed&&s.reverse(),i.paused&&s.paused(!0),i.scrollTrigger&&Ph(dn(s),i.scrollTrigger),s}var e=t.prototype;return e.to=function(r,s,o){return _r(0,arguments,this),this},e.from=function(r,s,o){return _r(1,arguments,this),this},e.fromTo=function(r,s,o,a){return _r(2,arguments,this),this},e.set=function(r,s,o){return s.duration=0,s.parent=this,gr(s).repeatDelay||(s.repeat=0),s.immediateRender=!!s.immediateRender,new te(r,s,De(this,o),1),this},e.call=function(r,s,o){return en(this,te.delayedCall(0,r,s),o)},e.staggerTo=function(r,s,o,a,l,c,h){return o.duration=s,o.stagger=o.stagger||a,o.onComplete=c,o.onCompleteParams=h,o.parent=this,new te(r,o,De(this,l)),this},e.staggerFrom=function(r,s,o,a,l,c,h){return o.runBackwards=1,gr(o).immediateRender=ve(o.immediateRender),this.staggerTo(r,s,o,a,l,c,h)},e.staggerFromTo=function(r,s,o,a,l,c,h,u){return a.startAt=o,gr(a).immediateRender=ve(a.immediateRender),this.staggerTo(r,s,a,l,c,h,u)},e.render=function(r,s,o){var a=this._time,l=this._dirty?this.totalDuration():this._tDur,c=this._dur,h=r<=0?0:he(r),u=this._zTime<0!=r<0&&(this._initted||!c),d,f,p,_,x,g,m,S,M,v,y,T;if(this!==qt&&h>l&&r>=0&&(h=l),h!==this._tTime||o||u){if(a!==this._time&&c&&(h+=this._time-a,r+=this._time-a),d=h,M=this._start,S=this._ts,g=!S,u&&(c||(a=this._zTime),(r||!s)&&(this._zTime=r)),this._repeat){if(y=this._yoyo,x=c+this._rDelay,this._repeat<-1&&r<0)return this.totalTime(x*100+r,s,o);if(d=he(h%x),h===l?(_=this._repeat,d=c):(_=~~(h/x),_&&_===h/x&&(d=c,_--),d>c&&(d=c)),v=Oi(this._tTime,x),!a&&this._tTime&&v!==_&&(v=_),y&&_&1&&(d=c-d,T=1),_!==v&&!this._lock){var D=y&&v&1,L=D===(y&&_&1);if(_<v&&(D=!D),a=D?0:c,this._lock=1,this.render(a||(T?0:he(_*x)),s,!c)._lock=0,this._tTime=h,!s&&this.parent&&Ne(this,"onRepeat"),this.vars.repeatRefresh&&!T&&(this.invalidate()._lock=1),a&&a!==this._time||g!==!this._ts||this.vars.onRepeat&&!this.parent&&!this._act)return this;if(c=this._dur,l=this._tDur,L&&(this._lock=2,a=D?c:-1e-4,this.render(a,!0),this.vars.repeatRefresh&&!T&&this.invalidate()),this._lock=0,!this._ts&&!g)return this;Wh(this,T)}}if(this._hasPause&&!this._forcing&&this._lock<2&&(m=Dd(this,he(a),he(d)),m&&(h-=d-(d=m._start))),this._tTime=h,this._time=d,this._act=!S,this._initted||(this._onUpdate=this.vars.onUpdate,this._initted=1,this._zTime=r,a=0),!a&&d&&!s&&(Ne(this,"onStart"),this._tTime!==h))return this;if(d>=a&&r>=0)for(f=this._first;f;){if(p=f._next,(f._act||d>=f._start)&&f._ts&&m!==f){if(f.parent!==this)return this.render(r,s,o);if(f.render(f._ts>0?(d-f._start)*f._ts:(f._dirty?f.totalDuration():f._tDur)+(d-f._start)*f._ts,s,o),d!==this._time||!this._ts&&!g){m=0,p&&(h+=this._zTime=-Bt);break}}f=p}else{f=this._last;for(var F=r<0?r:d;f;){if(p=f._prev,(f._act||F<=f._end)&&f._ts&&m!==f){if(f.parent!==this)return this.render(r,s,o);if(f.render(f._ts>0?(F-f._start)*f._ts:(f._dirty?f.totalDuration():f._tDur)+(F-f._start)*f._ts,s,o),d!==this._time||!this._ts&&!g){m=0,p&&(h+=this._zTime=F?-Bt:Bt);break}}f=p}}if(m&&!s&&(this.pause(),m.render(d>=a?0:-Bt)._zTime=d>=a?1:-1,this._ts))return this._start=M,Ys(this),this.render(r,s,o);this._onUpdate&&!s&&Ne(this,"onUpdate",!0),(h===l&&this._tTime>=this.totalDuration()||!h&&a)&&(M===this._start||Math.abs(S)!==Math.abs(this._ts))&&(this._lock||((r||!c)&&(h===l&&this._ts>0||!h&&this._ts<0)&&fn(this,1),!s&&!(r<0&&!a)&&(h||a||!l)&&(Ne(this,h===l&&r>=0?"onComplete":"onReverseComplete",!0),this._prom&&!(h<l&&this.timeScale()>0)&&this._prom())))}return this},e.add=function(r,s){var o=this;if(mn(s)||(s=De(this,s,r)),!(r instanceof Cr)){if(fe(r))return r.forEach(function(a){return o.add(a,s)}),this;if(ie(r))return this.addLabel(r,s);if(ee(r))r=te.delayedCall(0,r);else return this}return this!==r?en(this,r,s):this},e.getChildren=function(r,s,o,a){r===void 0&&(r=!0),s===void 0&&(s=!0),o===void 0&&(o=!0),a===void 0&&(a=-Ie);for(var l=[],c=this._first;c;)c._start>=a&&(c instanceof te?s&&l.push(c):(o&&l.push(c),r&&l.push.apply(l,c.getChildren(!0,s,o)))),c=c._next;return l},e.getById=function(r){for(var s=this.getChildren(1,1,1),o=s.length;o--;)if(s[o].vars.id===r)return s[o]},e.remove=function(r){return ie(r)?this.removeLabel(r):ee(r)?this.killTweensOf(r):(Xs(this,r),r===this._recent&&(this._recent=this._last),Qn(this))},e.totalTime=function(r,s){return arguments.length?(this._forcing=1,!this._dp&&this._ts&&(this._start=he(Ae.time-(this._ts>0?r/this._ts:(this.totalDuration()-r)/-this._ts))),n.prototype.totalTime.call(this,r,s),this._forcing=0,this):this._tTime},e.addLabel=function(r,s){return this.labels[r]=De(this,s),this},e.removeLabel=function(r){return delete this.labels[r],this},e.addPause=function(r,s,o){var a=te.delayedCall(0,s||Er,o);return a.data="isPause",this._hasPause=1,en(this,a,De(this,r))},e.removePause=function(r){var s=this._first;for(r=De(this,r);s;)s._start===r&&s.data==="isPause"&&fn(s),s=s._next},e.killTweensOf=function(r,s,o){for(var a=this.getTweensOf(r,o),l=a.length;l--;)En!==a[l]&&a[l].kill(r,s);return this},e.getTweensOf=function(r,s){for(var o=[],a=Fe(r),l=this._first,c=mn(s),h;l;)l instanceof te?Td(l._targets,a)&&(c?(!En||l._initted&&l._ts)&&l.globalTime(0)<=s&&l.globalTime(l.totalDuration())>s:!s||l.isActive())&&o.push(l):(h=l.getTweensOf(a,s)).length&&o.push.apply(o,h),l=l._next;return o},e.tweenTo=function(r,s){s=s||{};var o=this,a=De(o,r),l=s,c=l.startAt,h=l.onStart,u=l.onStartParams,d=l.immediateRender,f,p=te.to(o,ke({ease:s.ease||"none",lazy:!1,immediateRender:!1,time:a,overwrite:"auto",duration:s.duration||Math.abs((a-(c&&"time"in c?c.time:o._time))/o.timeScale())||Bt,onStart:function(){if(o.pause(),!f){var x=s.duration||Math.abs((a-(c&&"time"in c?c.time:o._time))/o.timeScale());p._dur!==x&&Bi(p,x,0,1).render(p._time,!0,!0),f=1}h&&h.apply(p,u||[])}},s));return d?p.render(0):p},e.tweenFromTo=function(r,s,o){return this.tweenTo(s,ke({startAt:{time:De(this,r)}},o))},e.recent=function(){return this._recent},e.nextLabel=function(r){return r===void 0&&(r=this._time),Pl(this,De(this,r))},e.previousLabel=function(r){return r===void 0&&(r=this._time),Pl(this,De(this,r),1)},e.currentLabel=function(r){return arguments.length?this.seek(r,!0):this.previousLabel(this._time+Bt)},e.shiftChildren=function(r,s,o){o===void 0&&(o=0);for(var a=this._first,l=this.labels,c;a;)a._start>=o&&(a._start+=r,a._end+=r),a=a._next;if(s)for(c in l)l[c]>=o&&(l[c]+=r);return Qn(this)},e.invalidate=function(){var r=this._first;for(this._lock=0;r;)r.invalidate(),r=r._next;return n.prototype.invalidate.call(this)},e.clear=function(r){r===void 0&&(r=!0);for(var s=this._first,o;s;)o=s._next,this.remove(s),s=o;return this._dp&&(this._time=this._tTime=this._pTime=0),r&&(this.labels={}),Qn(this)},e.totalDuration=function(r){var s=0,o=this,a=o._last,l=Ie,c,h,u;if(arguments.length)return o.timeScale((o._repeat<0?o.duration():o.totalDuration())/(o.reversed()?-r:r));if(o._dirty){for(u=o.parent;a;)c=a._prev,a._dirty&&a.totalDuration(),h=a._start,h>l&&o._sort&&a._ts&&!o._lock?(o._lock=1,en(o,a,h-a._delay,1)._lock=0):l=h,h<0&&a._ts&&(s-=h,(!u&&!o._dp||u&&u.smoothChildTiming)&&(o._start+=h/o._ts,o._time-=h,o._tTime-=h),o.shiftChildren(-h,!1,-1/0),l=0),a._end>s&&a._ts&&(s=a._end),a=c;Bi(o,o===qt&&o._time>s?o._time:s,1,1),o._dirty=0}return o._tDur},t.updateRoot=function(r){if(qt._ts&&(Eh(qt,Rs(r,qt)),Sh=Ae.frame),Ae.frame>=Al){Al+=Ce.autoSleep||120;var s=qt._first;if((!s||!s._ts)&&Ce.autoSleep&&Ae._listeners.length<2){for(;s&&!s._ts;)s=s._next;s||Ae.sleep()}}},t}(Cr);ke(ye.prototype,{_lock:0,_hasPause:0,_forcing:0});var Jd=function(t,e,i,r,s,o,a){var l=new we(this._pt,t,e,0,1,$h,null,s),c=0,h=0,u,d,f,p,_,x,g,m;for(l.b=i,l.e=r,i+="",r+="",(g=~r.indexOf("random("))&&(r=Ar(r)),o&&(m=[i,r],o(m,t,e),i=m[0],r=m[1]),d=i.match(co)||[];u=co.exec(r);)p=u[0],_=r.substring(c,u.index),f?f=(f+1)%5:_.substr(-5)==="rgba("&&(f=1),p!==d[h++]&&(x=parseFloat(d[h-1])||0,l._pt={_next:l._pt,p:_||h===1?_:",",s:x,c:p.charAt(1)==="="?Pi(x,p)-x:parseFloat(p)-x,m:f&&f<4?Math.round:0},c=co.lastIndex);return l.c=c<r.length?r.substring(c,r.length):"",l.fp=a,(yh.test(r)||g)&&(l.e=0),this._pt=l,l},Va=function(t,e,i,r,s,o,a,l,c){ee(r)&&(r=r(s||0,t,o));var h=t[e],u=i!=="get"?i:ee(h)?c?t[e.indexOf("set")||!ee(t["get"+e.substr(3)])?e:"get"+e.substr(3)](c):t[e]():h,d=ee(h)?c?ef:Jh:qa,f;if(ie(r)&&(~r.indexOf("random(")&&(r=Ar(r)),r.charAt(1)==="="&&(f=Pi(u,r)+(de(u)||0),(f||f===0)&&(r=f))),u!==r||sa)return!isNaN(u*r)&&r!==""?(f=new we(this._pt,t,e,+u||0,r-(u||0),typeof h=="boolean"?rf:Qh,0,d),c&&(f.fp=c),a&&f.modifier(a,this,t),this._pt=f):(!h&&!(e in t)&&za(e,r),Jd.call(this,t,e,u,r,d,l||Ce.stringFilter,c))},Qd=function(t,e,i,r,s){if(ee(t)&&(t=xr(t,s,e,i,r)),!gn(t)||t.style&&t.nodeType||fe(t)||_h(t))return ie(t)?xr(t,s,e,i,r):t;var o={},a;for(a in t)o[a]=xr(t[a],s,e,i,r);return o},Xh=function(t,e,i,r,s,o){var a,l,c,h;if(Ee[t]&&(a=new Ee[t]).init(s,a.rawVars?e[t]:Qd(e[t],r,s,o,i),i,r,o)!==!1&&(i._pt=l=new we(i._pt,s,t,0,1,a.render,a,0,a.priority),i!==Ai))for(c=i._ptLookup[i._targets.indexOf(s)],h=a._props.length;h--;)c[a._props[h]]=l;return a},En,sa,Wa=function n(t,e){var i=t.vars,r=i.ease,s=i.startAt,o=i.immediateRender,a=i.lazy,l=i.onUpdate,c=i.onUpdateParams,h=i.callbackScope,u=i.runBackwards,d=i.yoyoEase,f=i.keyframes,p=i.autoRevert,_=t._dur,x=t._startAt,g=t._targets,m=t.parent,S=m&&m.data==="nested"?m.parent._targets:g,M=t._overwrite==="auto"&&!Na,v=t.timeline,y,T,D,L,F,N,k,I,C,P,O,G,Y;if(v&&(!f||!r)&&(r="none"),t._ease=$n(r,Ni.ease),t._yEase=d?Vh($n(d===!0?r:d,Ni.ease)):0,d&&t._yoyo&&!t._repeat&&(d=t._yEase,t._yEase=t._ease,t._ease=d),t._from=!v&&!!i.runBackwards,!v||f&&!i.stagger){if(I=g[0]?Jn(g[0]).harness:0,G=I&&i[I.prop],y=Cs(i,ka),x&&(fn(x.render(-1,!0)),x._lazy=0),s)if(fn(t._startAt=te.set(g,ke({data:"isStart",overwrite:!1,parent:m,immediateRender:!0,lazy:ve(a),startAt:null,delay:0,onUpdate:l,onUpdateParams:c,callbackScope:h,stagger:0},s))),e<0&&!o&&!p&&t._startAt.render(-1,!0),o){if(e>0&&!p&&(t._startAt=0),_&&e<=0){e&&(t._zTime=e);return}}else p===!1&&(t._startAt=0);else if(u&&_){if(x)!p&&(t._startAt=0);else if(e&&(o=!1),D=ke({overwrite:!1,data:"isFromStart",lazy:o&&ve(a),immediateRender:o,stagger:0,parent:m},y),G&&(D[I.prop]=G),fn(t._startAt=te.set(g,D)),e<0&&t._startAt.render(-1,!0),t._zTime=e,!o)n(t._startAt,Bt);else if(!e)return}for(t._pt=t._ptCache=0,a=_&&ve(a)||a&&!_,T=0;T<g.length;T++){if(F=g[T],k=F._gsap||Ha(g)[T]._gsap,t._ptLookup[T]=P={},ea[k.id]&&Rn.length&&Ls(),O=S===g?T:S.indexOf(F),I&&(C=new I).init(F,G||y,t,O,S)!==!1&&(t._pt=L=new we(t._pt,F,C.name,0,1,C.render,C,0,C.priority),C._props.forEach(function(Q){P[Q]=L}),C.priority&&(N=1)),!I||G)for(D in y)Ee[D]&&(C=Xh(D,y,t,O,F,S))?C.priority&&(N=1):P[D]=L=Va.call(t,F,D,"get",y[D],O,S,0,i.stringFilter);t._op&&t._op[T]&&t.kill(F,t._op[T]),M&&t._pt&&(En=t,qt.killTweensOf(F,P,t.globalTime(e)),Y=!t.parent,En=0),t._pt&&a&&(ea[k.id]=1)}N&&Kh(t),t._onInit&&t._onInit(t)}t._onUpdate=l,t._initted=(!t._op||t._pt)&&!Y,f&&e<=0&&v.render(Ie,!0,!0)},$d=function(t,e,i,r,s,o,a){var l=(t._pt&&t._ptCache||(t._ptCache={}))[e],c,h,u;if(!l)for(l=t._ptCache[e]=[],h=t._ptLookup,u=t._targets.length;u--;){if(c=h[u][e],c&&c.d&&c.d._pt)for(c=c.d._pt;c&&c.p!==e;)c=c._next;if(!c)return sa=1,t.vars[e]="+=0",Wa(t,a),sa=0,1;l.push(c)}for(u=l.length;u--;)c=l[u],c.s=(r||r===0)&&!s?r:c.s+(r||0)+o*c.c,c.c=i-c.s,c.e&&(c.e=Zt(i)+de(c.e)),c.b&&(c.b=c.s+de(c.b))},Kd=function(t,e){var i=t[0]?Jn(t[0]).harness:0,r=i&&i.aliases,s,o,a,l;if(!r)return e;s=ii({},e);for(o in r)if(o in s)for(l=r[o].split(","),a=l.length;a--;)s[l[a]]=s[o];return s},tf=function(t,e,i,r){var s=e.ease||r||"power1.inOut",o,a;if(fe(e))a=i[t]||(i[t]=[]),e.forEach(function(l,c){return a.push({t:c/(e.length-1)*100,v:l,e:s})});else for(o in e)a=i[o]||(i[o]=[]),o==="ease"||a.push({t:parseFloat(t),v:e[o],e:s})},xr=function(t,e,i,r,s){return ee(t)?t.call(e,i,r,s):ie(t)&&~t.indexOf("random(")?Ar(t):t},Yh=Ua+"repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",Zh={};be(Yh+",id,stagger,delay,duration,paused,scrollTrigger",function(n){return Zh[n]=1});var te=function(n){ph(t,n);function t(i,r,s,o){var a;typeof r=="number"&&(s.duration=r,r=s,s=null),a=n.call(this,o?r:gr(r))||this;var l=a.vars,c=l.duration,h=l.delay,u=l.immediateRender,d=l.stagger,f=l.overwrite,p=l.keyframes,_=l.defaults,x=l.scrollTrigger,g=l.yoyoEase,m=r.parent||qt,S=(fe(i)||_h(i)?mn(i[0]):"length"in r)?[i]:Fe(i),M,v,y,T,D,L,F,N;if(a._targets=S.length?Ha(S):As("GSAP target "+i+" not found. https://greensock.com",!Ce.nullTargetWarn)||[],a._ptLookup=[],a._overwrite=f,p||d||Xr(c)||Xr(h)){if(r=a.vars,M=a.timeline=new ye({data:"nested",defaults:_||{}}),M.kill(),M.parent=M._dp=dn(a),M._start=0,d||Xr(c)||Xr(h)){if(T=S.length,F=d&&Nh(d),gn(d))for(D in d)~Yh.indexOf(D)&&(N||(N={}),N[D]=d[D]);for(v=0;v<T;v++)y=Cs(r,Zh),y.stagger=0,g&&(y.yoyoEase=g),N&&ii(y,N),L=S[v],y.duration=+xr(c,dn(a),v,L,S),y.delay=(+xr(h,dn(a),v,L,S)||0)-a._delay,!d&&T===1&&y.delay&&(a._delay=h=y.delay,a._start+=h,y.delay=0),M.to(L,y,F?F(v,L,S):0),M._ease=At.none;M.duration()?c=h=0:a.timeline=0}else if(p){gr(ke(M.vars.defaults,{ease:"none"})),M._ease=$n(p.ease||r.ease||"none");var k=0,I,C,P;if(fe(p))p.forEach(function(O){return M.to(S,O,">")});else{y={};for(D in p)D==="ease"||D==="easeEach"||tf(D,p[D],y,p.easeEach);for(D in y)for(I=y[D].sort(function(O,G){return O.t-G.t}),k=0,v=0;v<I.length;v++)C=I[v],P={ease:C.e,duration:(C.t-(v?I[v-1].t:0))/100*c},P[D]=C.v,M.to(S,P,k),k+=P.duration;M.duration()<c&&M.to({},{duration:c-M.duration()})}}c||a.duration(c=M.duration())}else a.timeline=0;return f===!0&&!Na&&(En=dn(a),qt.killTweensOf(S),En=0),en(m,dn(a),s),r.reversed&&a.reverse(),r.paused&&a.paused(!0),(u||!c&&!p&&a._start===he(m._time)&&ve(u)&&Cd(dn(a))&&m.data!=="nested")&&(a._tTime=-Bt,a.render(Math.max(0,-h))),x&&Ph(dn(a),x),a}var e=t.prototype;return e.render=function(r,s,o){var a=this._time,l=this._tDur,c=this._dur,h=r>l-Bt&&r>=0?l:r<Bt?0:r,u,d,f,p,_,x,g,m,S;if(!c)Pd(this,r,s,o);else if(h!==this._tTime||!r||o||!this._initted&&this._tTime||this._startAt&&this._zTime<0!=r<0){if(u=h,m=this.timeline,this._repeat){if(p=c+this._rDelay,this._repeat<-1&&r<0)return this.totalTime(p*100+r,s,o);if(u=he(h%p),h===l?(f=this._repeat,u=c):(f=~~(h/p),f&&f===h/p&&(u=c,f--),u>c&&(u=c)),x=this._yoyo&&f&1,x&&(S=this._yEase,u=c-u),_=Oi(this._tTime,p),u===a&&!o&&this._initted)return this._tTime=h,this;f!==_&&(m&&this._yEase&&Wh(m,x),this.vars.repeatRefresh&&!x&&!this._lock&&(this._lock=o=1,this.render(he(p*f),!0).invalidate()._lock=0))}if(!this._initted){if(Dh(this,r<0?r:u,o,s))return this._tTime=0,this;if(a!==this._time)return this;if(c!==this._dur)return this.render(r,s,o)}if(this._tTime=h,this._time=u,!this._act&&this._ts&&(this._act=1,this._lazy=0),this.ratio=g=(S||this._ease)(u/c),this._from&&(this.ratio=g=1-g),u&&!a&&!s&&(Ne(this,"onStart"),this._tTime!==h))return this;for(d=this._pt;d;)d.r(g,d.d),d=d._next;m&&m.render(r<0?r:!u&&x?-Bt:m._dur*m._ease(u/this._dur),s,o)||this._startAt&&(this._zTime=r),this._onUpdate&&!s&&(r<0&&this._startAt&&this._startAt.render(r,!0,o),Ne(this,"onUpdate")),this._repeat&&f!==_&&this.vars.onRepeat&&!s&&this.parent&&Ne(this,"onRepeat"),(h===this._tDur||!h)&&this._tTime===h&&(r<0&&this._startAt&&!this._onUpdate&&this._startAt.render(r,!0,!0),(r||!c)&&(h===this._tDur&&this._ts>0||!h&&this._ts<0)&&fn(this,1),!s&&!(r<0&&!a)&&(h||a)&&(Ne(this,h===l?"onComplete":"onReverseComplete",!0),this._prom&&!(h<l&&this.timeScale()>0)&&this._prom()))}return this},e.targets=function(){return this._targets},e.invalidate=function(){return this._pt=this._op=this._startAt=this._onUpdate=this._lazy=this.ratio=0,this._ptLookup=[],this.timeline&&this.timeline.invalidate(),n.prototype.invalidate.call(this)},e.resetTo=function(r,s,o,a){Lr||Ae.wake(),this._ts||this.play();var l=Math.min(this._dur,(this._dp._time-this._start)*this._ts),c;return this._initted||Wa(this,l),c=this._ease(l/this._dur),$d(this,r,s,o,a,c,l)?this.resetTo(r,s,o,a):(Ga(this,0),this.parent||Ch(this._dp,this,"_first","_last",this._dp._sort?"_start":0),this.render(0))},e.kill=function(r,s){if(s===void 0&&(s="all"),!r&&(!s||s==="all"))return this._lazy=this._pt=0,this.parent?ur(this):this;if(this.timeline){var o=this.timeline.totalDuration();return this.timeline.killTweensOf(r,s,En&&En.vars.overwrite!==!0)._first||ur(this),this.parent&&o!==this.timeline.totalDuration()&&Bi(this,this._dur*this.timeline._tDur/o,0,1),this}var a=this._targets,l=r?Fe(r):a,c=this._ptLookup,h=this._pt,u,d,f,p,_,x,g;if((!s||s==="all")&&Ad(a,l))return s==="all"&&(this._pt=0),ur(this);for(u=this._op=this._op||[],s!=="all"&&(ie(s)&&(_={},be(s,function(m){return _[m]=1}),s=_),s=Kd(a,s)),g=a.length;g--;)if(~l.indexOf(a[g])){d=c[g],s==="all"?(u[g]=s,p=d,f={}):(f=u[g]=u[g]||{},p=s);for(_ in p)x=d&&d[_],x&&((!("kill"in x.d)||x.d.kill(_)===!0)&&Xs(this,x,"_pt"),delete d[_]),f!=="all"&&(f[_]=1)}return this._initted&&!this._pt&&h&&ur(this),this},t.to=function(r,s){return new t(r,s,arguments[2])},t.from=function(r,s){return _r(1,arguments)},t.delayedCall=function(r,s,o,a){return new t(s,0,{immediateRender:!1,lazy:!1,overwrite:!1,delay:r,onComplete:s,onReverseComplete:s,onCompleteParams:o,onReverseCompleteParams:o,callbackScope:a})},t.fromTo=function(r,s,o){return _r(2,arguments)},t.set=function(r,s){return s.duration=0,s.repeatDelay||(s.repeat=0),new t(r,s)},t.killTweensOf=function(r,s,o){return qt.killTweensOf(r,s,o)},t}(Cr);ke(te.prototype,{_targets:[],_lazy:0,_startAt:0,_op:0,_onInit:0});be("staggerTo,staggerFrom,staggerFromTo",function(n){te[n]=function(){var t=new ye,e=ia.call(arguments,0);return e.splice(n==="staggerFromTo"?5:4,0,0),t[n].apply(t,e)}});var qa=function(t,e,i){return t[e]=i},Jh=function(t,e,i){return t[e](i)},ef=function(t,e,i,r){return t[e](r.fp,i)},nf=function(t,e,i){return t.setAttribute(e,i)},ja=function(t,e){return ee(t[e])?Jh:Oa(t[e])&&t.setAttribute?nf:qa},Qh=function(t,e){return e.set(e.t,e.p,Math.round((e.s+e.c*t)*1e6)/1e6,e)},rf=function(t,e){return e.set(e.t,e.p,!!(e.s+e.c*t),e)},$h=function(t,e){var i=e._pt,r="";if(!t&&e.b)r=e.b;else if(t===1&&e.e)r=e.e;else{for(;i;)r=i.p+(i.m?i.m(i.s+i.c*t):Math.round((i.s+i.c*t)*1e4)/1e4)+r,i=i._next;r+=e.c}e.set(e.t,e.p,r,e)},Xa=function(t,e){for(var i=e._pt;i;)i.r(t,i.d),i=i._next},sf=function(t,e,i,r){for(var s=this._pt,o;s;)o=s._next,s.p===r&&s.modifier(t,e,i),s=o},of=function(t){for(var e=this._pt,i,r;e;)r=e._next,e.p===t&&!e.op||e.op===t?Xs(this,e,"_pt"):e.dep||(i=1),e=r;return!i},af=function(t,e,i,r){r.mSet(t,e,r.m.call(r.tween,i,r.mt),r)},Kh=function(t){for(var e=t._pt,i,r,s,o;e;){for(i=e._next,r=s;r&&r.pr>e.pr;)r=r._next;(e._prev=r?r._prev:o)?e._prev._next=e:s=e,(e._next=r)?r._prev=e:o=e,e=i}t._pt=s},we=function(){function n(e,i,r,s,o,a,l,c,h){this.t=i,this.s=s,this.c=o,this.p=r,this.r=a||Qh,this.d=l||this,this.set=c||qa,this.pr=h||0,this._next=e,e&&(e._prev=this)}var t=n.prototype;return t.modifier=function(i,r,s){this.mSet=this.mSet||this.set,this.set=af,this.m=i,this.mt=s,this.tween=r},n}();be(Ua+"parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger",function(n){return ka[n]=1});Re.TweenMax=Re.TweenLite=te;Re.TimelineLite=Re.TimelineMax=ye;qt=new ye({sortChildren:!1,defaults:Ni,autoRemoveChildren:!0,id:"root",smoothChildTiming:!0});Ce.stringFilter=Gh;var Ps={registerPlugin:function(){for(var t=arguments.length,e=new Array(t),i=0;i<t;i++)e[i]=arguments[i];e.forEach(function(r){return Vd(r)})},timeline:function(t){return new ye(t)},getTweensOf:function(t,e){return qt.getTweensOf(t,e)},getProperty:function(t,e,i,r){ie(t)&&(t=Fe(t)[0]);var s=Jn(t||{}).get,o=i?Lh:Ah;return i==="native"&&(i=""),t&&(e?o((Ee[e]&&Ee[e].get||s)(t,e,i,r)):function(a,l,c){return o((Ee[a]&&Ee[a].get||s)(t,a,l,c))})},quickSetter:function(t,e,i){if(t=Fe(t),t.length>1){var r=t.map(function(h){return Je.quickSetter(h,e,i)}),s=r.length;return function(h){for(var u=s;u--;)r[u](h)}}t=t[0]||{};var o=Ee[e],a=Jn(t),l=a.harness&&(a.harness.aliases||{})[e]||e,c=o?function(h){var u=new o;Ai._pt=0,u.init(t,i?h+i:h,Ai,0,[t]),u.render(1,u),Ai._pt&&Xa(1,Ai)}:a.set(t,l);return o?c:function(h){return c(t,l,i?h+i:h,a,1)}},quickTo:function(t,e,i){var r,s=Je.to(t,ii((r={},r[e]="+=0.1",r.paused=!0,r),i||{})),o=function(l,c,h){return s.resetTo(e,l,c,h)};return o.tween=s,o},isTweening:function(t){return qt.getTweensOf(t,!0).length>0},defaults:function(t){return t&&t.ease&&(t.ease=$n(t.ease,Ni.ease)),Ll(Ni,t||{})},config:function(t){return Ll(Ce,t||{})},registerEffect:function(t){var e=t.name,i=t.effect,r=t.plugins,s=t.defaults,o=t.extendTimeline;(r||"").split(",").forEach(function(a){return a&&!Ee[a]&&!Re[a]&&As(e+" effect requires "+a+" plugin.")}),ho[e]=function(a,l,c){return i(Fe(a),ke(l||{},s),c)},o&&(ye.prototype[e]=function(a,l,c){return this.add(ho[e](a,gn(l)?l:(c=l)&&{},this),c)})},registerEase:function(t,e){At[t]=$n(e)},parseEase:function(t,e){return arguments.length?$n(t,e):At},getById:function(t){return qt.getById(t)},exportRoot:function(t,e){t===void 0&&(t={});var i=new ye(t),r,s;for(i.smoothChildTiming=ve(t.smoothChildTiming),qt.remove(i),i._dp=0,i._time=i._tTime=qt._time,r=qt._first;r;)s=r._next,(e||!(!r._dur&&r instanceof te&&r.vars.onComplete===r._targets[0]))&&en(i,r,r._start-r._delay),r=s;return en(qt,i,0),i},utils:{wrap:Ud,wrapYoyo:Hd,distribute:Nh,random:Bh,snap:Oh,normalize:kd,getUnit:de,clamp:Fd,splitColor:Uh,toArray:Fe,selector:Od,mapRange:kh,pipe:Bd,unitize:zd,interpolate:Gd,shuffle:Fh},install:wh,effects:ho,ticker:Ae,updateRoot:ye.updateRoot,plugins:Ee,globalTimeline:qt,core:{PropTween:we,globals:Mh,Tween:te,Timeline:ye,Animation:Cr,getCache:Jn,_removeLinkedListItem:Xs,suppressOverwrites:function(t){return Na=t}}};be("to,from,fromTo,delayedCall,set,killTweensOf",function(n){return Ps[n]=te[n]});Ae.add(ye.updateRoot);Ai=Ps.to({},{duration:0});var lf=function(t,e){for(var i=t._pt;i&&i.p!==e&&i.op!==e&&i.fp!==e;)i=i._next;return i},cf=function(t,e){var i=t._targets,r,s,o;for(r in e)for(s=i.length;s--;)o=t._ptLookup[s][r],o&&(o=o.d)&&(o._pt&&(o=lf(o,r)),o&&o.modifier&&o.modifier(e[r],t,i[s],r))},mo=function(t,e){return{name:t,rawVars:1,init:function(r,s,o){o._onInit=function(a){var l,c;if(ie(s)&&(l={},be(s,function(h){return l[h]=1}),s=l),e){l={};for(c in s)l[c]=e(s[c]);s=l}cf(a,s)}}}},Je=Ps.registerPlugin({name:"attr",init:function(t,e,i,r,s){var o,a;for(o in e)a=this.add(t,"setAttribute",(t.getAttribute(o)||0)+"",e[o],r,s,0,0,o),a&&(a.op=o),this._props.push(o)}},{name:"endArray",init:function(t,e){for(var i=e.length;i--;)this.add(t,i,t[i]||0,e[i])}},mo("roundProps",ra),mo("modifiers"),mo("snap",Oh))||Ps;te.version=ye.version=Je.version="3.10.4";bh=1;gh()&&zi();At.Power0;At.Power1;At.Power2;At.Power3;At.Power4;At.Linear;At.Quad;At.Cubic;At.Quart;At.Quint;At.Strong;At.Elastic;At.Back;At.SteppedEase;At.Bounce;At.Sine;At.Expo;At.Circ;/*!
 * CSSPlugin 3.10.4
 * https://greensock.com
 *
 * Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/var Il,An,Di,Ya,Yn,Fl,hf=function(){return typeof window!="undefined"},In={},jn=180/Math.PI,Ii=Math.PI/180,ai=Math.atan2,Nl=1e8,tu=/([A-Z])/g,uf=/(left|right|width|margin|padding|x)/i,df=/[\s,\(]\S/,Ln={autoAlpha:"opacity,visibility",scale:"scaleX,scaleY",alpha:"opacity"},eu=function(t,e){return e.set(e.t,e.p,Math.round((e.s+e.c*t)*1e4)/1e4+e.u,e)},ff=function(t,e){return e.set(e.t,e.p,t===1?e.e:Math.round((e.s+e.c*t)*1e4)/1e4+e.u,e)},pf=function(t,e){return e.set(e.t,e.p,t?Math.round((e.s+e.c*t)*1e4)/1e4+e.u:e.b,e)},mf=function(t,e){var i=e.s+e.c*t;e.set(e.t,e.p,~~(i+(i<0?-.5:.5))+e.u,e)},nu=function(t,e){return e.set(e.t,e.p,t?e.e:e.b,e)},iu=function(t,e){return e.set(e.t,e.p,t!==1?e.b:e.e,e)},gf=function(t,e,i){return t.style[e]=i},_f=function(t,e,i){return t.style.setProperty(e,i)},xf=function(t,e,i){return t._gsap[e]=i},yf=function(t,e,i){return t._gsap.scaleX=t._gsap.scaleY=i},vf=function(t,e,i,r,s){var o=t._gsap;o.scaleX=o.scaleY=i,o.renderTransform(s,o)},bf=function(t,e,i,r,s){var o=t._gsap;o[e]=i,o.renderTransform(s,o)},se="transform",Fn=se+"Origin",ru,oa=function(t,e){var i=An.createElementNS?An.createElementNS((e||"http://www.w3.org/1999/xhtml").replace(/^https/,"http"),t):An.createElement(t);return i.style?i:An.createElement(t)},pn=function n(t,e,i){var r=getComputedStyle(t);return r[e]||r.getPropertyValue(e.replace(tu,"-$1").toLowerCase())||r.getPropertyValue(e)||!i&&n(t,ki(e)||e,1)||""},Ol="O,Moz,ms,Ms,Webkit".split(","),ki=function(t,e,i){var r=e||Yn,s=r.style,o=5;if(t in s&&!i)return t;for(t=t.charAt(0).toUpperCase()+t.substr(1);o--&&!(Ol[o]+t in s););return o<0?null:(o===3?"ms":o>=0?Ol[o]:"")+t},aa=function(){hf()&&window.document&&(Il=window,An=Il.document,Di=An.documentElement,Yn=oa("div")||{style:{}},oa("div"),se=ki(se),Fn=se+"Origin",Yn.style.cssText="border-width:0;line-height:0;position:absolute;padding:0",ru=!!ki("perspective"),Ya=1)},go=function n(t){var e=oa("svg",this.ownerSVGElement&&this.ownerSVGElement.getAttribute("xmlns")||"http://www.w3.org/2000/svg"),i=this.parentNode,r=this.nextSibling,s=this.style.cssText,o;if(Di.appendChild(e),e.appendChild(this),this.style.display="block",t)try{o=this.getBBox(),this._gsapBBox=this.getBBox,this.getBBox=n}catch{}else this._gsapBBox&&(o=this._gsapBBox());return i&&(r?i.insertBefore(this,r):i.appendChild(this)),Di.removeChild(e),this.style.cssText=s,o},Bl=function(t,e){for(var i=e.length;i--;)if(t.hasAttribute(e[i]))return t.getAttribute(e[i])},su=function(t){var e;try{e=t.getBBox()}catch{e=go.call(t,!0)}return e&&(e.width||e.height)||t.getBBox===go||(e=go.call(t,!0)),e&&!e.width&&!e.x&&!e.y?{x:+Bl(t,["x","cx","x1"])||0,y:+Bl(t,["y","cy","y1"])||0,width:0,height:0}:e},ou=function(t){return!!(t.getCTM&&(!t.parentNode||t.ownerSVGElement)&&su(t))},Rr=function(t,e){if(e){var i=t.style;e in In&&e!==Fn&&(e=se),i.removeProperty?((e.substr(0,2)==="ms"||e.substr(0,6)==="webkit")&&(e="-"+e),i.removeProperty(e.replace(tu,"-$1").toLowerCase())):i.removeAttribute(e)}},Cn=function(t,e,i,r,s,o){var a=new we(t._pt,e,i,0,1,o?iu:nu);return t._pt=a,a.b=r,a.e=s,t._props.push(i),a},zl={deg:1,rad:1,turn:1},Nn=function n(t,e,i,r){var s=parseFloat(i)||0,o=(i+"").trim().substr((s+"").length)||"px",a=Yn.style,l=uf.test(e),c=t.tagName.toLowerCase()==="svg",h=(c?"client":"offset")+(l?"Width":"Height"),u=100,d=r==="px",f=r==="%",p,_,x,g;return r===o||!s||zl[r]||zl[o]?s:(o!=="px"&&!d&&(s=n(t,e,i,"px")),g=t.getCTM&&ou(t),(f||o==="%")&&(In[e]||~e.indexOf("adius"))?(p=g?t.getBBox()[l?"width":"height"]:t[h],Zt(f?s/p*u:s/100*p)):(a[l?"width":"height"]=u+(d?o:r),_=~e.indexOf("adius")||r==="em"&&t.appendChild&&!c?t:t.parentNode,g&&(_=(t.ownerSVGElement||{}).parentNode),(!_||_===An||!_.appendChild)&&(_=An.body),x=_._gsap,x&&f&&x.width&&l&&x.time===Ae.time?Zt(s/x.width*u):((f||o==="%")&&(a.position=pn(t,"position")),_===t&&(a.position="static"),_.appendChild(Yn),p=Yn[h],_.removeChild(Yn),a.position="absolute",l&&f&&(x=Jn(_),x.time=Ae.time,x.width=_[h]),Zt(d?p*s/u:p&&s?u/p*s:0))))},Xn=function(t,e,i,r){var s;return Ya||aa(),e in Ln&&e!=="transform"&&(e=Ln[e],~e.indexOf(",")&&(e=e.split(",")[0])),In[e]&&e!=="transform"?(s=Dr(t,r),s=e!=="transformOrigin"?s[e]:s.svg?s.origin:Is(pn(t,Fn))+" "+s.zOrigin+"px"):(s=t.style[e],(!s||s==="auto"||r||~(s+"").indexOf("calc("))&&(s=Ds[e]&&Ds[e](t,e,i)||pn(t,e)||Th(t,e)||(e==="opacity"?1:0))),i&&!~(s+"").trim().indexOf(" ")?Nn(t,e,s,i)+i:s},wf=function(t,e,i,r){if(!i||i==="none"){var s=ki(e,t,1),o=s&&pn(t,s,1);o&&o!==i?(e=s,i=o):e==="borderColor"&&(i=pn(t,"borderTopColor"))}var a=new we(this._pt,t.style,e,0,1,$h),l=0,c=0,h,u,d,f,p,_,x,g,m,S,M,v;if(a.b=i,a.e=r,i+="",r+="",r==="auto"&&(t.style[e]=r,r=pn(t,e)||r,t.style[e]=i),h=[i,r],Gh(h),i=h[0],r=h[1],d=i.match(Ei)||[],v=r.match(Ei)||[],v.length){for(;u=Ei.exec(r);)x=u[0],m=r.substring(l,u.index),p?p=(p+1)%5:(m.substr(-5)==="rgba("||m.substr(-5)==="hsla(")&&(p=1),x!==(_=d[c++]||"")&&(f=parseFloat(_)||0,M=_.substr((f+"").length),x.charAt(1)==="="&&(x=Pi(f,x)+M),g=parseFloat(x),S=x.substr((g+"").length),l=Ei.lastIndex-S.length,S||(S=S||Ce.units[e]||M,l===r.length&&(r+=S,a.e+=S)),M!==S&&(f=Nn(t,e,_,S)||0),a._pt={_next:a._pt,p:m||c===1?m:",",s:f,c:g-f,m:p&&p<4||e==="zIndex"?Math.round:0});a.c=l<r.length?r.substring(l,r.length):""}else a.r=e==="display"&&r==="none"?iu:nu;return yh.test(r)&&(a.e=0),this._pt=a,a},kl={top:"0%",bottom:"100%",left:"0%",right:"100%",center:"50%"},Mf=function(t){var e=t.split(" "),i=e[0],r=e[1]||"50%";return(i==="top"||i==="bottom"||r==="left"||r==="right")&&(t=i,i=r,r=t),e[0]=kl[i]||i,e[1]=kl[r]||r,e.join(" ")},Sf=function(t,e){if(e.tween&&e.tween._time===e.tween._dur){var i=e.t,r=i.style,s=e.u,o=i._gsap,a,l,c;if(s==="all"||s===!0)r.cssText="",l=1;else for(s=s.split(","),c=s.length;--c>-1;)a=s[c],In[a]&&(l=1,a=a==="transformOrigin"?Fn:se),Rr(i,a);l&&(Rr(i,se),o&&(o.svg&&i.removeAttribute("transform"),Dr(i,1),o.uncache=1))}},Ds={clearProps:function(t,e,i,r,s){if(s.data!=="isFromStart"){var o=t._pt=new we(t._pt,e,i,0,0,Sf);return o.u=r,o.pr=-10,o.tween=s,t._props.push(i),1}}},Pr=[1,0,0,1,0,0],au={},lu=function(t){return t==="matrix(1, 0, 0, 1, 0, 0)"||t==="none"||!t},Ul=function(t){var e=pn(t,se);return lu(e)?Pr:e.substr(7).match(xh).map(Zt)},Za=function(t,e){var i=t._gsap||Jn(t),r=t.style,s=Ul(t),o,a,l,c;return i.svg&&t.getAttribute("transform")?(l=t.transform.baseVal.consolidate().matrix,s=[l.a,l.b,l.c,l.d,l.e,l.f],s.join(",")==="1,0,0,1,0,0"?Pr:s):(s===Pr&&!t.offsetParent&&t!==Di&&!i.svg&&(l=r.display,r.display="block",o=t.parentNode,(!o||!t.offsetParent)&&(c=1,a=t.nextSibling,Di.appendChild(t)),s=Ul(t),l?r.display=l:Rr(t,"display"),c&&(a?o.insertBefore(t,a):o?o.appendChild(t):Di.removeChild(t))),e&&s.length>6?[s[0],s[1],s[4],s[5],s[12],s[13]]:s)},la=function(t,e,i,r,s,o){var a=t._gsap,l=s||Za(t,!0),c=a.xOrigin||0,h=a.yOrigin||0,u=a.xOffset||0,d=a.yOffset||0,f=l[0],p=l[1],_=l[2],x=l[3],g=l[4],m=l[5],S=e.split(" "),M=parseFloat(S[0])||0,v=parseFloat(S[1])||0,y,T,D,L;i?l!==Pr&&(T=f*x-p*_)&&(D=M*(x/T)+v*(-_/T)+(_*m-x*g)/T,L=M*(-p/T)+v*(f/T)-(f*m-p*g)/T,M=D,v=L):(y=su(t),M=y.x+(~S[0].indexOf("%")?M/100*y.width:M),v=y.y+(~(S[1]||S[0]).indexOf("%")?v/100*y.height:v)),r||r!==!1&&a.smooth?(g=M-c,m=v-h,a.xOffset=u+(g*f+m*_)-g,a.yOffset=d+(g*p+m*x)-m):a.xOffset=a.yOffset=0,a.xOrigin=M,a.yOrigin=v,a.smooth=!!r,a.origin=e,a.originIsAbsolute=!!i,t.style[Fn]="0px 0px",o&&(Cn(o,a,"xOrigin",c,M),Cn(o,a,"yOrigin",h,v),Cn(o,a,"xOffset",u,a.xOffset),Cn(o,a,"yOffset",d,a.yOffset)),t.setAttribute("data-svg-origin",M+" "+v)},Dr=function(t,e){var i=t._gsap||new jh(t);if("x"in i&&!e&&!i.uncache)return i;var r=t.style,s=i.scaleX<0,o="px",a="deg",l=pn(t,Fn)||"0",c,h,u,d,f,p,_,x,g,m,S,M,v,y,T,D,L,F,N,k,I,C,P,O,G,Y,Q,it,et,wt,ot,Et;return c=h=u=p=_=x=g=m=S=0,d=f=1,i.svg=!!(t.getCTM&&ou(t)),y=Za(t,i.svg),i.svg&&(O=(!i.uncache||l==="0px 0px")&&!e&&t.getAttribute("data-svg-origin"),la(t,O||l,!!O||i.originIsAbsolute,i.smooth!==!1,y)),M=i.xOrigin||0,v=i.yOrigin||0,y!==Pr&&(F=y[0],N=y[1],k=y[2],I=y[3],c=C=y[4],h=P=y[5],y.length===6?(d=Math.sqrt(F*F+N*N),f=Math.sqrt(I*I+k*k),p=F||N?ai(N,F)*jn:0,g=k||I?ai(k,I)*jn+p:0,g&&(f*=Math.abs(Math.cos(g*Ii))),i.svg&&(c-=M-(M*F+v*k),h-=v-(M*N+v*I))):(Et=y[6],wt=y[7],Q=y[8],it=y[9],et=y[10],ot=y[11],c=y[12],h=y[13],u=y[14],T=ai(Et,et),_=T*jn,T&&(D=Math.cos(-T),L=Math.sin(-T),O=C*D+Q*L,G=P*D+it*L,Y=Et*D+et*L,Q=C*-L+Q*D,it=P*-L+it*D,et=Et*-L+et*D,ot=wt*-L+ot*D,C=O,P=G,Et=Y),T=ai(-k,et),x=T*jn,T&&(D=Math.cos(-T),L=Math.sin(-T),O=F*D-Q*L,G=N*D-it*L,Y=k*D-et*L,ot=I*L+ot*D,F=O,N=G,k=Y),T=ai(N,F),p=T*jn,T&&(D=Math.cos(T),L=Math.sin(T),O=F*D+N*L,G=C*D+P*L,N=N*D-F*L,P=P*D-C*L,F=O,C=G),_&&Math.abs(_)+Math.abs(p)>359.9&&(_=p=0,x=180-x),d=Zt(Math.sqrt(F*F+N*N+k*k)),f=Zt(Math.sqrt(P*P+Et*Et)),T=ai(C,P),g=Math.abs(T)>2e-4?T*jn:0,S=ot?1/(ot<0?-ot:ot):0),i.svg&&(O=t.getAttribute("transform"),i.forceCSS=t.setAttribute("transform","")||!lu(pn(t,se)),O&&t.setAttribute("transform",O))),Math.abs(g)>90&&Math.abs(g)<270&&(s?(d*=-1,g+=p<=0?180:-180,p+=p<=0?180:-180):(f*=-1,g+=g<=0?180:-180)),e=e||i.uncache,i.x=c-((i.xPercent=c&&(!e&&i.xPercent||(Math.round(t.offsetWidth/2)===Math.round(-c)?-50:0)))?t.offsetWidth*i.xPercent/100:0)+o,i.y=h-((i.yPercent=h&&(!e&&i.yPercent||(Math.round(t.offsetHeight/2)===Math.round(-h)?-50:0)))?t.offsetHeight*i.yPercent/100:0)+o,i.z=u+o,i.scaleX=Zt(d),i.scaleY=Zt(f),i.rotation=Zt(p)+a,i.rotationX=Zt(_)+a,i.rotationY=Zt(x)+a,i.skewX=g+a,i.skewY=m+a,i.transformPerspective=S+o,(i.zOrigin=parseFloat(l.split(" ")[2])||0)&&(r[Fn]=Is(l)),i.xOffset=i.yOffset=0,i.force3D=Ce.force3D,i.renderTransform=i.svg?Ef:ru?cu:Tf,i.uncache=0,i},Is=function(t){return(t=t.split(" "))[0]+" "+t[1]},_o=function(t,e,i){var r=de(e);return Zt(parseFloat(e)+parseFloat(Nn(t,"x",i+"px",r)))+r},Tf=function(t,e){e.z="0px",e.rotationY=e.rotationX="0deg",e.force3D=0,cu(t,e)},Un="0deg",tr="0px",Hn=") ",cu=function(t,e){var i=e||this,r=i.xPercent,s=i.yPercent,o=i.x,a=i.y,l=i.z,c=i.rotation,h=i.rotationY,u=i.rotationX,d=i.skewX,f=i.skewY,p=i.scaleX,_=i.scaleY,x=i.transformPerspective,g=i.force3D,m=i.target,S=i.zOrigin,M="",v=g==="auto"&&t&&t!==1||g===!0;if(S&&(u!==Un||h!==Un)){var y=parseFloat(h)*Ii,T=Math.sin(y),D=Math.cos(y),L;y=parseFloat(u)*Ii,L=Math.cos(y),o=_o(m,o,T*L*-S),a=_o(m,a,-Math.sin(y)*-S),l=_o(m,l,D*L*-S+S)}x!==tr&&(M+="perspective("+x+Hn),(r||s)&&(M+="translate("+r+"%, "+s+"%) "),(v||o!==tr||a!==tr||l!==tr)&&(M+=l!==tr||v?"translate3d("+o+", "+a+", "+l+") ":"translate("+o+", "+a+Hn),c!==Un&&(M+="rotate("+c+Hn),h!==Un&&(M+="rotateY("+h+Hn),u!==Un&&(M+="rotateX("+u+Hn),(d!==Un||f!==Un)&&(M+="skew("+d+", "+f+Hn),(p!==1||_!==1)&&(M+="scale("+p+", "+_+Hn),m.style[se]=M||"translate(0, 0)"},Ef=function(t,e){var i=e||this,r=i.xPercent,s=i.yPercent,o=i.x,a=i.y,l=i.rotation,c=i.skewX,h=i.skewY,u=i.scaleX,d=i.scaleY,f=i.target,p=i.xOrigin,_=i.yOrigin,x=i.xOffset,g=i.yOffset,m=i.forceCSS,S=parseFloat(o),M=parseFloat(a),v,y,T,D,L;l=parseFloat(l),c=parseFloat(c),h=parseFloat(h),h&&(h=parseFloat(h),c+=h,l+=h),l||c?(l*=Ii,c*=Ii,v=Math.cos(l)*u,y=Math.sin(l)*u,T=Math.sin(l-c)*-d,D=Math.cos(l-c)*d,c&&(h*=Ii,L=Math.tan(c-h),L=Math.sqrt(1+L*L),T*=L,D*=L,h&&(L=Math.tan(h),L=Math.sqrt(1+L*L),v*=L,y*=L)),v=Zt(v),y=Zt(y),T=Zt(T),D=Zt(D)):(v=u,D=d,y=T=0),(S&&!~(o+"").indexOf("px")||M&&!~(a+"").indexOf("px"))&&(S=Nn(f,"x",o,"px"),M=Nn(f,"y",a,"px")),(p||_||x||g)&&(S=Zt(S+p-(p*v+_*T)+x),M=Zt(M+_-(p*y+_*D)+g)),(r||s)&&(L=f.getBBox(),S=Zt(S+r/100*L.width),M=Zt(M+s/100*L.height)),L="matrix("+v+","+y+","+T+","+D+","+S+","+M+")",f.setAttribute("transform",L),m&&(f.style[se]=L)},Af=function(t,e,i,r,s){var o=360,a=ie(s),l=parseFloat(s)*(a&&~s.indexOf("rad")?jn:1),c=l-r,h=r+c+"deg",u,d;return a&&(u=s.split("_")[1],u==="short"&&(c%=o,c!==c%(o/2)&&(c+=c<0?o:-o)),u==="cw"&&c<0?c=(c+o*Nl)%o-~~(c/o)*o:u==="ccw"&&c>0&&(c=(c-o*Nl)%o-~~(c/o)*o)),t._pt=d=new we(t._pt,e,i,r,c,ff),d.e=h,d.u="deg",t._props.push(i),d},Hl=function(t,e){for(var i in e)t[i]=e[i];return t},Lf=function(t,e,i){var r=Hl({},i._gsap),s="perspective,force3D,transformOrigin,svgOrigin",o=i.style,a,l,c,h,u,d,f,p;r.svg?(c=i.getAttribute("transform"),i.setAttribute("transform",""),o[se]=e,a=Dr(i,1),Rr(i,se),i.setAttribute("transform",c)):(c=getComputedStyle(i)[se],o[se]=e,a=Dr(i,1),o[se]=c);for(l in In)c=r[l],h=a[l],c!==h&&s.indexOf(l)<0&&(f=de(c),p=de(h),u=f!==p?Nn(i,l,c,p):parseFloat(c),d=parseFloat(h),t._pt=new we(t._pt,a,l,u,d-u,eu),t._pt.u=p||0,t._props.push(l));Hl(a,r)};be("padding,margin,Width,Radius",function(n,t){var e="Top",i="Right",r="Bottom",s="Left",o=(t<3?[e,i,r,s]:[e+s,e+i,r+i,r+s]).map(function(a){return t<2?n+a:"border"+a+n});Ds[t>1?"border"+n:n]=function(a,l,c,h,u){var d,f;if(arguments.length<4)return d=o.map(function(p){return Xn(a,p,c)}),f=d.join(" "),f.split(d[0]).length===5?d[0]:f;d=(h+"").split(" "),f={},o.forEach(function(p,_){return f[p]=d[_]=d[_]||d[(_-1)/2|0]}),a.init(l,f,u)}});var hu={name:"css",register:aa,targetTest:function(t){return t.style&&t.nodeType},init:function(t,e,i,r,s){var o=this._props,a=t.style,l=i.vars.startAt,c,h,u,d,f,p,_,x,g,m,S,M,v,y,T;Ya||aa();for(_ in e)if(_!=="autoRound"&&(h=e[_],!(Ee[_]&&Xh(_,e,i,r,t,s)))){if(f=typeof h,p=Ds[_],f==="function"&&(h=h.call(i,r,t,s),f=typeof h),f==="string"&&~h.indexOf("random(")&&(h=Ar(h)),p)p(this,t,_,h,i)&&(T=1);else if(_.substr(0,2)==="--")c=(getComputedStyle(t).getPropertyValue(_)+"").trim(),h+="",Pn.lastIndex=0,Pn.test(c)||(x=de(c),g=de(h)),g?x!==g&&(c=Nn(t,_,c,g)+g):x&&(h+=x),this.add(a,"setProperty",c,h,r,s,0,0,_),o.push(_);else if(f!=="undefined"){if(l&&_ in l?(c=typeof l[_]=="function"?l[_].call(i,r,t,s):l[_],ie(c)&&~c.indexOf("random(")&&(c=Ar(c)),de(c+"")||(c+=Ce.units[_]||de(Xn(t,_))||""),(c+"").charAt(1)==="="&&(c=Xn(t,_))):c=Xn(t,_),d=parseFloat(c),m=f==="string"&&h.charAt(1)==="="&&h.substr(0,2),m&&(h=h.substr(2)),u=parseFloat(h),_ in Ln&&(_==="autoAlpha"&&(d===1&&Xn(t,"visibility")==="hidden"&&u&&(d=0),Cn(this,a,"visibility",d?"inherit":"hidden",u?"inherit":"hidden",!u)),_!=="scale"&&_!=="transform"&&(_=Ln[_],~_.indexOf(",")&&(_=_.split(",")[0]))),S=_ in In,S){if(M||(v=t._gsap,v.renderTransform&&!e.parseTransform||Dr(t,e.parseTransform),y=e.smoothOrigin!==!1&&v.smooth,M=this._pt=new we(this._pt,a,se,0,1,v.renderTransform,v,0,-1),M.dep=1),_==="scale")this._pt=new we(this._pt,v,"scaleY",v.scaleY,(m?Pi(v.scaleY,m+u):u)-v.scaleY||0),o.push("scaleY",_),_+="X";else if(_==="transformOrigin"){h=Mf(h),v.svg?la(t,h,0,y,0,this):(g=parseFloat(h.split(" ")[2])||0,g!==v.zOrigin&&Cn(this,v,"zOrigin",v.zOrigin,g),Cn(this,a,_,Is(c),Is(h)));continue}else if(_==="svgOrigin"){la(t,h,1,y,0,this);continue}else if(_ in au){Af(this,v,_,d,m?Pi(d,m+h):h);continue}else if(_==="smoothOrigin"){Cn(this,v,"smooth",v.smooth,h);continue}else if(_==="force3D"){v[_]=h;continue}else if(_==="transform"){Lf(this,h,t);continue}}else _ in a||(_=ki(_)||_);if(S||(u||u===0)&&(d||d===0)&&!df.test(h)&&_ in a)x=(c+"").substr((d+"").length),u||(u=0),g=de(h)||(_ in Ce.units?Ce.units[_]:x),x!==g&&(d=Nn(t,_,c,g)),this._pt=new we(this._pt,S?v:a,_,d,(m?Pi(d,m+u):u)-d,!S&&(g==="px"||_==="zIndex")&&e.autoRound!==!1?mf:eu),this._pt.u=g||0,x!==g&&g!=="%"&&(this._pt.b=c,this._pt.r=pf);else if(_ in a)wf.call(this,t,_,c,m?m+h:h);else if(_ in t)this.add(t,_,c||t[_],m?m+h:h,r,s);else{za(_,h);continue}o.push(_)}}T&&Kh(this)},get:Xn,aliases:Ln,getSetter:function(t,e,i){var r=Ln[e];return r&&r.indexOf(",")<0&&(e=r),e in In&&e!==Fn&&(t._gsap.x||Xn(t,"x"))?i&&Fl===i?e==="scale"?yf:xf:(Fl=i||{})&&(e==="scale"?vf:bf):t.style&&!Oa(t.style[e])?gf:~e.indexOf("-")?_f:ja(t,e)},core:{_removeProperty:Rr,_getMatrix:Za}};Je.utils.checkPrefix=ki;(function(n,t,e,i){var r=be(n+","+t+","+e,function(s){In[s]=1});be(t,function(s){Ce.units[s]="deg",au[s]=1}),Ln[r[13]]=n+","+t,be(i,function(s){var o=s.split(":");Ln[o[1]]=r[o[0]]})})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent","rotation,rotationX,rotationY,skewX,skewY","transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective","0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");be("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective",function(n){Ce.units[n]="px"});Je.registerPlugin(hu);var uu=Je.registerPlugin(hu)||Je;uu.core.Tween;const du="126",Cf=0,Gl=1,Rf=2,fu=1,Pf=2,fr=3,Zs=0,Kt=1,Vr=2,Ja=1,yr=0,vr=1,Vl=2,Wl=3,ql=4,Df=5,Ti=100,If=101,Ff=102,jl=103,Xl=104,Nf=200,Of=201,Bf=202,zf=203,pu=204,mu=205,kf=206,Uf=207,Hf=208,Gf=209,Vf=210,Wf=0,qf=1,jf=2,ca=3,Xf=4,Yf=5,Zf=6,Jf=7,Js=0,Qf=1,$f=2,br=0,Kf=1,tp=2,ep=3,np=4,ip=5,gu=300,Qa=301,$a=302,Yl=303,Zl=304,Ka=306,tl=307,ha=1e3,Le=1001,ua=1002,pe=1003,Jl=1004,Ql=1005,oe=1006,rp=1007,Qs=1008,el=1009,sp=1010,op=1011,Fs=1012,ap=1013,Ts=1014,Tn=1015,Ns=1016,lp=1017,cp=1018,hp=1019,wr=1020,up=1021,Kn=1022,Ye=1023,dp=1024,fp=1025,Fi=1026,Ir=1027,pp=1028,mp=1029,gp=1030,_p=1031,xp=1032,yp=1033,$l=33776,Kl=33777,tc=33778,ec=33779,nc=35840,ic=35841,rc=35842,sc=35843,vp=36196,oc=37492,ac=37496,bp=37808,wp=37809,Mp=37810,Sp=37811,Tp=37812,Ep=37813,Ap=37814,Lp=37815,Cp=37816,Rp=37817,Pp=37818,Dp=37819,Ip=37820,Fp=37821,Np=36492,Op=37840,Bp=37841,zp=37842,kp=37843,Up=37844,Hp=37845,Gp=37846,Vp=37847,Wp=37848,qp=37849,jp=37850,Xp=37851,Yp=37852,Zp=37853,Jp=2200,Qp=2201,$p=2202,Os=2300,Bs=2301,xo=2302,Li=2400,Ci=2401,zs=2402,nl=2500,_u=2501,Kp=0,Wr=3e3,xu=3001,tm=3007,em=3002,nm=3003,im=3004,rm=3005,sm=3006,om=3200,am=3201,Wi=0,lm=1,yo=7680,cm=519,$s=35044,Fr=35048,lc="300 es";function kn(){}Object.assign(kn.prototype,{addEventListener:function(n,t){this._listeners===void 0&&(this._listeners={});const e=this._listeners;e[n]===void 0&&(e[n]=[]),e[n].indexOf(t)===-1&&e[n].push(t)},hasEventListener:function(n,t){if(this._listeners===void 0)return!1;const e=this._listeners;return e[n]!==void 0&&e[n].indexOf(t)!==-1},removeEventListener:function(n,t){if(this._listeners===void 0)return;const i=this._listeners[n];if(i!==void 0){const r=i.indexOf(t);r!==-1&&i.splice(r,1)}},dispatchEvent:function(n){if(this._listeners===void 0)return;const e=this._listeners[n.type];if(e!==void 0){n.target=this;const i=e.slice(0);for(let r=0,s=i.length;r<s;r++)i[r].call(this,n)}}});const re=[];for(let n=0;n<256;n++)re[n]=(n<16?"0":"")+n.toString(16);let Yr=1234567;const bt={DEG2RAD:Math.PI/180,RAD2DEG:180/Math.PI,generateUUID:function(){const n=Math.random()*4294967295|0,t=Math.random()*4294967295|0,e=Math.random()*4294967295|0,i=Math.random()*4294967295|0;return(re[n&255]+re[n>>8&255]+re[n>>16&255]+re[n>>24&255]+"-"+re[t&255]+re[t>>8&255]+"-"+re[t>>16&15|64]+re[t>>24&255]+"-"+re[e&63|128]+re[e>>8&255]+"-"+re[e>>16&255]+re[e>>24&255]+re[i&255]+re[i>>8&255]+re[i>>16&255]+re[i>>24&255]).toUpperCase()},clamp:function(n,t,e){return Math.max(t,Math.min(e,n))},euclideanModulo:function(n,t){return(n%t+t)%t},mapLinear:function(n,t,e,i,r){return i+(n-t)*(r-i)/(e-t)},lerp:function(n,t,e){return(1-e)*n+e*t},damp:function(n,t,e,i){return bt.lerp(n,t,1-Math.exp(-e*i))},pingpong:function(n,t=1){return t-Math.abs(bt.euclideanModulo(n,t*2)-t)},smoothstep:function(n,t,e){return n<=t?0:n>=e?1:(n=(n-t)/(e-t),n*n*(3-2*n))},smootherstep:function(n,t,e){return n<=t?0:n>=e?1:(n=(n-t)/(e-t),n*n*n*(n*(n*6-15)+10))},randInt:function(n,t){return n+Math.floor(Math.random()*(t-n+1))},randFloat:function(n,t){return n+Math.random()*(t-n)},randFloatSpread:function(n){return n*(.5-Math.random())},seededRandom:function(n){return n!==void 0&&(Yr=n%2147483647),Yr=Yr*16807%2147483647,(Yr-1)/2147483646},degToRad:function(n){return n*bt.DEG2RAD},radToDeg:function(n){return n*bt.RAD2DEG},isPowerOfTwo:function(n){return(n&n-1)===0&&n!==0},ceilPowerOfTwo:function(n){return Math.pow(2,Math.ceil(Math.log(n)/Math.LN2))},floorPowerOfTwo:function(n){return Math.pow(2,Math.floor(Math.log(n)/Math.LN2))},setQuaternionFromProperEuler:function(n,t,e,i,r){const s=Math.cos,o=Math.sin,a=s(e/2),l=o(e/2),c=s((t+i)/2),h=o((t+i)/2),u=s((t-i)/2),d=o((t-i)/2),f=s((i-t)/2),p=o((i-t)/2);switch(r){case"XYX":n.set(a*h,l*u,l*d,a*c);break;case"YZY":n.set(l*d,a*h,l*u,a*c);break;case"ZXZ":n.set(l*u,l*d,a*h,a*c);break;case"XZX":n.set(a*h,l*p,l*f,a*c);break;case"YXY":n.set(l*f,a*h,l*p,a*c);break;case"ZYZ":n.set(l*p,l*f,a*h,a*c);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+r)}}};class J{constructor(t=0,e=0){this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this)}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this)}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,i=this.y,r=t.elements;return this.x=r[0]*e+r[3]*i+r[6],this.y=r[1]*e+r[4]*i+r[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,i=this.y-t.y;return e*e+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e,i){return i!==void 0&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const i=Math.cos(e),r=Math.sin(e),s=this.x-t.x,o=this.y-t.y;return this.x=s*i-o*r+t.x,this.y=s*r+o*i+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}}J.prototype.isVector2=!0;class ae{constructor(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(t,e,i,r,s,o,a,l,c){const h=this.elements;return h[0]=t,h[1]=r,h[2]=a,h[3]=e,h[4]=s,h[5]=l,h[6]=i,h[7]=o,h[8]=c,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,i=t.elements;return e[0]=i[0],e[1]=i[1],e[2]=i[2],e[3]=i[3],e[4]=i[4],e[5]=i[5],e[6]=i[6],e[7]=i[7],e[8]=i[8],this}extractBasis(t,e,i){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),i.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const i=t.elements,r=e.elements,s=this.elements,o=i[0],a=i[3],l=i[6],c=i[1],h=i[4],u=i[7],d=i[2],f=i[5],p=i[8],_=r[0],x=r[3],g=r[6],m=r[1],S=r[4],M=r[7],v=r[2],y=r[5],T=r[8];return s[0]=o*_+a*m+l*v,s[3]=o*x+a*S+l*y,s[6]=o*g+a*M+l*T,s[1]=c*_+h*m+u*v,s[4]=c*x+h*S+u*y,s[7]=c*g+h*M+u*T,s[2]=d*_+f*m+p*v,s[5]=d*x+f*S+p*y,s[8]=d*g+f*M+p*T,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],i=t[1],r=t[2],s=t[3],o=t[4],a=t[5],l=t[6],c=t[7],h=t[8];return e*o*h-e*a*c-i*s*h+i*a*l+r*s*c-r*o*l}invert(){const t=this.elements,e=t[0],i=t[1],r=t[2],s=t[3],o=t[4],a=t[5],l=t[6],c=t[7],h=t[8],u=h*o-a*c,d=a*l-h*s,f=c*s-o*l,p=e*u+i*d+r*f;if(p===0)return this.set(0,0,0,0,0,0,0,0,0);const _=1/p;return t[0]=u*_,t[1]=(r*c-h*i)*_,t[2]=(a*i-r*o)*_,t[3]=d*_,t[4]=(h*e-r*l)*_,t[5]=(r*s-a*e)*_,t[6]=f*_,t[7]=(i*l-c*e)*_,t[8]=(o*e-i*s)*_,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,i,r,s,o,a){const l=Math.cos(s),c=Math.sin(s);return this.set(i*l,i*c,-i*(l*o+c*a)+o+t,-r*c,r*l,-r*(-c*o+l*a)+a+e,0,0,1),this}scale(t,e){const i=this.elements;return i[0]*=t,i[3]*=t,i[6]*=t,i[1]*=e,i[4]*=e,i[7]*=e,this}rotate(t){const e=Math.cos(t),i=Math.sin(t),r=this.elements,s=r[0],o=r[3],a=r[6],l=r[1],c=r[4],h=r[7];return r[0]=e*s+i*l,r[3]=e*o+i*c,r[6]=e*a+i*h,r[1]=-i*s+e*l,r[4]=-i*o+e*c,r[7]=-i*a+e*h,this}translate(t,e){const i=this.elements;return i[0]+=t*i[2],i[3]+=t*i[5],i[6]+=t*i[8],i[1]+=e*i[2],i[4]+=e*i[5],i[7]+=e*i[8],this}equals(t){const e=this.elements,i=t.elements;for(let r=0;r<9;r++)if(e[r]!==i[r])return!1;return!0}fromArray(t,e=0){for(let i=0;i<9;i++)this.elements[i]=t[i+e];return this}toArray(t=[],e=0){const i=this.elements;return t[e]=i[0],t[e+1]=i[1],t[e+2]=i[2],t[e+3]=i[3],t[e+4]=i[4],t[e+5]=i[5],t[e+6]=i[6],t[e+7]=i[7],t[e+8]=i[8],t}clone(){return new this.constructor().fromArray(this.elements)}}ae.prototype.isMatrix3=!0;let li;const qi={getDataURL:function(n){if(/^data:/i.test(n.src)||typeof HTMLCanvasElement=="undefined")return n.src;let t;if(n instanceof HTMLCanvasElement)t=n;else{li===void 0&&(li=document.createElementNS("http://www.w3.org/1999/xhtml","canvas")),li.width=n.width,li.height=n.height;const e=li.getContext("2d");n instanceof ImageData?e.putImageData(n,0,0):e.drawImage(n,0,0,n.width,n.height),t=li}return t.width>2048||t.height>2048?t.toDataURL("image/jpeg",.6):t.toDataURL("image/png")}};let hm=0;class le extends kn{constructor(t=le.DEFAULT_IMAGE,e=le.DEFAULT_MAPPING,i=Le,r=Le,s=oe,o=Qs,a=Ye,l=el,c=1,h=Wr){super(),Object.defineProperty(this,"id",{value:hm++}),this.uuid=bt.generateUUID(),this.name="",this.image=t,this.mipmaps=[],this.mapping=e,this.wrapS=i,this.wrapT=r,this.magFilter=s,this.minFilter=o,this.anisotropy=c,this.format=a,this.internalFormat=null,this.type=l,this.offset=new J(0,0),this.repeat=new J(1,1),this.center=new J(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new ae,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=h,this.version=0,this.onUpdate=null}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(t){return this.name=t.name,this.image=t.image,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.encoding=t.encoding,this}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.textures[this.uuid]!==void 0)return t.textures[this.uuid];const i={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(this.image!==void 0){const r=this.image;if(r.uuid===void 0&&(r.uuid=bt.generateUUID()),!e&&t.images[r.uuid]===void 0){let s;if(Array.isArray(r)){s=[];for(let o=0,a=r.length;o<a;o++)r[o].isDataTexture?s.push(vo(r[o].image)):s.push(vo(r[o]))}else s=vo(r);t.images[r.uuid]={uuid:r.uuid,url:s}}i.image=r.uuid}return e||(t.textures[this.uuid]=i),i}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(this.mapping!==gu)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case ha:t.x=t.x-Math.floor(t.x);break;case Le:t.x=t.x<0?0:1;break;case ua:Math.abs(Math.floor(t.x)%2)===1?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x);break}if(t.y<0||t.y>1)switch(this.wrapT){case ha:t.y=t.y-Math.floor(t.y);break;case Le:t.y=t.y<0?0:1;break;case ua:Math.abs(Math.floor(t.y)%2)===1?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y);break}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){t===!0&&this.version++}}le.DEFAULT_IMAGE=void 0;le.DEFAULT_MAPPING=gu;le.prototype.isTexture=!0;function vo(n){return typeof HTMLImageElement!="undefined"&&n instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&n instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&n instanceof ImageBitmap?qi.getDataURL(n):n.data?{data:Array.prototype.slice.call(n.data),width:n.width,height:n.height,type:n.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}class Ft{constructor(t=0,e=0,i=0,r=1){this.x=t,this.y=e,this.z=i,this.w=r}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,i,r){return this.x=t,this.y=e,this.z=i,this.w=r,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w!==void 0?t.w:1,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,i=this.y,r=this.z,s=this.w,o=t.elements;return this.x=o[0]*e+o[4]*i+o[8]*r+o[12]*s,this.y=o[1]*e+o[5]*i+o[9]*r+o[13]*s,this.z=o[2]*e+o[6]*i+o[10]*r+o[14]*s,this.w=o[3]*e+o[7]*i+o[11]*r+o[15]*s,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,i,r,s;const l=t.elements,c=l[0],h=l[4],u=l[8],d=l[1],f=l[5],p=l[9],_=l[2],x=l[6],g=l[10];if(Math.abs(h-d)<.01&&Math.abs(u-_)<.01&&Math.abs(p-x)<.01){if(Math.abs(h+d)<.1&&Math.abs(u+_)<.1&&Math.abs(p+x)<.1&&Math.abs(c+f+g-3)<.1)return this.set(1,0,0,0),this;e=Math.PI;const S=(c+1)/2,M=(f+1)/2,v=(g+1)/2,y=(h+d)/4,T=(u+_)/4,D=(p+x)/4;return S>M&&S>v?S<.01?(i=0,r=.707106781,s=.707106781):(i=Math.sqrt(S),r=y/i,s=T/i):M>v?M<.01?(i=.707106781,r=0,s=.707106781):(r=Math.sqrt(M),i=y/r,s=D/r):v<.01?(i=.707106781,r=.707106781,s=0):(s=Math.sqrt(v),i=T/s,r=D/s),this.set(i,r,s,e),this}let m=Math.sqrt((x-p)*(x-p)+(u-_)*(u-_)+(d-h)*(d-h));return Math.abs(m)<.001&&(m=1),this.x=(x-p)/m,this.y=(u-_)/m,this.z=(d-h)/m,this.w=Math.acos((c+f+g-1)/2),this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this.z=t.z+(e.z-t.z)*i,this.w=t.w+(e.w-t.w)*i,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e,i){return i!==void 0&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}}Ft.prototype.isVector4=!0;class ti extends kn{constructor(t,e,i){super(),this.width=t,this.height=e,this.depth=1,this.scissor=new Ft(0,0,t,e),this.scissorTest=!1,this.viewport=new Ft(0,0,t,e),i=i||{},this.texture=new le(void 0,i.mapping,i.wrapS,i.wrapT,i.magFilter,i.minFilter,i.format,i.type,i.anisotropy,i.encoding),this.texture.image={},this.texture.image.width=t,this.texture.image.height=e,this.texture.image.depth=1,this.texture.generateMipmaps=i.generateMipmaps!==void 0?i.generateMipmaps:!1,this.texture.minFilter=i.minFilter!==void 0?i.minFilter:oe,this.depthBuffer=i.depthBuffer!==void 0?i.depthBuffer:!0,this.stencilBuffer=i.stencilBuffer!==void 0?i.stencilBuffer:!1,this.depthTexture=i.depthTexture!==void 0?i.depthTexture:null}setTexture(t){t.image={width:this.width,height:this.height,depth:this.depth},this.texture=t}setSize(t,e,i=1){(this.width!==t||this.height!==e||this.depth!==i)&&(this.width=t,this.height=e,this.depth=i,this.texture.image.width=t,this.texture.image.height=e,this.texture.image.depth=i,this.dispose()),this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}clone(){return new this.constructor().copy(this)}copy(t){return this.width=t.width,this.height=t.height,this.depth=t.depth,this.viewport.copy(t.viewport),this.texture=t.texture.clone(),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.depthTexture=t.depthTexture,this}dispose(){this.dispatchEvent({type:"dispose"})}}ti.prototype.isWebGLRenderTarget=!0;class um extends ti{constructor(t,e,i){super(t,e,i),this.samples=4}copy(t){return super.copy.call(this,t),this.samples=t.samples,this}}um.prototype.isWebGLMultisampleRenderTarget=!0;class me{constructor(t=0,e=0,i=0,r=1){this._x=t,this._y=e,this._z=i,this._w=r}static slerp(t,e,i,r){return i.copy(t).slerp(e,r)}static slerpFlat(t,e,i,r,s,o,a){let l=i[r+0],c=i[r+1],h=i[r+2],u=i[r+3];const d=s[o+0],f=s[o+1],p=s[o+2],_=s[o+3];if(a===0){t[e+0]=l,t[e+1]=c,t[e+2]=h,t[e+3]=u;return}if(a===1){t[e+0]=d,t[e+1]=f,t[e+2]=p,t[e+3]=_;return}if(u!==_||l!==d||c!==f||h!==p){let x=1-a;const g=l*d+c*f+h*p+u*_,m=g>=0?1:-1,S=1-g*g;if(S>Number.EPSILON){const v=Math.sqrt(S),y=Math.atan2(v,g*m);x=Math.sin(x*y)/v,a=Math.sin(a*y)/v}const M=a*m;if(l=l*x+d*M,c=c*x+f*M,h=h*x+p*M,u=u*x+_*M,x===1-a){const v=1/Math.sqrt(l*l+c*c+h*h+u*u);l*=v,c*=v,h*=v,u*=v}}t[e]=l,t[e+1]=c,t[e+2]=h,t[e+3]=u}static multiplyQuaternionsFlat(t,e,i,r,s,o){const a=i[r],l=i[r+1],c=i[r+2],h=i[r+3],u=s[o],d=s[o+1],f=s[o+2],p=s[o+3];return t[e]=a*p+h*u+l*f-c*d,t[e+1]=l*p+h*d+c*u-a*f,t[e+2]=c*p+h*f+a*d-l*u,t[e+3]=h*p-a*u-l*d-c*f,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,i,r){return this._x=t,this._y=e,this._z=i,this._w=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e){if(!(t&&t.isEuler))throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const i=t._x,r=t._y,s=t._z,o=t._order,a=Math.cos,l=Math.sin,c=a(i/2),h=a(r/2),u=a(s/2),d=l(i/2),f=l(r/2),p=l(s/2);switch(o){case"XYZ":this._x=d*h*u+c*f*p,this._y=c*f*u-d*h*p,this._z=c*h*p+d*f*u,this._w=c*h*u-d*f*p;break;case"YXZ":this._x=d*h*u+c*f*p,this._y=c*f*u-d*h*p,this._z=c*h*p-d*f*u,this._w=c*h*u+d*f*p;break;case"ZXY":this._x=d*h*u-c*f*p,this._y=c*f*u+d*h*p,this._z=c*h*p+d*f*u,this._w=c*h*u-d*f*p;break;case"ZYX":this._x=d*h*u-c*f*p,this._y=c*f*u+d*h*p,this._z=c*h*p-d*f*u,this._w=c*h*u+d*f*p;break;case"YZX":this._x=d*h*u+c*f*p,this._y=c*f*u+d*h*p,this._z=c*h*p-d*f*u,this._w=c*h*u-d*f*p;break;case"XZY":this._x=d*h*u-c*f*p,this._y=c*f*u-d*h*p,this._z=c*h*p+d*f*u,this._w=c*h*u+d*f*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+o)}return e!==!1&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const i=e/2,r=Math.sin(i);return this._x=t.x*r,this._y=t.y*r,this._z=t.z*r,this._w=Math.cos(i),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,i=e[0],r=e[4],s=e[8],o=e[1],a=e[5],l=e[9],c=e[2],h=e[6],u=e[10],d=i+a+u;if(d>0){const f=.5/Math.sqrt(d+1);this._w=.25/f,this._x=(h-l)*f,this._y=(s-c)*f,this._z=(o-r)*f}else if(i>a&&i>u){const f=2*Math.sqrt(1+i-a-u);this._w=(h-l)/f,this._x=.25*f,this._y=(r+o)/f,this._z=(s+c)/f}else if(a>u){const f=2*Math.sqrt(1+a-i-u);this._w=(s-c)/f,this._x=(r+o)/f,this._y=.25*f,this._z=(l+h)/f}else{const f=2*Math.sqrt(1+u-i-a);this._w=(o-r)/f,this._x=(s+c)/f,this._y=(l+h)/f,this._z=.25*f}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let r=t.dot(e)+1;return r<1e-6?(r=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=r):(this._x=0,this._y=-t.z,this._z=t.y,this._w=r)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=r),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(bt.clamp(this.dot(t),-1,1)))}rotateTowards(t,e){const i=this.angleTo(t);if(i===0)return this;const r=Math.min(1,e/i);return this.slerp(t,r),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return t===0?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t,e){return e!==void 0?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(t,e)):this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const i=t._x,r=t._y,s=t._z,o=t._w,a=e._x,l=e._y,c=e._z,h=e._w;return this._x=i*h+o*a+r*c-s*l,this._y=r*h+o*l+s*a-i*c,this._z=s*h+o*c+i*l-r*a,this._w=o*h-i*a-r*l-s*c,this._onChangeCallback(),this}slerp(t,e){if(e===0)return this;if(e===1)return this.copy(t);const i=this._x,r=this._y,s=this._z,o=this._w;let a=o*t._w+i*t._x+r*t._y+s*t._z;if(a<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,a=-a):this.copy(t),a>=1)return this._w=o,this._x=i,this._y=r,this._z=s,this;const l=1-a*a;if(l<=Number.EPSILON){const f=1-e;return this._w=f*o+e*this._w,this._x=f*i+e*this._x,this._y=f*r+e*this._y,this._z=f*s+e*this._z,this.normalize(),this._onChangeCallback(),this}const c=Math.sqrt(l),h=Math.atan2(c,a),u=Math.sin((1-e)*h)/c,d=Math.sin(e*h)/c;return this._w=o*u+this._w*d,this._x=i*u+this._x*d,this._y=r*u+this._y*d,this._z=s*u+this._z*d,this._onChangeCallback(),this}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}me.prototype.isQuaternion=!0;class A{constructor(t=0,e=0,i=0){this.x=t,this.y=e,this.z=i}set(t,e,i){return i===void 0&&(i=this.z),this.x=t,this.y=e,this.z=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t,e){return e!==void 0?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(t,e)):(this.x*=t.x,this.y*=t.y,this.z*=t.z,this)}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return t&&t.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(cc.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(cc.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,i=this.y,r=this.z,s=t.elements;return this.x=s[0]*e+s[3]*i+s[6]*r,this.y=s[1]*e+s[4]*i+s[7]*r,this.z=s[2]*e+s[5]*i+s[8]*r,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,i=this.y,r=this.z,s=t.elements,o=1/(s[3]*e+s[7]*i+s[11]*r+s[15]);return this.x=(s[0]*e+s[4]*i+s[8]*r+s[12])*o,this.y=(s[1]*e+s[5]*i+s[9]*r+s[13])*o,this.z=(s[2]*e+s[6]*i+s[10]*r+s[14])*o,this}applyQuaternion(t){const e=this.x,i=this.y,r=this.z,s=t.x,o=t.y,a=t.z,l=t.w,c=l*e+o*r-a*i,h=l*i+a*e-s*r,u=l*r+s*i-o*e,d=-s*e-o*i-a*r;return this.x=c*l+d*-s+h*-a-u*-o,this.y=h*l+d*-o+u*-s-c*-a,this.z=u*l+d*-a+c*-o-h*-s,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,i=this.y,r=this.z,s=t.elements;return this.x=s[0]*e+s[4]*i+s[8]*r,this.y=s[1]*e+s[5]*i+s[9]*r,this.z=s[2]*e+s[6]*i+s[10]*r,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this.z=t.z+(e.z-t.z)*i,this}cross(t,e){return e!==void 0?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(t,e)):this.crossVectors(this,t)}crossVectors(t,e){const i=t.x,r=t.y,s=t.z,o=e.x,a=e.y,l=e.z;return this.x=r*l-s*a,this.y=s*o-i*l,this.z=i*a-r*o,this}projectOnVector(t){const e=t.lengthSq();if(e===0)return this.set(0,0,0);const i=t.dot(this)/e;return this.copy(t).multiplyScalar(i)}projectOnPlane(t){return bo.copy(this).projectOnVector(t),this.sub(bo)}reflect(t){return this.sub(bo.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const i=this.dot(t)/e;return Math.acos(bt.clamp(i,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,i=this.y-t.y,r=this.z-t.z;return e*e+i*i+r*r}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,i){const r=Math.sin(e)*t;return this.x=r*Math.sin(i),this.y=Math.cos(e)*t,this.z=r*Math.cos(i),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,i){return this.x=t*Math.sin(e),this.y=i,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),i=this.setFromMatrixColumn(t,1).length(),r=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=i,this.z=r,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,e*4)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,e*3)}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e,i){return i!==void 0&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}}A.prototype.isVector3=!0;const bo=new A,cc=new me;class Ge{constructor(t=new A(1/0,1/0,1/0),e=new A(-1/0,-1/0,-1/0)){this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){let e=1/0,i=1/0,r=1/0,s=-1/0,o=-1/0,a=-1/0;for(let l=0,c=t.length;l<c;l+=3){const h=t[l],u=t[l+1],d=t[l+2];h<e&&(e=h),u<i&&(i=u),d<r&&(r=d),h>s&&(s=h),u>o&&(o=u),d>a&&(a=d)}return this.min.set(e,i,r),this.max.set(s,o,a),this}setFromBufferAttribute(t){let e=1/0,i=1/0,r=1/0,s=-1/0,o=-1/0,a=-1/0;for(let l=0,c=t.count;l<c;l++){const h=t.getX(l),u=t.getY(l),d=t.getZ(l);h<e&&(e=h),u<i&&(i=u),d<r&&(r=d),h>s&&(s=h),u>o&&(o=u),d>a&&(a=d)}return this.min.set(e,i,r),this.max.set(s,o,a),this}setFromPoints(t){this.makeEmpty();for(let e=0,i=t.length;e<i;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const i=er.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(i),this.max.copy(t).add(i),this}setFromObject(t){return this.makeEmpty(),this.expandByObject(t)}clone(){return new this.constructor().copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return t===void 0&&(console.warn("THREE.Box3: .getCenter() target is now required"),t=new A),this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return t===void 0&&(console.warn("THREE.Box3: .getSize() target is now required"),t=new A),this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t){t.updateWorldMatrix(!1,!1);const e=t.geometry;e!==void 0&&(e.boundingBox===null&&e.computeBoundingBox(),wo.copy(e.boundingBox),wo.applyMatrix4(t.matrixWorld),this.union(wo));const i=t.children;for(let r=0,s=i.length;r<s;r++)this.expandByObject(i[r]);return this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y||t.z<this.min.z||t.z>this.max.z)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e===void 0&&(console.warn("THREE.Box3: .getParameter() target is now required"),e=new A),e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y||t.max.z<this.min.z||t.min.z>this.max.z)}intersectsSphere(t){return this.clampPoint(t.center,er),er.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,i;return t.normal.x>0?(e=t.normal.x*this.min.x,i=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,i=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,i+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,i+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,i+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,i+=t.normal.z*this.min.z),e<=-t.constant&&i>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(nr),Zr.subVectors(this.max,nr),ci.subVectors(t.a,nr),hi.subVectors(t.b,nr),ui.subVectors(t.c,nr),_n.subVectors(hi,ci),xn.subVectors(ui,hi),Gn.subVectors(ci,ui);let e=[0,-_n.z,_n.y,0,-xn.z,xn.y,0,-Gn.z,Gn.y,_n.z,0,-_n.x,xn.z,0,-xn.x,Gn.z,0,-Gn.x,-_n.y,_n.x,0,-xn.y,xn.x,0,-Gn.y,Gn.x,0];return!Mo(e,ci,hi,ui,Zr)||(e=[1,0,0,0,1,0,0,0,1],!Mo(e,ci,hi,ui,Zr))?!1:(Jr.crossVectors(_n,xn),e=[Jr.x,Jr.y,Jr.z],Mo(e,ci,hi,ui,Zr))}clampPoint(t,e){return e===void 0&&(console.warn("THREE.Box3: .clampPoint() target is now required"),e=new A),e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return er.copy(t).clamp(this.min,this.max).sub(t).length()}getBoundingSphere(t){return t===void 0&&console.error("THREE.Box3: .getBoundingSphere() target is now required"),this.getCenter(t.center),t.radius=this.getSize(er).length()*.5,t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()?this:(an[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),an[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),an[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),an[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),an[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),an[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),an[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),an[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(an),this)}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}Ge.prototype.isBox3=!0;const an=[new A,new A,new A,new A,new A,new A,new A,new A],er=new A,wo=new Ge,ci=new A,hi=new A,ui=new A,_n=new A,xn=new A,Gn=new A,nr=new A,Zr=new A,Jr=new A,Vn=new A;function Mo(n,t,e,i,r){for(let s=0,o=n.length-3;s<=o;s+=3){Vn.fromArray(n,s);const a=r.x*Math.abs(Vn.x)+r.y*Math.abs(Vn.y)+r.z*Math.abs(Vn.z),l=t.dot(Vn),c=e.dot(Vn),h=i.dot(Vn);if(Math.max(-Math.max(l,c,h),Math.min(l,c,h))>a)return!1}return!0}const dm=new Ge;class ji{constructor(t=new A,e=-1){this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const i=this.center;e!==void 0?i.copy(e):dm.setFromPoints(t).getCenter(i);let r=0;for(let s=0,o=t.length;s<o;s++)r=Math.max(r,i.distanceToSquared(t[s]));return this.radius=Math.sqrt(r),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const i=this.center.distanceToSquared(t);return e===void 0&&(console.warn("THREE.Sphere: .clampPoint() target is now required"),e=new A),e.copy(t),i>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return t===void 0&&(console.warn("THREE.Sphere: .getBoundingBox() target is now required"),t=new Ge),this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return new this.constructor().copy(this)}}const ln=new A,So=new A,Qr=new A,yn=new A,To=new A,$r=new A,Eo=new A;class si{constructor(t=new A,e=new A(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e===void 0&&(console.warn("THREE.Ray: .at() target is now required"),e=new A),e.copy(this.direction).multiplyScalar(t).add(this.origin)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,ln)),this}closestPointToPoint(t,e){e===void 0&&(console.warn("THREE.Ray: .closestPointToPoint() target is now required"),e=new A),e.subVectors(t,this.origin);const i=e.dot(this.direction);return i<0?e.copy(this.origin):e.copy(this.direction).multiplyScalar(i).add(this.origin)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=ln.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(ln.copy(this.direction).multiplyScalar(e).add(this.origin),ln.distanceToSquared(t))}distanceSqToSegment(t,e,i,r){So.copy(t).add(e).multiplyScalar(.5),Qr.copy(e).sub(t).normalize(),yn.copy(this.origin).sub(So);const s=t.distanceTo(e)*.5,o=-this.direction.dot(Qr),a=yn.dot(this.direction),l=-yn.dot(Qr),c=yn.lengthSq(),h=Math.abs(1-o*o);let u,d,f,p;if(h>0)if(u=o*l-a,d=o*a-l,p=s*h,u>=0)if(d>=-p)if(d<=p){const _=1/h;u*=_,d*=_,f=u*(u+o*d+2*a)+d*(o*u+d+2*l)+c}else d=s,u=Math.max(0,-(o*d+a)),f=-u*u+d*(d+2*l)+c;else d=-s,u=Math.max(0,-(o*d+a)),f=-u*u+d*(d+2*l)+c;else d<=-p?(u=Math.max(0,-(-o*s+a)),d=u>0?-s:Math.min(Math.max(-s,-l),s),f=-u*u+d*(d+2*l)+c):d<=p?(u=0,d=Math.min(Math.max(-s,-l),s),f=d*(d+2*l)+c):(u=Math.max(0,-(o*s+a)),d=u>0?s:Math.min(Math.max(-s,-l),s),f=-u*u+d*(d+2*l)+c);else d=o>0?-s:s,u=Math.max(0,-(o*d+a)),f=-u*u+d*(d+2*l)+c;return i&&i.copy(this.direction).multiplyScalar(u).add(this.origin),r&&r.copy(Qr).multiplyScalar(d).add(So),f}intersectSphere(t,e){ln.subVectors(t.center,this.origin);const i=ln.dot(this.direction),r=ln.dot(ln)-i*i,s=t.radius*t.radius;if(r>s)return null;const o=Math.sqrt(s-r),a=i-o,l=i+o;return a<0&&l<0?null:a<0?this.at(l,e):this.at(a,e)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(e===0)return t.distanceToPoint(this.origin)===0?0:null;const i=-(this.origin.dot(t.normal)+t.constant)/e;return i>=0?i:null}intersectPlane(t,e){const i=this.distanceToPlane(t);return i===null?null:this.at(i,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);return e===0||t.normal.dot(this.direction)*e<0}intersectBox(t,e){let i,r,s,o,a,l;const c=1/this.direction.x,h=1/this.direction.y,u=1/this.direction.z,d=this.origin;return c>=0?(i=(t.min.x-d.x)*c,r=(t.max.x-d.x)*c):(i=(t.max.x-d.x)*c,r=(t.min.x-d.x)*c),h>=0?(s=(t.min.y-d.y)*h,o=(t.max.y-d.y)*h):(s=(t.max.y-d.y)*h,o=(t.min.y-d.y)*h),i>o||s>r||((s>i||i!==i)&&(i=s),(o<r||r!==r)&&(r=o),u>=0?(a=(t.min.z-d.z)*u,l=(t.max.z-d.z)*u):(a=(t.max.z-d.z)*u,l=(t.min.z-d.z)*u),i>l||a>r)||((a>i||i!==i)&&(i=a),(l<r||r!==r)&&(r=l),r<0)?null:this.at(i>=0?i:r,e)}intersectsBox(t){return this.intersectBox(t,ln)!==null}intersectTriangle(t,e,i,r,s){To.subVectors(e,t),$r.subVectors(i,t),Eo.crossVectors(To,$r);let o=this.direction.dot(Eo),a;if(o>0){if(r)return null;a=1}else if(o<0)a=-1,o=-o;else return null;yn.subVectors(this.origin,t);const l=a*this.direction.dot($r.crossVectors(yn,$r));if(l<0)return null;const c=a*this.direction.dot(To.cross(yn));if(c<0||l+c>o)return null;const h=-a*yn.dot(Eo);return h<0?null:this.at(h/o,s)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class dt{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(t,e,i,r,s,o,a,l,c,h,u,d,f,p,_,x){const g=this.elements;return g[0]=t,g[4]=e,g[8]=i,g[12]=r,g[1]=s,g[5]=o,g[9]=a,g[13]=l,g[2]=c,g[6]=h,g[10]=u,g[14]=d,g[3]=f,g[7]=p,g[11]=_,g[15]=x,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new dt().fromArray(this.elements)}copy(t){const e=this.elements,i=t.elements;return e[0]=i[0],e[1]=i[1],e[2]=i[2],e[3]=i[3],e[4]=i[4],e[5]=i[5],e[6]=i[6],e[7]=i[7],e[8]=i[8],e[9]=i[9],e[10]=i[10],e[11]=i[11],e[12]=i[12],e[13]=i[13],e[14]=i[14],e[15]=i[15],this}copyPosition(t){const e=this.elements,i=t.elements;return e[12]=i[12],e[13]=i[13],e[14]=i[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,i){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),i.setFromMatrixColumn(this,2),this}makeBasis(t,e,i){return this.set(t.x,e.x,i.x,0,t.y,e.y,i.y,0,t.z,e.z,i.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,i=t.elements,r=1/di.setFromMatrixColumn(t,0).length(),s=1/di.setFromMatrixColumn(t,1).length(),o=1/di.setFromMatrixColumn(t,2).length();return e[0]=i[0]*r,e[1]=i[1]*r,e[2]=i[2]*r,e[3]=0,e[4]=i[4]*s,e[5]=i[5]*s,e[6]=i[6]*s,e[7]=0,e[8]=i[8]*o,e[9]=i[9]*o,e[10]=i[10]*o,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){t&&t.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const e=this.elements,i=t.x,r=t.y,s=t.z,o=Math.cos(i),a=Math.sin(i),l=Math.cos(r),c=Math.sin(r),h=Math.cos(s),u=Math.sin(s);if(t.order==="XYZ"){const d=o*h,f=o*u,p=a*h,_=a*u;e[0]=l*h,e[4]=-l*u,e[8]=c,e[1]=f+p*c,e[5]=d-_*c,e[9]=-a*l,e[2]=_-d*c,e[6]=p+f*c,e[10]=o*l}else if(t.order==="YXZ"){const d=l*h,f=l*u,p=c*h,_=c*u;e[0]=d+_*a,e[4]=p*a-f,e[8]=o*c,e[1]=o*u,e[5]=o*h,e[9]=-a,e[2]=f*a-p,e[6]=_+d*a,e[10]=o*l}else if(t.order==="ZXY"){const d=l*h,f=l*u,p=c*h,_=c*u;e[0]=d-_*a,e[4]=-o*u,e[8]=p+f*a,e[1]=f+p*a,e[5]=o*h,e[9]=_-d*a,e[2]=-o*c,e[6]=a,e[10]=o*l}else if(t.order==="ZYX"){const d=o*h,f=o*u,p=a*h,_=a*u;e[0]=l*h,e[4]=p*c-f,e[8]=d*c+_,e[1]=l*u,e[5]=_*c+d,e[9]=f*c-p,e[2]=-c,e[6]=a*l,e[10]=o*l}else if(t.order==="YZX"){const d=o*l,f=o*c,p=a*l,_=a*c;e[0]=l*h,e[4]=_-d*u,e[8]=p*u+f,e[1]=u,e[5]=o*h,e[9]=-a*h,e[2]=-c*h,e[6]=f*u+p,e[10]=d-_*u}else if(t.order==="XZY"){const d=o*l,f=o*c,p=a*l,_=a*c;e[0]=l*h,e[4]=-u,e[8]=c*h,e[1]=d*u+_,e[5]=o*h,e[9]=f*u-p,e[2]=p*u-f,e[6]=a*h,e[10]=_*u+d}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(fm,t,pm)}lookAt(t,e,i){const r=this.elements;return Se.subVectors(t,e),Se.lengthSq()===0&&(Se.z=1),Se.normalize(),vn.crossVectors(i,Se),vn.lengthSq()===0&&(Math.abs(i.z)===1?Se.x+=1e-4:Se.z+=1e-4,Se.normalize(),vn.crossVectors(i,Se)),vn.normalize(),Kr.crossVectors(Se,vn),r[0]=vn.x,r[4]=Kr.x,r[8]=Se.x,r[1]=vn.y,r[5]=Kr.y,r[9]=Se.y,r[2]=vn.z,r[6]=Kr.z,r[10]=Se.z,this}multiply(t,e){return e!==void 0?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(t,e)):this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const i=t.elements,r=e.elements,s=this.elements,o=i[0],a=i[4],l=i[8],c=i[12],h=i[1],u=i[5],d=i[9],f=i[13],p=i[2],_=i[6],x=i[10],g=i[14],m=i[3],S=i[7],M=i[11],v=i[15],y=r[0],T=r[4],D=r[8],L=r[12],F=r[1],N=r[5],k=r[9],I=r[13],C=r[2],P=r[6],O=r[10],G=r[14],Y=r[3],Q=r[7],it=r[11],et=r[15];return s[0]=o*y+a*F+l*C+c*Y,s[4]=o*T+a*N+l*P+c*Q,s[8]=o*D+a*k+l*O+c*it,s[12]=o*L+a*I+l*G+c*et,s[1]=h*y+u*F+d*C+f*Y,s[5]=h*T+u*N+d*P+f*Q,s[9]=h*D+u*k+d*O+f*it,s[13]=h*L+u*I+d*G+f*et,s[2]=p*y+_*F+x*C+g*Y,s[6]=p*T+_*N+x*P+g*Q,s[10]=p*D+_*k+x*O+g*it,s[14]=p*L+_*I+x*G+g*et,s[3]=m*y+S*F+M*C+v*Y,s[7]=m*T+S*N+M*P+v*Q,s[11]=m*D+S*k+M*O+v*it,s[15]=m*L+S*I+M*G+v*et,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],i=t[4],r=t[8],s=t[12],o=t[1],a=t[5],l=t[9],c=t[13],h=t[2],u=t[6],d=t[10],f=t[14],p=t[3],_=t[7],x=t[11],g=t[15];return p*(+s*l*u-r*c*u-s*a*d+i*c*d+r*a*f-i*l*f)+_*(+e*l*f-e*c*d+s*o*d-r*o*f+r*c*h-s*l*h)+x*(+e*c*u-e*a*f-s*o*u+i*o*f+s*a*h-i*c*h)+g*(-r*a*h-e*l*u+e*a*d+r*o*u-i*o*d+i*l*h)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,i){const r=this.elements;return t.isVector3?(r[12]=t.x,r[13]=t.y,r[14]=t.z):(r[12]=t,r[13]=e,r[14]=i),this}invert(){const t=this.elements,e=t[0],i=t[1],r=t[2],s=t[3],o=t[4],a=t[5],l=t[6],c=t[7],h=t[8],u=t[9],d=t[10],f=t[11],p=t[12],_=t[13],x=t[14],g=t[15],m=u*x*c-_*d*c+_*l*f-a*x*f-u*l*g+a*d*g,S=p*d*c-h*x*c-p*l*f+o*x*f+h*l*g-o*d*g,M=h*_*c-p*u*c+p*a*f-o*_*f-h*a*g+o*u*g,v=p*u*l-h*_*l-p*a*d+o*_*d+h*a*x-o*u*x,y=e*m+i*S+r*M+s*v;if(y===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const T=1/y;return t[0]=m*T,t[1]=(_*d*s-u*x*s-_*r*f+i*x*f+u*r*g-i*d*g)*T,t[2]=(a*x*s-_*l*s+_*r*c-i*x*c-a*r*g+i*l*g)*T,t[3]=(u*l*s-a*d*s-u*r*c+i*d*c+a*r*f-i*l*f)*T,t[4]=S*T,t[5]=(h*x*s-p*d*s+p*r*f-e*x*f-h*r*g+e*d*g)*T,t[6]=(p*l*s-o*x*s-p*r*c+e*x*c+o*r*g-e*l*g)*T,t[7]=(o*d*s-h*l*s+h*r*c-e*d*c-o*r*f+e*l*f)*T,t[8]=M*T,t[9]=(p*u*s-h*_*s-p*i*f+e*_*f+h*i*g-e*u*g)*T,t[10]=(o*_*s-p*a*s+p*i*c-e*_*c-o*i*g+e*a*g)*T,t[11]=(h*a*s-o*u*s-h*i*c+e*u*c+o*i*f-e*a*f)*T,t[12]=v*T,t[13]=(h*_*r-p*u*r+p*i*d-e*_*d-h*i*x+e*u*x)*T,t[14]=(p*a*r-o*_*r-p*i*l+e*_*l+o*i*x-e*a*x)*T,t[15]=(o*u*r-h*a*r+h*i*l-e*u*l-o*i*d+e*a*d)*T,this}scale(t){const e=this.elements,i=t.x,r=t.y,s=t.z;return e[0]*=i,e[4]*=r,e[8]*=s,e[1]*=i,e[5]*=r,e[9]*=s,e[2]*=i,e[6]*=r,e[10]*=s,e[3]*=i,e[7]*=r,e[11]*=s,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],i=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],r=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,i,r))}makeTranslation(t,e,i){return this.set(1,0,0,t,0,1,0,e,0,0,1,i,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),i=Math.sin(t);return this.set(1,0,0,0,0,e,-i,0,0,i,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),i=Math.sin(t);return this.set(e,0,i,0,0,1,0,0,-i,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),i=Math.sin(t);return this.set(e,-i,0,0,i,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const i=Math.cos(e),r=Math.sin(e),s=1-i,o=t.x,a=t.y,l=t.z,c=s*o,h=s*a;return this.set(c*o+i,c*a-r*l,c*l+r*a,0,c*a+r*l,h*a+i,h*l-r*o,0,c*l-r*a,h*l+r*o,s*l*l+i,0,0,0,0,1),this}makeScale(t,e,i){return this.set(t,0,0,0,0,e,0,0,0,0,i,0,0,0,0,1),this}makeShear(t,e,i){return this.set(1,e,i,0,t,1,i,0,t,e,1,0,0,0,0,1),this}compose(t,e,i){const r=this.elements,s=e._x,o=e._y,a=e._z,l=e._w,c=s+s,h=o+o,u=a+a,d=s*c,f=s*h,p=s*u,_=o*h,x=o*u,g=a*u,m=l*c,S=l*h,M=l*u,v=i.x,y=i.y,T=i.z;return r[0]=(1-(_+g))*v,r[1]=(f+M)*v,r[2]=(p-S)*v,r[3]=0,r[4]=(f-M)*y,r[5]=(1-(d+g))*y,r[6]=(x+m)*y,r[7]=0,r[8]=(p+S)*T,r[9]=(x-m)*T,r[10]=(1-(d+_))*T,r[11]=0,r[12]=t.x,r[13]=t.y,r[14]=t.z,r[15]=1,this}decompose(t,e,i){const r=this.elements;let s=di.set(r[0],r[1],r[2]).length();const o=di.set(r[4],r[5],r[6]).length(),a=di.set(r[8],r[9],r[10]).length();this.determinant()<0&&(s=-s),t.x=r[12],t.y=r[13],t.z=r[14],We.copy(this);const c=1/s,h=1/o,u=1/a;return We.elements[0]*=c,We.elements[1]*=c,We.elements[2]*=c,We.elements[4]*=h,We.elements[5]*=h,We.elements[6]*=h,We.elements[8]*=u,We.elements[9]*=u,We.elements[10]*=u,e.setFromRotationMatrix(We),i.x=s,i.y=o,i.z=a,this}makePerspective(t,e,i,r,s,o){o===void 0&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const a=this.elements,l=2*s/(e-t),c=2*s/(i-r),h=(e+t)/(e-t),u=(i+r)/(i-r),d=-(o+s)/(o-s),f=-2*o*s/(o-s);return a[0]=l,a[4]=0,a[8]=h,a[12]=0,a[1]=0,a[5]=c,a[9]=u,a[13]=0,a[2]=0,a[6]=0,a[10]=d,a[14]=f,a[3]=0,a[7]=0,a[11]=-1,a[15]=0,this}makeOrthographic(t,e,i,r,s,o){const a=this.elements,l=1/(e-t),c=1/(i-r),h=1/(o-s),u=(e+t)*l,d=(i+r)*c,f=(o+s)*h;return a[0]=2*l,a[4]=0,a[8]=0,a[12]=-u,a[1]=0,a[5]=2*c,a[9]=0,a[13]=-d,a[2]=0,a[6]=0,a[10]=-2*h,a[14]=-f,a[3]=0,a[7]=0,a[11]=0,a[15]=1,this}equals(t){const e=this.elements,i=t.elements;for(let r=0;r<16;r++)if(e[r]!==i[r])return!1;return!0}fromArray(t,e=0){for(let i=0;i<16;i++)this.elements[i]=t[i+e];return this}toArray(t=[],e=0){const i=this.elements;return t[e]=i[0],t[e+1]=i[1],t[e+2]=i[2],t[e+3]=i[3],t[e+4]=i[4],t[e+5]=i[5],t[e+6]=i[6],t[e+7]=i[7],t[e+8]=i[8],t[e+9]=i[9],t[e+10]=i[10],t[e+11]=i[11],t[e+12]=i[12],t[e+13]=i[13],t[e+14]=i[14],t[e+15]=i[15],t}}dt.prototype.isMatrix4=!0;const di=new A,We=new dt,fm=new A(0,0,0),pm=new A(1,1,1),vn=new A,Kr=new A,Se=new A,hc=new dt,uc=new me;class Xi{constructor(t=0,e=0,i=0,r=Xi.DefaultOrder){this._x=t,this._y=e,this._z=i,this._order=r}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,i,r){return this._x=t,this._y=e,this._z=i,this._order=r||this._order,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e,i){const r=bt.clamp,s=t.elements,o=s[0],a=s[4],l=s[8],c=s[1],h=s[5],u=s[9],d=s[2],f=s[6],p=s[10];switch(e=e||this._order,e){case"XYZ":this._y=Math.asin(r(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-u,p),this._z=Math.atan2(-a,o)):(this._x=Math.atan2(f,h),this._z=0);break;case"YXZ":this._x=Math.asin(-r(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(l,p),this._z=Math.atan2(c,h)):(this._y=Math.atan2(-d,o),this._z=0);break;case"ZXY":this._x=Math.asin(r(f,-1,1)),Math.abs(f)<.9999999?(this._y=Math.atan2(-d,p),this._z=Math.atan2(-a,h)):(this._y=0,this._z=Math.atan2(c,o));break;case"ZYX":this._y=Math.asin(-r(d,-1,1)),Math.abs(d)<.9999999?(this._x=Math.atan2(f,p),this._z=Math.atan2(c,o)):(this._x=0,this._z=Math.atan2(-a,h));break;case"YZX":this._z=Math.asin(r(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(-u,h),this._y=Math.atan2(-d,o)):(this._x=0,this._y=Math.atan2(l,p));break;case"XZY":this._z=Math.asin(-r(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(f,h),this._y=Math.atan2(l,o)):(this._x=Math.atan2(-u,p),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,i!==!1&&this._onChangeCallback(),this}setFromQuaternion(t,e,i){return hc.makeRotationFromQuaternion(t),this.setFromRotationMatrix(hc,e,i)}setFromVector3(t,e){return this.set(t.x,t.y,t.z,e||this._order)}reorder(t){return uc.setFromEuler(this),this.setFromQuaternion(uc,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],t[3]!==void 0&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}toVector3(t){return t?t.set(this._x,this._y,this._z):new A(this._x,this._y,this._z)}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}Xi.prototype.isEuler=!0;Xi.DefaultOrder="XYZ";Xi.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class yu{constructor(){this.mask=1}set(t){this.mask=1<<t|0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return(this.mask&t.mask)!==0}}let mm=0;const dc=new A,fi=new me,cn=new dt,ts=new A,ir=new A,gm=new A,_m=new me,fc=new A(1,0,0),pc=new A(0,1,0),mc=new A(0,0,1),xm={type:"added"},gc={type:"removed"};function xt(){Object.defineProperty(this,"id",{value:mm++}),this.uuid=bt.generateUUID(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=xt.DefaultUp.clone();const n=new A,t=new Xi,e=new me,i=new A(1,1,1);function r(){e.setFromEuler(t,!1)}function s(){t.setFromQuaternion(e,void 0,!1)}t._onChange(r),e._onChange(s),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:n},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:e},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new dt},normalMatrix:{value:new ae}}),this.matrix=new dt,this.matrixWorld=new dt,this.matrixAutoUpdate=xt.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new yu,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}xt.DefaultUp=new A(0,1,0);xt.DefaultMatrixAutoUpdate=!0;xt.prototype=Object.assign(Object.create(kn.prototype),{constructor:xt,isObject3D:!0,onBeforeRender:function(){},onAfterRender:function(){},applyMatrix4:function(n){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(n),this.matrix.decompose(this.position,this.quaternion,this.scale)},applyQuaternion:function(n){return this.quaternion.premultiply(n),this},setRotationFromAxisAngle:function(n,t){this.quaternion.setFromAxisAngle(n,t)},setRotationFromEuler:function(n){this.quaternion.setFromEuler(n,!0)},setRotationFromMatrix:function(n){this.quaternion.setFromRotationMatrix(n)},setRotationFromQuaternion:function(n){this.quaternion.copy(n)},rotateOnAxis:function(n,t){return fi.setFromAxisAngle(n,t),this.quaternion.multiply(fi),this},rotateOnWorldAxis:function(n,t){return fi.setFromAxisAngle(n,t),this.quaternion.premultiply(fi),this},rotateX:function(n){return this.rotateOnAxis(fc,n)},rotateY:function(n){return this.rotateOnAxis(pc,n)},rotateZ:function(n){return this.rotateOnAxis(mc,n)},translateOnAxis:function(n,t){return dc.copy(n).applyQuaternion(this.quaternion),this.position.add(dc.multiplyScalar(t)),this},translateX:function(n){return this.translateOnAxis(fc,n)},translateY:function(n){return this.translateOnAxis(pc,n)},translateZ:function(n){return this.translateOnAxis(mc,n)},localToWorld:function(n){return n.applyMatrix4(this.matrixWorld)},worldToLocal:function(n){return n.applyMatrix4(cn.copy(this.matrixWorld).invert())},lookAt:function(n,t,e){n.isVector3?ts.copy(n):ts.set(n,t,e);const i=this.parent;this.updateWorldMatrix(!0,!1),ir.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?cn.lookAt(ir,ts,this.up):cn.lookAt(ts,ir,this.up),this.quaternion.setFromRotationMatrix(cn),i&&(cn.extractRotation(i.matrixWorld),fi.setFromRotationMatrix(cn),this.quaternion.premultiply(fi.invert()))},add:function(n){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return n===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",n),this):(n&&n.isObject3D?(n.parent!==null&&n.parent.remove(n),n.parent=this,this.children.push(n),n.dispatchEvent(xm)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",n),this)},remove:function(n){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.remove(arguments[e]);return this}const t=this.children.indexOf(n);return t!==-1&&(n.parent=null,this.children.splice(t,1),n.dispatchEvent(gc)),this},clear:function(){for(let n=0;n<this.children.length;n++){const t=this.children[n];t.parent=null,t.dispatchEvent(gc)}return this.children.length=0,this},attach:function(n){return this.updateWorldMatrix(!0,!1),cn.copy(this.matrixWorld).invert(),n.parent!==null&&(n.parent.updateWorldMatrix(!0,!1),cn.multiply(n.parent.matrixWorld)),n.applyMatrix4(cn),this.add(n),n.updateWorldMatrix(!1,!0),this},getObjectById:function(n){return this.getObjectByProperty("id",n)},getObjectByName:function(n){return this.getObjectByProperty("name",n)},getObjectByProperty:function(n,t){if(this[n]===t)return this;for(let e=0,i=this.children.length;e<i;e++){const s=this.children[e].getObjectByProperty(n,t);if(s!==void 0)return s}},getWorldPosition:function(n){return n===void 0&&(console.warn("THREE.Object3D: .getWorldPosition() target is now required"),n=new A),this.updateWorldMatrix(!0,!1),n.setFromMatrixPosition(this.matrixWorld)},getWorldQuaternion:function(n){return n===void 0&&(console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"),n=new me),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(ir,n,gm),n},getWorldScale:function(n){return n===void 0&&(console.warn("THREE.Object3D: .getWorldScale() target is now required"),n=new A),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(ir,_m,n),n},getWorldDirection:function(n){n===void 0&&(console.warn("THREE.Object3D: .getWorldDirection() target is now required"),n=new A),this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return n.set(t[8],t[9],t[10]).normalize()},raycast:function(){},traverse:function(n){n(this);const t=this.children;for(let e=0,i=t.length;e<i;e++)t[e].traverse(n)},traverseVisible:function(n){if(this.visible===!1)return;n(this);const t=this.children;for(let e=0,i=t.length;e<i;e++)t[e].traverseVisible(n)},traverseAncestors:function(n){const t=this.parent;t!==null&&(n(t),t.traverseAncestors(n))},updateMatrix:function(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0},updateMatrixWorld:function(n){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||n)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,n=!0);const t=this.children;for(let e=0,i=t.length;e<i;e++)t[e].updateMatrixWorld(n)},updateWorldMatrix:function(n,t){const e=this.parent;if(n===!0&&e!==null&&e.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),t===!0){const i=this.children;for(let r=0,s=i.length;r<s;r++)i[r].updateWorldMatrix(!1,!0)}},toJSON:function(n){const t=n===void 0||typeof n=="string",e={};t&&(n={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},e.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const i={};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.castShadow===!0&&(i.castShadow=!0),this.receiveShadow===!0&&(i.receiveShadow=!0),this.visible===!1&&(i.visible=!1),this.frustumCulled===!1&&(i.frustumCulled=!1),this.renderOrder!==0&&(i.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON());function r(o,a){return o[a.uuid]===void 0&&(o[a.uuid]=a.toJSON(n)),a.uuid}if(this.isMesh||this.isLine||this.isPoints){i.geometry=r(n.geometries,this.geometry);const o=this.geometry.parameters;if(o!==void 0&&o.shapes!==void 0){const a=o.shapes;if(Array.isArray(a))for(let l=0,c=a.length;l<c;l++){const h=a[l];r(n.shapes,h)}else r(n.shapes,a)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(r(n.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const o=[];for(let a=0,l=this.material.length;a<l;a++)o.push(r(n.materials,this.material[a]));i.material=o}else i.material=r(n.materials,this.material);if(this.children.length>0){i.children=[];for(let o=0;o<this.children.length;o++)i.children.push(this.children[o].toJSON(n).object)}if(this.animations.length>0){i.animations=[];for(let o=0;o<this.animations.length;o++){const a=this.animations[o];i.animations.push(r(n.animations,a))}}if(t){const o=s(n.geometries),a=s(n.materials),l=s(n.textures),c=s(n.images),h=s(n.shapes),u=s(n.skeletons),d=s(n.animations);o.length>0&&(e.geometries=o),a.length>0&&(e.materials=a),l.length>0&&(e.textures=l),c.length>0&&(e.images=c),h.length>0&&(e.shapes=h),u.length>0&&(e.skeletons=u),d.length>0&&(e.animations=d)}return e.object=i,e;function s(o){const a=[];for(const l in o){const c=o[l];delete c.metadata,a.push(c)}return a}},clone:function(n){return new this.constructor().copy(this,n)},copy:function(n,t=!0){if(this.name=n.name,this.up.copy(n.up),this.position.copy(n.position),this.rotation.order=n.rotation.order,this.quaternion.copy(n.quaternion),this.scale.copy(n.scale),this.matrix.copy(n.matrix),this.matrixWorld.copy(n.matrixWorld),this.matrixAutoUpdate=n.matrixAutoUpdate,this.matrixWorldNeedsUpdate=n.matrixWorldNeedsUpdate,this.layers.mask=n.layers.mask,this.visible=n.visible,this.castShadow=n.castShadow,this.receiveShadow=n.receiveShadow,this.frustumCulled=n.frustumCulled,this.renderOrder=n.renderOrder,this.userData=JSON.parse(JSON.stringify(n.userData)),t===!0)for(let e=0;e<n.children.length;e++){const i=n.children[e];this.add(i.clone())}return this}});const Ao=new A,ym=new A,vm=new ae;class Ke{constructor(t=new A(1,0,0),e=0){this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,i,r){return this.normal.set(t,e,i),this.constant=r,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,i){const r=Ao.subVectors(i,e).cross(ym.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(r,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e===void 0&&(console.warn("THREE.Plane: .projectPoint() target is now required"),e=new A),e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)}intersectLine(t,e){e===void 0&&(console.warn("THREE.Plane: .intersectLine() target is now required"),e=new A);const i=t.delta(Ao),r=this.normal.dot(i);if(r===0)return this.distanceToPoint(t.start)===0?e.copy(t.start):void 0;const s=-(t.start.dot(this.normal)+this.constant)/r;if(!(s<0||s>1))return e.copy(i).multiplyScalar(s).add(t.start)}intersectsLine(t){const e=this.distanceToPoint(t.start),i=this.distanceToPoint(t.end);return e<0&&i>0||i<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t===void 0&&(console.warn("THREE.Plane: .coplanarPoint() target is now required"),t=new A),t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const i=e||vm.getNormalMatrix(t),r=this.coplanarPoint(Ao).applyMatrix4(t),s=this.normal.applyMatrix3(i).normalize();return this.constant=-r.dot(s),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return new this.constructor().copy(this)}}Ke.prototype.isPlane=!0;const qe=new A,hn=new A,Lo=new A,un=new A,pi=new A,mi=new A,_c=new A,Co=new A,Ro=new A,Po=new A;class Jt{constructor(t=new A,e=new A,i=new A){this.a=t,this.b=e,this.c=i}static getNormal(t,e,i,r){r===void 0&&(console.warn("THREE.Triangle: .getNormal() target is now required"),r=new A),r.subVectors(i,e),qe.subVectors(t,e),r.cross(qe);const s=r.lengthSq();return s>0?r.multiplyScalar(1/Math.sqrt(s)):r.set(0,0,0)}static getBarycoord(t,e,i,r,s){qe.subVectors(r,e),hn.subVectors(i,e),Lo.subVectors(t,e);const o=qe.dot(qe),a=qe.dot(hn),l=qe.dot(Lo),c=hn.dot(hn),h=hn.dot(Lo),u=o*c-a*a;if(s===void 0&&(console.warn("THREE.Triangle: .getBarycoord() target is now required"),s=new A),u===0)return s.set(-2,-1,-1);const d=1/u,f=(c*l-a*h)*d,p=(o*h-a*l)*d;return s.set(1-f-p,p,f)}static containsPoint(t,e,i,r){return this.getBarycoord(t,e,i,r,un),un.x>=0&&un.y>=0&&un.x+un.y<=1}static getUV(t,e,i,r,s,o,a,l){return this.getBarycoord(t,e,i,r,un),l.set(0,0),l.addScaledVector(s,un.x),l.addScaledVector(o,un.y),l.addScaledVector(a,un.z),l}static isFrontFacing(t,e,i,r){return qe.subVectors(i,e),hn.subVectors(t,e),qe.cross(hn).dot(r)<0}set(t,e,i){return this.a.copy(t),this.b.copy(e),this.c.copy(i),this}setFromPointsAndIndices(t,e,i,r){return this.a.copy(t[e]),this.b.copy(t[i]),this.c.copy(t[r]),this}clone(){return new this.constructor().copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return qe.subVectors(this.c,this.b),hn.subVectors(this.a,this.b),qe.cross(hn).length()*.5}getMidpoint(t){return t===void 0&&(console.warn("THREE.Triangle: .getMidpoint() target is now required"),t=new A),t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return Jt.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t===void 0&&(console.warn("THREE.Triangle: .getPlane() target is now required"),t=new Ke),t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return Jt.getBarycoord(t,this.a,this.b,this.c,e)}getUV(t,e,i,r,s){return Jt.getUV(t,this.a,this.b,this.c,e,i,r,s)}containsPoint(t){return Jt.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return Jt.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){e===void 0&&(console.warn("THREE.Triangle: .closestPointToPoint() target is now required"),e=new A);const i=this.a,r=this.b,s=this.c;let o,a;pi.subVectors(r,i),mi.subVectors(s,i),Co.subVectors(t,i);const l=pi.dot(Co),c=mi.dot(Co);if(l<=0&&c<=0)return e.copy(i);Ro.subVectors(t,r);const h=pi.dot(Ro),u=mi.dot(Ro);if(h>=0&&u<=h)return e.copy(r);const d=l*u-h*c;if(d<=0&&l>=0&&h<=0)return o=l/(l-h),e.copy(i).addScaledVector(pi,o);Po.subVectors(t,s);const f=pi.dot(Po),p=mi.dot(Po);if(p>=0&&f<=p)return e.copy(s);const _=f*c-l*p;if(_<=0&&c>=0&&p<=0)return a=c/(c-p),e.copy(i).addScaledVector(mi,a);const x=h*p-f*u;if(x<=0&&u-h>=0&&f-p>=0)return _c.subVectors(s,r),a=(u-h)/(u-h+(f-p)),e.copy(r).addScaledVector(_c,a);const g=1/(x+_+d);return o=_*g,a=d*g,e.copy(i).addScaledVector(pi,o).addScaledVector(mi,a)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}let bm=0;function Xt(){Object.defineProperty(this,"id",{value:bm++}),this.uuid=bt.generateUUID(),this.name="",this.type="Material",this.fog=!0,this.blending=vr,this.side=Zs,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=pu,this.blendDst=mu,this.blendEquation=Ti,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=ca,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=cm,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=yo,this.stencilZFail=yo,this.stencilZPass=yo,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaTest=0,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0}Xt.prototype=Object.assign(Object.create(kn.prototype),{constructor:Xt,isMaterial:!0,onBeforeCompile:function(){},customProgramCacheKey:function(){return this.onBeforeCompile.toString()},setValues:function(n){if(n!==void 0)for(const t in n){const e=n[t];if(e===void 0){console.warn("THREE.Material: '"+t+"' parameter is undefined.");continue}if(t==="shading"){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=e===Ja;continue}const i=this[t];if(i===void 0){console.warn("THREE."+this.type+": '"+t+"' is not a property of this material.");continue}i&&i.isColor?i.set(e):i&&i.isVector3&&e&&e.isVector3?i.copy(e):this[t]=e}},toJSON:function(n){const t=n===void 0||typeof n=="string";t&&(n={textures:{},images:{}});const e={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),this.color&&this.color.isColor&&(e.color=this.color.getHex()),this.roughness!==void 0&&(e.roughness=this.roughness),this.metalness!==void 0&&(e.metalness=this.metalness),this.sheen&&this.sheen.isColor&&(e.sheen=this.sheen.getHex()),this.emissive&&this.emissive.isColor&&(e.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(e.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(e.specular=this.specular.getHex()),this.shininess!==void 0&&(e.shininess=this.shininess),this.clearcoat!==void 0&&(e.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(e.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(e.clearcoatMap=this.clearcoatMap.toJSON(n).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(e.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(n).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(e.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(n).uuid,e.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(e.map=this.map.toJSON(n).uuid),this.matcap&&this.matcap.isTexture&&(e.matcap=this.matcap.toJSON(n).uuid),this.alphaMap&&this.alphaMap.isTexture&&(e.alphaMap=this.alphaMap.toJSON(n).uuid),this.lightMap&&this.lightMap.isTexture&&(e.lightMap=this.lightMap.toJSON(n).uuid,e.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(e.aoMap=this.aoMap.toJSON(n).uuid,e.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(e.bumpMap=this.bumpMap.toJSON(n).uuid,e.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(e.normalMap=this.normalMap.toJSON(n).uuid,e.normalMapType=this.normalMapType,e.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(e.displacementMap=this.displacementMap.toJSON(n).uuid,e.displacementScale=this.displacementScale,e.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(e.roughnessMap=this.roughnessMap.toJSON(n).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(e.metalnessMap=this.metalnessMap.toJSON(n).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(e.emissiveMap=this.emissiveMap.toJSON(n).uuid),this.specularMap&&this.specularMap.isTexture&&(e.specularMap=this.specularMap.toJSON(n).uuid),this.envMap&&this.envMap.isTexture&&(e.envMap=this.envMap.toJSON(n).uuid,e.reflectivity=this.reflectivity,e.refractionRatio=this.refractionRatio,this.combine!==void 0&&(e.combine=this.combine),this.envMapIntensity!==void 0&&(e.envMapIntensity=this.envMapIntensity)),this.gradientMap&&this.gradientMap.isTexture&&(e.gradientMap=this.gradientMap.toJSON(n).uuid),this.size!==void 0&&(e.size=this.size),this.sizeAttenuation!==void 0&&(e.sizeAttenuation=this.sizeAttenuation),this.blending!==vr&&(e.blending=this.blending),this.side!==Zs&&(e.side=this.side),this.vertexColors&&(e.vertexColors=!0),this.opacity<1&&(e.opacity=this.opacity),this.transparent===!0&&(e.transparent=this.transparent),e.depthFunc=this.depthFunc,e.depthTest=this.depthTest,e.depthWrite=this.depthWrite,e.stencilWrite=this.stencilWrite,e.stencilWriteMask=this.stencilWriteMask,e.stencilFunc=this.stencilFunc,e.stencilRef=this.stencilRef,e.stencilFuncMask=this.stencilFuncMask,e.stencilFail=this.stencilFail,e.stencilZFail=this.stencilZFail,e.stencilZPass=this.stencilZPass,this.rotation&&this.rotation!==0&&(e.rotation=this.rotation),this.polygonOffset===!0&&(e.polygonOffset=!0),this.polygonOffsetFactor!==0&&(e.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(e.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&this.linewidth!==1&&(e.linewidth=this.linewidth),this.dashSize!==void 0&&(e.dashSize=this.dashSize),this.gapSize!==void 0&&(e.gapSize=this.gapSize),this.scale!==void 0&&(e.scale=this.scale),this.dithering===!0&&(e.dithering=!0),this.alphaTest>0&&(e.alphaTest=this.alphaTest),this.premultipliedAlpha===!0&&(e.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(e.wireframe=this.wireframe),this.wireframeLinewidth>1&&(e.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(e.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(e.wireframeLinejoin=this.wireframeLinejoin),this.morphTargets===!0&&(e.morphTargets=!0),this.morphNormals===!0&&(e.morphNormals=!0),this.skinning===!0&&(e.skinning=!0),this.flatShading===!0&&(e.flatShading=this.flatShading),this.visible===!1&&(e.visible=!1),this.toneMapped===!1&&(e.toneMapped=!1),JSON.stringify(this.userData)!=="{}"&&(e.userData=this.userData);function i(r){const s=[];for(const o in r){const a=r[o];delete a.metadata,s.push(a)}return s}if(t){const r=i(n.textures),s=i(n.images);r.length>0&&(e.textures=r),s.length>0&&(e.images=s)}return e},clone:function(){return new this.constructor().copy(this)},copy:function(n){this.name=n.name,this.fog=n.fog,this.blending=n.blending,this.side=n.side,this.vertexColors=n.vertexColors,this.opacity=n.opacity,this.transparent=n.transparent,this.blendSrc=n.blendSrc,this.blendDst=n.blendDst,this.blendEquation=n.blendEquation,this.blendSrcAlpha=n.blendSrcAlpha,this.blendDstAlpha=n.blendDstAlpha,this.blendEquationAlpha=n.blendEquationAlpha,this.depthFunc=n.depthFunc,this.depthTest=n.depthTest,this.depthWrite=n.depthWrite,this.stencilWriteMask=n.stencilWriteMask,this.stencilFunc=n.stencilFunc,this.stencilRef=n.stencilRef,this.stencilFuncMask=n.stencilFuncMask,this.stencilFail=n.stencilFail,this.stencilZFail=n.stencilZFail,this.stencilZPass=n.stencilZPass,this.stencilWrite=n.stencilWrite;const t=n.clippingPlanes;let e=null;if(t!==null){const i=t.length;e=new Array(i);for(let r=0;r!==i;++r)e[r]=t[r].clone()}return this.clippingPlanes=e,this.clipIntersection=n.clipIntersection,this.clipShadows=n.clipShadows,this.shadowSide=n.shadowSide,this.colorWrite=n.colorWrite,this.precision=n.precision,this.polygonOffset=n.polygonOffset,this.polygonOffsetFactor=n.polygonOffsetFactor,this.polygonOffsetUnits=n.polygonOffsetUnits,this.dithering=n.dithering,this.alphaTest=n.alphaTest,this.premultipliedAlpha=n.premultipliedAlpha,this.visible=n.visible,this.toneMapped=n.toneMapped,this.userData=JSON.parse(JSON.stringify(n.userData)),this},dispose:function(){this.dispatchEvent({type:"dispose"})}});Object.defineProperty(Xt.prototype,"needsUpdate",{set:function(n){n===!0&&this.version++}});const vu={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},je={h:0,s:0,l:0},es={h:0,s:0,l:0};function Do(n,t,e){return e<0&&(e+=1),e>1&&(e-=1),e<1/6?n+(t-n)*6*e:e<1/2?t:e<2/3?n+(t-n)*6*(2/3-e):n}function Io(n){return n<.04045?n*.0773993808:Math.pow(n*.9478672986+.0521327014,2.4)}function Fo(n){return n<.0031308?n*12.92:1.055*Math.pow(n,.41666)-.055}class pt{constructor(t,e,i){return e===void 0&&i===void 0?this.set(t):this.setRGB(t,e,i)}set(t){return t&&t.isColor?this.copy(t):typeof t=="number"?this.setHex(t):typeof t=="string"&&this.setStyle(t),this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(t&255)/255,this}setRGB(t,e,i){return this.r=t,this.g=e,this.b=i,this}setHSL(t,e,i){if(t=bt.euclideanModulo(t,1),e=bt.clamp(e,0,1),i=bt.clamp(i,0,1),e===0)this.r=this.g=this.b=i;else{const r=i<=.5?i*(1+e):i+e-i*e,s=2*i-r;this.r=Do(s,r,t+1/3),this.g=Do(s,r,t),this.b=Do(s,r,t-1/3)}return this}setStyle(t){function e(r){r!==void 0&&parseFloat(r)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let i;if(i=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)){let r;const s=i[1],o=i[2];switch(s){case"rgb":case"rgba":if(r=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return this.r=Math.min(255,parseInt(r[1],10))/255,this.g=Math.min(255,parseInt(r[2],10))/255,this.b=Math.min(255,parseInt(r[3],10))/255,e(r[4]),this;if(r=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return this.r=Math.min(100,parseInt(r[1],10))/100,this.g=Math.min(100,parseInt(r[2],10))/100,this.b=Math.min(100,parseInt(r[3],10))/100,e(r[4]),this;break;case"hsl":case"hsla":if(r=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)){const a=parseFloat(r[1])/360,l=parseInt(r[2],10)/100,c=parseInt(r[3],10)/100;return e(r[4]),this.setHSL(a,l,c)}break}}else if(i=/^\#([A-Fa-f\d]+)$/.exec(t)){const r=i[1],s=r.length;if(s===3)return this.r=parseInt(r.charAt(0)+r.charAt(0),16)/255,this.g=parseInt(r.charAt(1)+r.charAt(1),16)/255,this.b=parseInt(r.charAt(2)+r.charAt(2),16)/255,this;if(s===6)return this.r=parseInt(r.charAt(0)+r.charAt(1),16)/255,this.g=parseInt(r.charAt(2)+r.charAt(3),16)/255,this.b=parseInt(r.charAt(4)+r.charAt(5),16)/255,this}return t&&t.length>0?this.setColorName(t):this}setColorName(t){const e=vu[t];return e!==void 0?this.setHex(e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copyGammaToLinear(t,e=2){return this.r=Math.pow(t.r,e),this.g=Math.pow(t.g,e),this.b=Math.pow(t.b,e),this}copyLinearToGamma(t,e=2){const i=e>0?1/e:1;return this.r=Math.pow(t.r,i),this.g=Math.pow(t.g,i),this.b=Math.pow(t.b,i),this}convertGammaToLinear(t){return this.copyGammaToLinear(this,t),this}convertLinearToGamma(t){return this.copyLinearToGamma(this,t),this}copySRGBToLinear(t){return this.r=Io(t.r),this.g=Io(t.g),this.b=Io(t.b),this}copyLinearToSRGB(t){return this.r=Fo(t.r),this.g=Fo(t.g),this.b=Fo(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return this.r*255<<16^this.g*255<<8^this.b*255<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(t){t===void 0&&(console.warn("THREE.Color: .getHSL() target is now required"),t={h:0,s:0,l:0});const e=this.r,i=this.g,r=this.b,s=Math.max(e,i,r),o=Math.min(e,i,r);let a,l;const c=(o+s)/2;if(o===s)a=0,l=0;else{const h=s-o;switch(l=c<=.5?h/(s+o):h/(2-s-o),s){case e:a=(i-r)/h+(i<r?6:0);break;case i:a=(r-e)/h+2;break;case r:a=(e-i)/h+4;break}a/=6}return t.h=a,t.s=l,t.l=c,t}getStyle(){return"rgb("+(this.r*255|0)+","+(this.g*255|0)+","+(this.b*255|0)+")"}offsetHSL(t,e,i){return this.getHSL(je),je.h+=t,je.s+=e,je.l+=i,this.setHSL(je.h,je.s,je.l),this}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,i){return this.r=t.r+(e.r-t.r)*i,this.g=t.g+(e.g-t.g)*i,this.b=t.b+(e.b-t.b)*i,this}lerpHSL(t,e){this.getHSL(je),t.getHSL(es);const i=bt.lerp(je.h,es.h,e),r=bt.lerp(je.s,es.s,e),s=bt.lerp(je.l,es.l,e);return this.setHSL(i,r,s),this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),t.normalized===!0&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}pt.NAMES=vu;pt.prototype.isColor=!0;pt.prototype.r=1;pt.prototype.g=1;pt.prototype.b=1;class il extends Xt{constructor(t){super(),this.type="MeshBasicMaterial",this.color=new pt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Js,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this}}il.prototype.isMeshBasicMaterial=!0;const Ut=new A,ns=new J;function Mt(n,t,e){if(Array.isArray(n))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=n,this.itemSize=t,this.count=n!==void 0?n.length/t:0,this.normalized=e===!0,this.usage=$s,this.updateRange={offset:0,count:-1},this.version=0}Object.defineProperty(Mt.prototype,"needsUpdate",{set:function(n){n===!0&&this.version++}});Object.assign(Mt.prototype,{isBufferAttribute:!0,onUploadCallback:function(){},setUsage:function(n){return this.usage=n,this},copy:function(n){return this.name=n.name,this.array=new n.array.constructor(n.array),this.itemSize=n.itemSize,this.count=n.count,this.normalized=n.normalized,this.usage=n.usage,this},copyAt:function(n,t,e){n*=this.itemSize,e*=t.itemSize;for(let i=0,r=this.itemSize;i<r;i++)this.array[n+i]=t.array[e+i];return this},copyArray:function(n){return this.array.set(n),this},copyColorsArray:function(n){const t=this.array;let e=0;for(let i=0,r=n.length;i<r;i++){let s=n[i];s===void 0&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",i),s=new pt),t[e++]=s.r,t[e++]=s.g,t[e++]=s.b}return this},copyVector2sArray:function(n){const t=this.array;let e=0;for(let i=0,r=n.length;i<r;i++){let s=n[i];s===void 0&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",i),s=new J),t[e++]=s.x,t[e++]=s.y}return this},copyVector3sArray:function(n){const t=this.array;let e=0;for(let i=0,r=n.length;i<r;i++){let s=n[i];s===void 0&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",i),s=new A),t[e++]=s.x,t[e++]=s.y,t[e++]=s.z}return this},copyVector4sArray:function(n){const t=this.array;let e=0;for(let i=0,r=n.length;i<r;i++){let s=n[i];s===void 0&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",i),s=new Ft),t[e++]=s.x,t[e++]=s.y,t[e++]=s.z,t[e++]=s.w}return this},applyMatrix3:function(n){if(this.itemSize===2)for(let t=0,e=this.count;t<e;t++)ns.fromBufferAttribute(this,t),ns.applyMatrix3(n),this.setXY(t,ns.x,ns.y);else if(this.itemSize===3)for(let t=0,e=this.count;t<e;t++)Ut.fromBufferAttribute(this,t),Ut.applyMatrix3(n),this.setXYZ(t,Ut.x,Ut.y,Ut.z);return this},applyMatrix4:function(n){for(let t=0,e=this.count;t<e;t++)Ut.x=this.getX(t),Ut.y=this.getY(t),Ut.z=this.getZ(t),Ut.applyMatrix4(n),this.setXYZ(t,Ut.x,Ut.y,Ut.z);return this},applyNormalMatrix:function(n){for(let t=0,e=this.count;t<e;t++)Ut.x=this.getX(t),Ut.y=this.getY(t),Ut.z=this.getZ(t),Ut.applyNormalMatrix(n),this.setXYZ(t,Ut.x,Ut.y,Ut.z);return this},transformDirection:function(n){for(let t=0,e=this.count;t<e;t++)Ut.x=this.getX(t),Ut.y=this.getY(t),Ut.z=this.getZ(t),Ut.transformDirection(n),this.setXYZ(t,Ut.x,Ut.y,Ut.z);return this},set:function(n,t=0){return this.array.set(n,t),this},getX:function(n){return this.array[n*this.itemSize]},setX:function(n,t){return this.array[n*this.itemSize]=t,this},getY:function(n){return this.array[n*this.itemSize+1]},setY:function(n,t){return this.array[n*this.itemSize+1]=t,this},getZ:function(n){return this.array[n*this.itemSize+2]},setZ:function(n,t){return this.array[n*this.itemSize+2]=t,this},getW:function(n){return this.array[n*this.itemSize+3]},setW:function(n,t){return this.array[n*this.itemSize+3]=t,this},setXY:function(n,t,e){return n*=this.itemSize,this.array[n+0]=t,this.array[n+1]=e,this},setXYZ:function(n,t,e,i){return n*=this.itemSize,this.array[n+0]=t,this.array[n+1]=e,this.array[n+2]=i,this},setXYZW:function(n,t,e,i,r){return n*=this.itemSize,this.array[n+0]=t,this.array[n+1]=e,this.array[n+2]=i,this.array[n+3]=r,this},onUpload:function(n){return this.onUploadCallback=n,this},clone:function(){return new this.constructor(this.array,this.itemSize).copy(this)},toJSON:function(){return{itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized}}});function da(n,t,e){Mt.call(this,new Int8Array(n),t,e)}da.prototype=Object.create(Mt.prototype);da.prototype.constructor=da;function fa(n,t,e){Mt.call(this,new Uint8Array(n),t,e)}fa.prototype=Object.create(Mt.prototype);fa.prototype.constructor=fa;function pa(n,t,e){Mt.call(this,new Uint8ClampedArray(n),t,e)}pa.prototype=Object.create(Mt.prototype);pa.prototype.constructor=pa;function ma(n,t,e){Mt.call(this,new Int16Array(n),t,e)}ma.prototype=Object.create(Mt.prototype);ma.prototype.constructor=ma;function Nr(n,t,e){Mt.call(this,new Uint16Array(n),t,e)}Nr.prototype=Object.create(Mt.prototype);Nr.prototype.constructor=Nr;function ga(n,t,e){Mt.call(this,new Int32Array(n),t,e)}ga.prototype=Object.create(Mt.prototype);ga.prototype.constructor=ga;function Or(n,t,e){Mt.call(this,new Uint32Array(n),t,e)}Or.prototype=Object.create(Mt.prototype);Or.prototype.constructor=Or;function ks(n,t,e){Mt.call(this,new Uint16Array(n),t,e)}ks.prototype=Object.create(Mt.prototype);ks.prototype.constructor=ks;ks.prototype.isFloat16BufferAttribute=!0;function Vt(n,t,e){Mt.call(this,new Float32Array(n),t,e)}Vt.prototype=Object.create(Mt.prototype);Vt.prototype.constructor=Vt;function _a(n,t,e){Mt.call(this,new Float64Array(n),t,e)}_a.prototype=Object.create(Mt.prototype);_a.prototype.constructor=_a;function bu(n){if(n.length===0)return-1/0;let t=n[0];for(let e=1,i=n.length;e<i;++e)n[e]>t&&(t=n[e]);return t}let wm=0;const Qe=new dt,No=new xt,gi=new A,Te=new Ge,rr=new Ge,$t=new A;function Dt(){Object.defineProperty(this,"id",{value:wm++}),this.uuid=bt.generateUUID(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}Dt.prototype=Object.assign(Object.create(kn.prototype),{constructor:Dt,isBufferGeometry:!0,getIndex:function(){return this.index},setIndex:function(n){return Array.isArray(n)?this.index=new(bu(n)>65535?Or:Nr)(n,1):this.index=n,this},getAttribute:function(n){return this.attributes[n]},setAttribute:function(n,t){return this.attributes[n]=t,this},deleteAttribute:function(n){return delete this.attributes[n],this},hasAttribute:function(n){return this.attributes[n]!==void 0},addGroup:function(n,t,e=0){this.groups.push({start:n,count:t,materialIndex:e})},clearGroups:function(){this.groups=[]},setDrawRange:function(n,t){this.drawRange.start=n,this.drawRange.count=t},applyMatrix4:function(n){const t=this.attributes.position;t!==void 0&&(t.applyMatrix4(n),t.needsUpdate=!0);const e=this.attributes.normal;if(e!==void 0){const r=new ae().getNormalMatrix(n);e.applyNormalMatrix(r),e.needsUpdate=!0}const i=this.attributes.tangent;return i!==void 0&&(i.transformDirection(n),i.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this},rotateX:function(n){return Qe.makeRotationX(n),this.applyMatrix4(Qe),this},rotateY:function(n){return Qe.makeRotationY(n),this.applyMatrix4(Qe),this},rotateZ:function(n){return Qe.makeRotationZ(n),this.applyMatrix4(Qe),this},translate:function(n,t,e){return Qe.makeTranslation(n,t,e),this.applyMatrix4(Qe),this},scale:function(n,t,e){return Qe.makeScale(n,t,e),this.applyMatrix4(Qe),this},lookAt:function(n){return No.lookAt(n),No.updateMatrix(),this.applyMatrix4(No.matrix),this},center:function(){return this.computeBoundingBox(),this.boundingBox.getCenter(gi).negate(),this.translate(gi.x,gi.y,gi.z),this},setFromPoints:function(n){const t=[];for(let e=0,i=n.length;e<i;e++){const r=n[e];t.push(r.x,r.y,r.z||0)}return this.setAttribute("position",new Vt(t,3)),this},computeBoundingBox:function(){this.boundingBox===null&&(this.boundingBox=new Ge);const n=this.attributes.position,t=this.morphAttributes.position;if(n&&n.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new A(-1/0,-1/0,-1/0),new A(1/0,1/0,1/0));return}if(n!==void 0){if(this.boundingBox.setFromBufferAttribute(n),t)for(let e=0,i=t.length;e<i;e++){const r=t[e];Te.setFromBufferAttribute(r),this.morphTargetsRelative?($t.addVectors(this.boundingBox.min,Te.min),this.boundingBox.expandByPoint($t),$t.addVectors(this.boundingBox.max,Te.max),this.boundingBox.expandByPoint($t)):(this.boundingBox.expandByPoint(Te.min),this.boundingBox.expandByPoint(Te.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)},computeBoundingSphere:function(){this.boundingSphere===null&&(this.boundingSphere=new ji);const n=this.attributes.position,t=this.morphAttributes.position;if(n&&n.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new A,1/0);return}if(n){const e=this.boundingSphere.center;if(Te.setFromBufferAttribute(n),t)for(let r=0,s=t.length;r<s;r++){const o=t[r];rr.setFromBufferAttribute(o),this.morphTargetsRelative?($t.addVectors(Te.min,rr.min),Te.expandByPoint($t),$t.addVectors(Te.max,rr.max),Te.expandByPoint($t)):(Te.expandByPoint(rr.min),Te.expandByPoint(rr.max))}Te.getCenter(e);let i=0;for(let r=0,s=n.count;r<s;r++)$t.fromBufferAttribute(n,r),i=Math.max(i,e.distanceToSquared($t));if(t)for(let r=0,s=t.length;r<s;r++){const o=t[r],a=this.morphTargetsRelative;for(let l=0,c=o.count;l<c;l++)$t.fromBufferAttribute(o,l),a&&(gi.fromBufferAttribute(n,l),$t.add(gi)),i=Math.max(i,e.distanceToSquared($t))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}},computeFaceNormals:function(){},computeTangents:function(){const n=this.index,t=this.attributes;if(n===null||t.position===void 0||t.normal===void 0||t.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const e=n.array,i=t.position.array,r=t.normal.array,s=t.uv.array,o=i.length/3;t.tangent===void 0&&this.setAttribute("tangent",new Mt(new Float32Array(4*o),4));const a=t.tangent.array,l=[],c=[];for(let L=0;L<o;L++)l[L]=new A,c[L]=new A;const h=new A,u=new A,d=new A,f=new J,p=new J,_=new J,x=new A,g=new A;function m(L,F,N){h.fromArray(i,L*3),u.fromArray(i,F*3),d.fromArray(i,N*3),f.fromArray(s,L*2),p.fromArray(s,F*2),_.fromArray(s,N*2),u.sub(h),d.sub(h),p.sub(f),_.sub(f);const k=1/(p.x*_.y-_.x*p.y);!isFinite(k)||(x.copy(u).multiplyScalar(_.y).addScaledVector(d,-p.y).multiplyScalar(k),g.copy(d).multiplyScalar(p.x).addScaledVector(u,-_.x).multiplyScalar(k),l[L].add(x),l[F].add(x),l[N].add(x),c[L].add(g),c[F].add(g),c[N].add(g))}let S=this.groups;S.length===0&&(S=[{start:0,count:e.length}]);for(let L=0,F=S.length;L<F;++L){const N=S[L],k=N.start,I=N.count;for(let C=k,P=k+I;C<P;C+=3)m(e[C+0],e[C+1],e[C+2])}const M=new A,v=new A,y=new A,T=new A;function D(L){y.fromArray(r,L*3),T.copy(y);const F=l[L];M.copy(F),M.sub(y.multiplyScalar(y.dot(F))).normalize(),v.crossVectors(T,F);const k=v.dot(c[L])<0?-1:1;a[L*4]=M.x,a[L*4+1]=M.y,a[L*4+2]=M.z,a[L*4+3]=k}for(let L=0,F=S.length;L<F;++L){const N=S[L],k=N.start,I=N.count;for(let C=k,P=k+I;C<P;C+=3)D(e[C+0]),D(e[C+1]),D(e[C+2])}},computeVertexNormals:function(){const n=this.index,t=this.getAttribute("position");if(t!==void 0){let e=this.getAttribute("normal");if(e===void 0)e=new Mt(new Float32Array(t.count*3),3),this.setAttribute("normal",e);else for(let u=0,d=e.count;u<d;u++)e.setXYZ(u,0,0,0);const i=new A,r=new A,s=new A,o=new A,a=new A,l=new A,c=new A,h=new A;if(n)for(let u=0,d=n.count;u<d;u+=3){const f=n.getX(u+0),p=n.getX(u+1),_=n.getX(u+2);i.fromBufferAttribute(t,f),r.fromBufferAttribute(t,p),s.fromBufferAttribute(t,_),c.subVectors(s,r),h.subVectors(i,r),c.cross(h),o.fromBufferAttribute(e,f),a.fromBufferAttribute(e,p),l.fromBufferAttribute(e,_),o.add(c),a.add(c),l.add(c),e.setXYZ(f,o.x,o.y,o.z),e.setXYZ(p,a.x,a.y,a.z),e.setXYZ(_,l.x,l.y,l.z)}else for(let u=0,d=t.count;u<d;u+=3)i.fromBufferAttribute(t,u+0),r.fromBufferAttribute(t,u+1),s.fromBufferAttribute(t,u+2),c.subVectors(s,r),h.subVectors(i,r),c.cross(h),e.setXYZ(u+0,c.x,c.y,c.z),e.setXYZ(u+1,c.x,c.y,c.z),e.setXYZ(u+2,c.x,c.y,c.z);this.normalizeNormals(),e.needsUpdate=!0}},merge:function(n,t){if(!(n&&n.isBufferGeometry)){console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",n);return}t===void 0&&(t=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const e=this.attributes;for(const i in e){if(n.attributes[i]===void 0)continue;const s=e[i].array,o=n.attributes[i],a=o.array,l=o.itemSize*t,c=Math.min(a.length,s.length-l);for(let h=0,u=l;h<c;h++,u++)s[u]=a[h]}return this},normalizeNormals:function(){const n=this.attributes.normal;for(let t=0,e=n.count;t<e;t++)$t.fromBufferAttribute(n,t),$t.normalize(),n.setXYZ(t,$t.x,$t.y,$t.z)},toNonIndexed:function(){function n(o,a){const l=o.array,c=o.itemSize,h=o.normalized,u=new l.constructor(a.length*c);let d=0,f=0;for(let p=0,_=a.length;p<_;p++){d=a[p]*c;for(let x=0;x<c;x++)u[f++]=l[d++]}return new Mt(u,c,h)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new Dt,e=this.index.array,i=this.attributes;for(const o in i){const a=i[o],l=n(a,e);t.setAttribute(o,l)}const r=this.morphAttributes;for(const o in r){const a=[],l=r[o];for(let c=0,h=l.length;c<h;c++){const u=l[c],d=n(u,e);a.push(d)}t.morphAttributes[o]=a}t.morphTargetsRelative=this.morphTargetsRelative;const s=this.groups;for(let o=0,a=s.length;o<a;o++){const l=s[o];t.addGroup(l.start,l.count,l.materialIndex)}return t},toJSON:function(){const n={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),Object.keys(this.userData).length>0&&(n.userData=this.userData),this.parameters!==void 0){const a=this.parameters;for(const l in a)a[l]!==void 0&&(n[l]=a[l]);return n}n.data={attributes:{}};const t=this.index;t!==null&&(n.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const e=this.attributes;for(const a in e){const l=e[a],c=l.toJSON(n.data);l.name!==""&&(c.name=l.name),n.data.attributes[a]=c}const i={};let r=!1;for(const a in this.morphAttributes){const l=this.morphAttributes[a],c=[];for(let h=0,u=l.length;h<u;h++){const d=l[h],f=d.toJSON(n.data);d.name!==""&&(f.name=d.name),c.push(f)}c.length>0&&(i[a]=c,r=!0)}r&&(n.data.morphAttributes=i,n.data.morphTargetsRelative=this.morphTargetsRelative);const s=this.groups;s.length>0&&(n.data.groups=JSON.parse(JSON.stringify(s)));const o=this.boundingSphere;return o!==null&&(n.data.boundingSphere={center:o.center.toArray(),radius:o.radius}),n},clone:function(){return new Dt().copy(this)},copy:function(n){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=n.name;const e=n.index;e!==null&&this.setIndex(e.clone(t));const i=n.attributes;for(const l in i){const c=i[l];this.setAttribute(l,c.clone(t))}const r=n.morphAttributes;for(const l in r){const c=[],h=r[l];for(let u=0,d=h.length;u<d;u++)c.push(h[u].clone(t));this.morphAttributes[l]=c}this.morphTargetsRelative=n.morphTargetsRelative;const s=n.groups;for(let l=0,c=s.length;l<c;l++){const h=s[l];this.addGroup(h.start,h.count,h.materialIndex)}const o=n.boundingBox;o!==null&&(this.boundingBox=o.clone());const a=n.boundingSphere;return a!==null&&(this.boundingSphere=a.clone()),this.drawRange.start=n.drawRange.start,this.drawRange.count=n.drawRange.count,this.userData=n.userData,this},dispose:function(){this.dispatchEvent({type:"dispose"})}});const xc=new dt,_i=new si,Oo=new ji,bn=new A,wn=new A,Mn=new A,Bo=new A,zo=new A,ko=new A,is=new A,rs=new A,ss=new A,os=new J,as=new J,ls=new J,Uo=new A,cs=new A;function ne(n=new Dt,t=new il){xt.call(this),this.type="Mesh",this.geometry=n,this.material=t,this.updateMorphTargets()}ne.prototype=Object.assign(Object.create(xt.prototype),{constructor:ne,isMesh:!0,copy:function(n){return xt.prototype.copy.call(this,n),n.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=n.morphTargetInfluences.slice()),n.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},n.morphTargetDictionary)),this.material=n.material,this.geometry=n.geometry,this},updateMorphTargets:function(){const n=this.geometry;if(n.isBufferGeometry){const t=n.morphAttributes,e=Object.keys(t);if(e.length>0){const i=t[e[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,s=i.length;r<s;r++){const o=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=r}}}}else{const t=n.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}},raycast:function(n,t){const e=this.geometry,i=this.material,r=this.matrixWorld;if(i===void 0||(e.boundingSphere===null&&e.computeBoundingSphere(),Oo.copy(e.boundingSphere),Oo.applyMatrix4(r),n.ray.intersectsSphere(Oo)===!1)||(xc.copy(r).invert(),_i.copy(n.ray).applyMatrix4(xc),e.boundingBox!==null&&_i.intersectsBox(e.boundingBox)===!1))return;let s;if(e.isBufferGeometry){const o=e.index,a=e.attributes.position,l=e.morphAttributes.position,c=e.morphTargetsRelative,h=e.attributes.uv,u=e.attributes.uv2,d=e.groups,f=e.drawRange;if(o!==null)if(Array.isArray(i))for(let p=0,_=d.length;p<_;p++){const x=d[p],g=i[x.materialIndex],m=Math.max(x.start,f.start),S=Math.min(x.start+x.count,f.start+f.count);for(let M=m,v=S;M<v;M+=3){const y=o.getX(M),T=o.getX(M+1),D=o.getX(M+2);s=hs(this,g,n,_i,a,l,c,h,u,y,T,D),s&&(s.faceIndex=Math.floor(M/3),s.face.materialIndex=x.materialIndex,t.push(s))}}else{const p=Math.max(0,f.start),_=Math.min(o.count,f.start+f.count);for(let x=p,g=_;x<g;x+=3){const m=o.getX(x),S=o.getX(x+1),M=o.getX(x+2);s=hs(this,i,n,_i,a,l,c,h,u,m,S,M),s&&(s.faceIndex=Math.floor(x/3),t.push(s))}}else if(a!==void 0)if(Array.isArray(i))for(let p=0,_=d.length;p<_;p++){const x=d[p],g=i[x.materialIndex],m=Math.max(x.start,f.start),S=Math.min(x.start+x.count,f.start+f.count);for(let M=m,v=S;M<v;M+=3){const y=M,T=M+1,D=M+2;s=hs(this,g,n,_i,a,l,c,h,u,y,T,D),s&&(s.faceIndex=Math.floor(M/3),s.face.materialIndex=x.materialIndex,t.push(s))}}else{const p=Math.max(0,f.start),_=Math.min(a.count,f.start+f.count);for(let x=p,g=_;x<g;x+=3){const m=x,S=x+1,M=x+2;s=hs(this,i,n,_i,a,l,c,h,u,m,S,M),s&&(s.faceIndex=Math.floor(x/3),t.push(s))}}}else e.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}});function Mm(n,t,e,i,r,s,o,a){let l;if(t.side===Kt?l=i.intersectTriangle(o,s,r,!0,a):l=i.intersectTriangle(r,s,o,t.side!==Vr,a),l===null)return null;cs.copy(a),cs.applyMatrix4(n.matrixWorld);const c=e.ray.origin.distanceTo(cs);return c<e.near||c>e.far?null:{distance:c,point:cs.clone(),object:n}}function hs(n,t,e,i,r,s,o,a,l,c,h,u){bn.fromBufferAttribute(r,c),wn.fromBufferAttribute(r,h),Mn.fromBufferAttribute(r,u);const d=n.morphTargetInfluences;if(t.morphTargets&&s&&d){is.set(0,0,0),rs.set(0,0,0),ss.set(0,0,0);for(let p=0,_=s.length;p<_;p++){const x=d[p],g=s[p];x!==0&&(Bo.fromBufferAttribute(g,c),zo.fromBufferAttribute(g,h),ko.fromBufferAttribute(g,u),o?(is.addScaledVector(Bo,x),rs.addScaledVector(zo,x),ss.addScaledVector(ko,x)):(is.addScaledVector(Bo.sub(bn),x),rs.addScaledVector(zo.sub(wn),x),ss.addScaledVector(ko.sub(Mn),x)))}bn.add(is),wn.add(rs),Mn.add(ss)}n.isSkinnedMesh&&t.skinning&&(n.boneTransform(c,bn),n.boneTransform(h,wn),n.boneTransform(u,Mn));const f=Mm(n,t,e,i,bn,wn,Mn,Uo);if(f){a&&(os.fromBufferAttribute(a,c),as.fromBufferAttribute(a,h),ls.fromBufferAttribute(a,u),f.uv=Jt.getUV(Uo,bn,wn,Mn,os,as,ls,new J)),l&&(os.fromBufferAttribute(l,c),as.fromBufferAttribute(l,h),ls.fromBufferAttribute(l,u),f.uv2=Jt.getUV(Uo,bn,wn,Mn,os,as,ls,new J));const p={a:c,b:h,c:u,normal:new A,materialIndex:0};Jt.getNormal(bn,wn,Mn,p.normal),f.face=p}return f}class rl extends Dt{constructor(t=1,e=1,i=1,r=1,s=1,o=1){super(),this.type="BoxGeometry",this.parameters={width:t,height:e,depth:i,widthSegments:r,heightSegments:s,depthSegments:o};const a=this;r=Math.floor(r),s=Math.floor(s),o=Math.floor(o);const l=[],c=[],h=[],u=[];let d=0,f=0;p("z","y","x",-1,-1,i,e,t,o,s,0),p("z","y","x",1,-1,i,e,-t,o,s,1),p("x","z","y",1,1,t,i,e,r,o,2),p("x","z","y",1,-1,t,i,-e,r,o,3),p("x","y","z",1,-1,t,e,i,r,s,4),p("x","y","z",-1,-1,t,e,-i,r,s,5),this.setIndex(l),this.setAttribute("position",new Vt(c,3)),this.setAttribute("normal",new Vt(h,3)),this.setAttribute("uv",new Vt(u,2));function p(_,x,g,m,S,M,v,y,T,D,L){const F=M/T,N=v/D,k=M/2,I=v/2,C=y/2,P=T+1,O=D+1;let G=0,Y=0;const Q=new A;for(let it=0;it<O;it++){const et=it*N-I;for(let wt=0;wt<P;wt++){const ot=wt*F-k;Q[_]=ot*m,Q[x]=et*S,Q[g]=C,c.push(Q.x,Q.y,Q.z),Q[_]=0,Q[x]=0,Q[g]=y>0?1:-1,h.push(Q.x,Q.y,Q.z),u.push(wt/T),u.push(1-it/D),G+=1}}for(let it=0;it<D;it++)for(let et=0;et<T;et++){const wt=d+et+P*it,ot=d+et+P*(it+1),Et=d+(et+1)+P*(it+1),Ct=d+(et+1)+P*it;l.push(wt,ot,Ct),l.push(ot,Et,Ct),Y+=6}a.addGroup(f,Y,L),f+=Y,d+=G}}}function Ui(n){const t={};for(const e in n){t[e]={};for(const i in n[e]){const r=n[e][i];r&&(r.isColor||r.isMatrix3||r.isMatrix4||r.isVector2||r.isVector3||r.isVector4||r.isTexture||r.isQuaternion)?t[e][i]=r.clone():Array.isArray(r)?t[e][i]=r.slice():t[e][i]=r}}return t}function ce(n){const t={};for(let e=0;e<n.length;e++){const i=Ui(n[e]);for(const r in i)t[r]=i[r]}return t}const Sm={clone:Ui,merge:ce};var Tm=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,Em=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;function Ue(n){Xt.call(this),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader=Tm,this.fragmentShader=Em,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,n!==void 0&&(n.attributes!==void 0&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(n))}Ue.prototype=Object.create(Xt.prototype);Ue.prototype.constructor=Ue;Ue.prototype.isShaderMaterial=!0;Ue.prototype.copy=function(n){return Xt.prototype.copy.call(this,n),this.fragmentShader=n.fragmentShader,this.vertexShader=n.vertexShader,this.uniforms=Ui(n.uniforms),this.defines=Object.assign({},n.defines),this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.lights=n.lights,this.clipping=n.clipping,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.morphNormals=n.morphNormals,this.extensions=Object.assign({},n.extensions),this.glslVersion=n.glslVersion,this};Ue.prototype.toJSON=function(n){const t=Xt.prototype.toJSON.call(this,n);t.glslVersion=this.glslVersion,t.uniforms={};for(const i in this.uniforms){const s=this.uniforms[i].value;s&&s.isTexture?t.uniforms[i]={type:"t",value:s.toJSON(n).uuid}:s&&s.isColor?t.uniforms[i]={type:"c",value:s.getHex()}:s&&s.isVector2?t.uniforms[i]={type:"v2",value:s.toArray()}:s&&s.isVector3?t.uniforms[i]={type:"v3",value:s.toArray()}:s&&s.isVector4?t.uniforms[i]={type:"v4",value:s.toArray()}:s&&s.isMatrix3?t.uniforms[i]={type:"m3",value:s.toArray()}:s&&s.isMatrix4?t.uniforms[i]={type:"m4",value:s.toArray()}:t.uniforms[i]={value:s}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader;const e={};for(const i in this.extensions)this.extensions[i]===!0&&(e[i]=!0);return Object.keys(e).length>0&&(t.extensions=e),t};function Hi(){xt.call(this),this.type="Camera",this.matrixWorldInverse=new dt,this.projectionMatrix=new dt,this.projectionMatrixInverse=new dt}Hi.prototype=Object.assign(Object.create(xt.prototype),{constructor:Hi,isCamera:!0,copy:function(n,t){return xt.prototype.copy.call(this,n,t),this.matrixWorldInverse.copy(n.matrixWorldInverse),this.projectionMatrix.copy(n.projectionMatrix),this.projectionMatrixInverse.copy(n.projectionMatrixInverse),this},getWorldDirection:function(n){n===void 0&&(console.warn("THREE.Camera: .getWorldDirection() target is now required"),n=new A),this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return n.set(-t[8],-t[9],-t[10]).normalize()},updateMatrixWorld:function(n){xt.prototype.updateMatrixWorld.call(this,n),this.matrixWorldInverse.copy(this.matrixWorld).invert()},updateWorldMatrix:function(n,t){xt.prototype.updateWorldMatrix.call(this,n,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()},clone:function(){return new this.constructor().copy(this)}});function ue(n=50,t=1,e=.1,i=2e3){Hi.call(this),this.type="PerspectiveCamera",this.fov=n,this.zoom=1,this.near=e,this.far=i,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}ue.prototype=Object.assign(Object.create(Hi.prototype),{constructor:ue,isPerspectiveCamera:!0,copy:function(n,t){return Hi.prototype.copy.call(this,n,t),this.fov=n.fov,this.zoom=n.zoom,this.near=n.near,this.far=n.far,this.focus=n.focus,this.aspect=n.aspect,this.view=n.view===null?null:Object.assign({},n.view),this.filmGauge=n.filmGauge,this.filmOffset=n.filmOffset,this},setFocalLength:function(n){const t=.5*this.getFilmHeight()/n;this.fov=bt.RAD2DEG*2*Math.atan(t),this.updateProjectionMatrix()},getFocalLength:function(){const n=Math.tan(bt.DEG2RAD*.5*this.fov);return .5*this.getFilmHeight()/n},getEffectiveFOV:function(){return bt.RAD2DEG*2*Math.atan(Math.tan(bt.DEG2RAD*.5*this.fov)/this.zoom)},getFilmWidth:function(){return this.filmGauge*Math.min(this.aspect,1)},getFilmHeight:function(){return this.filmGauge/Math.max(this.aspect,1)},setViewOffset:function(n,t,e,i,r,s){this.aspect=n/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=n,this.view.fullHeight=t,this.view.offsetX=e,this.view.offsetY=i,this.view.width=r,this.view.height=s,this.updateProjectionMatrix()},clearViewOffset:function(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()},updateProjectionMatrix:function(){const n=this.near;let t=n*Math.tan(bt.DEG2RAD*.5*this.fov)/this.zoom,e=2*t,i=this.aspect*e,r=-.5*i;const s=this.view;if(this.view!==null&&this.view.enabled){const a=s.fullWidth,l=s.fullHeight;r+=s.offsetX*i/a,t-=s.offsetY*e/l,i*=s.width/a,e*=s.height/l}const o=this.filmOffset;o!==0&&(r+=n*o/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+i,t,t-e,n,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()},toJSON:function(n){const t=xt.prototype.toJSON.call(this,n);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}});const xi=90,yi=1;class sl extends xt{constructor(t,e,i){if(super(),this.type="CubeCamera",i.isWebGLCubeRenderTarget!==!0){console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");return}this.renderTarget=i;const r=new ue(xi,yi,t,e);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new A(1,0,0)),this.add(r);const s=new ue(xi,yi,t,e);s.layers=this.layers,s.up.set(0,-1,0),s.lookAt(new A(-1,0,0)),this.add(s);const o=new ue(xi,yi,t,e);o.layers=this.layers,o.up.set(0,0,1),o.lookAt(new A(0,1,0)),this.add(o);const a=new ue(xi,yi,t,e);a.layers=this.layers,a.up.set(0,0,-1),a.lookAt(new A(0,-1,0)),this.add(a);const l=new ue(xi,yi,t,e);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new A(0,0,1)),this.add(l);const c=new ue(xi,yi,t,e);c.layers=this.layers,c.up.set(0,-1,0),c.lookAt(new A(0,0,-1)),this.add(c)}update(t,e){this.parent===null&&this.updateMatrixWorld();const i=this.renderTarget,[r,s,o,a,l,c]=this.children,h=t.xr.enabled,u=t.getRenderTarget();t.xr.enabled=!1;const d=i.texture.generateMipmaps;i.texture.generateMipmaps=!1,t.setRenderTarget(i,0),t.render(e,r),t.setRenderTarget(i,1),t.render(e,s),t.setRenderTarget(i,2),t.render(e,o),t.setRenderTarget(i,3),t.render(e,a),t.setRenderTarget(i,4),t.render(e,l),i.texture.generateMipmaps=d,t.setRenderTarget(i,5),t.render(e,c),t.setRenderTarget(u),t.xr.enabled=h}}class Ks extends le{constructor(t,e,i,r,s,o,a,l,c,h){t=t!==void 0?t:[],e=e!==void 0?e:Qa,a=a!==void 0?a:Kn,super(t,e,i,r,s,o,a,l,c,h),this._needsFlipEnvMap=!0,this.flipY=!1}get images(){return this.image}set images(t){this.image=t}}Ks.prototype.isCubeTexture=!0;class wu extends ti{constructor(t,e,i){Number.isInteger(e)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),e=i),super(t,t,e),e=e||{},this.texture=new Ks(void 0,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.encoding),this.texture.generateMipmaps=e.generateMipmaps!==void 0?e.generateMipmaps:!1,this.texture.minFilter=e.minFilter!==void 0?e.minFilter:oe,this.texture._needsFlipEnvMap=!1}fromEquirectangularTexture(t,e){this.texture.type=e.type,this.texture.format=Ye,this.texture.encoding=e.encoding,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const i={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},r=new rl(5,5,5),s=new Ue({name:"CubemapFromEquirect",uniforms:Ui(i.uniforms),vertexShader:i.vertexShader,fragmentShader:i.fragmentShader,side:Kt,blending:yr});s.uniforms.tEquirect.value=e;const o=new ne(r,s),a=e.minFilter;return e.minFilter===Qs&&(e.minFilter=oe),new sl(1,10,this).update(t,o),e.minFilter=a,o.geometry.dispose(),o.material.dispose(),this}clear(t,e,i,r){const s=t.getRenderTarget();for(let o=0;o<6;o++)t.setRenderTarget(this,o),t.clear(e,i,r);t.setRenderTarget(s)}}wu.prototype.isWebGLCubeRenderTarget=!0;class ol extends le{constructor(t,e,i,r,s,o,a,l,c,h,u,d){super(null,o,a,l,c,h,r,s,u,d),this.image={data:t||null,width:e||1,height:i||1},this.magFilter=c!==void 0?c:pe,this.minFilter=h!==void 0?h:pe,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}ol.prototype.isDataTexture=!0;const vi=new ji,us=new A;class to{constructor(t=new Ke,e=new Ke,i=new Ke,r=new Ke,s=new Ke,o=new Ke){this.planes=[t,e,i,r,s,o]}set(t,e,i,r,s,o){const a=this.planes;return a[0].copy(t),a[1].copy(e),a[2].copy(i),a[3].copy(r),a[4].copy(s),a[5].copy(o),this}copy(t){const e=this.planes;for(let i=0;i<6;i++)e[i].copy(t.planes[i]);return this}setFromProjectionMatrix(t){const e=this.planes,i=t.elements,r=i[0],s=i[1],o=i[2],a=i[3],l=i[4],c=i[5],h=i[6],u=i[7],d=i[8],f=i[9],p=i[10],_=i[11],x=i[12],g=i[13],m=i[14],S=i[15];return e[0].setComponents(a-r,u-l,_-d,S-x).normalize(),e[1].setComponents(a+r,u+l,_+d,S+x).normalize(),e[2].setComponents(a+s,u+c,_+f,S+g).normalize(),e[3].setComponents(a-s,u-c,_-f,S-g).normalize(),e[4].setComponents(a-o,u-h,_-p,S-m).normalize(),e[5].setComponents(a+o,u+h,_+p,S+m).normalize(),this}intersectsObject(t){const e=t.geometry;return e.boundingSphere===null&&e.computeBoundingSphere(),vi.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),this.intersectsSphere(vi)}intersectsSprite(t){return vi.center.set(0,0,0),vi.radius=.7071067811865476,vi.applyMatrix4(t.matrixWorld),this.intersectsSphere(vi)}intersectsSphere(t){const e=this.planes,i=t.center,r=-t.radius;for(let s=0;s<6;s++)if(e[s].distanceToPoint(i)<r)return!1;return!0}intersectsBox(t){const e=this.planes;for(let i=0;i<6;i++){const r=e[i];if(us.x=r.normal.x>0?t.max.x:t.min.x,us.y=r.normal.y>0?t.max.y:t.min.y,us.z=r.normal.z>0?t.max.z:t.min.z,r.distanceToPoint(us)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let i=0;i<6;i++)if(e[i].distanceToPoint(t)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function Mu(){let n=null,t=!1,e=null,i=null;function r(s,o){e(s,o),i=n.requestAnimationFrame(r)}return{start:function(){t!==!0&&e!==null&&(i=n.requestAnimationFrame(r),t=!0)},stop:function(){n.cancelAnimationFrame(i),t=!1},setAnimationLoop:function(s){e=s},setContext:function(s){n=s}}}function Am(n,t){const e=t.isWebGL2,i=new WeakMap;function r(c,h){const u=c.array,d=c.usage,f=n.createBuffer();n.bindBuffer(h,f),n.bufferData(h,u,d),c.onUploadCallback();let p=5126;return u instanceof Float32Array?p=5126:u instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):u instanceof Uint16Array?c.isFloat16BufferAttribute?e?p=5131:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):p=5123:u instanceof Int16Array?p=5122:u instanceof Uint32Array?p=5125:u instanceof Int32Array?p=5124:u instanceof Int8Array?p=5120:u instanceof Uint8Array&&(p=5121),{buffer:f,type:p,bytesPerElement:u.BYTES_PER_ELEMENT,version:c.version}}function s(c,h,u){const d=h.array,f=h.updateRange;n.bindBuffer(u,c),f.count===-1?n.bufferSubData(u,0,d):(e?n.bufferSubData(u,f.offset*d.BYTES_PER_ELEMENT,d,f.offset,f.count):n.bufferSubData(u,f.offset*d.BYTES_PER_ELEMENT,d.subarray(f.offset,f.offset+f.count)),f.count=-1)}function o(c){return c.isInterleavedBufferAttribute&&(c=c.data),i.get(c)}function a(c){c.isInterleavedBufferAttribute&&(c=c.data);const h=i.get(c);h&&(n.deleteBuffer(h.buffer),i.delete(c))}function l(c,h){if(c.isGLBufferAttribute){const d=i.get(c);(!d||d.version<c.version)&&i.set(c,{buffer:c.buffer,type:c.type,bytesPerElement:c.elementSize,version:c.version});return}c.isInterleavedBufferAttribute&&(c=c.data);const u=i.get(c);u===void 0?i.set(c,r(c,h)):u.version<c.version&&(s(u.buffer,c,h),u.version=c.version)}return{get:o,remove:a,update:l}}class Su extends Dt{constructor(t=1,e=1,i=1,r=1){super(),this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:i,heightSegments:r};const s=t/2,o=e/2,a=Math.floor(i),l=Math.floor(r),c=a+1,h=l+1,u=t/a,d=e/l,f=[],p=[],_=[],x=[];for(let g=0;g<h;g++){const m=g*d-o;for(let S=0;S<c;S++){const M=S*u-s;p.push(M,-m,0),_.push(0,0,1),x.push(S/a),x.push(1-g/l)}}for(let g=0;g<l;g++)for(let m=0;m<a;m++){const S=m+c*g,M=m+c*(g+1),v=m+1+c*(g+1),y=m+1+c*g;f.push(S,M,y),f.push(M,v,y)}this.setIndex(f),this.setAttribute("position",new Vt(p,3)),this.setAttribute("normal",new Vt(_,3)),this.setAttribute("uv",new Vt(x,2))}}var Lm=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,Cm=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,Rm=`#ifdef ALPHATEST
	if ( diffuseColor.a < ALPHATEST ) discard;
#endif`,Pm=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );
	#endif
#endif`,Dm=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,Im="vec3 transformed = vec3( position );",Fm=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,Nm=`vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	return vec2( -1.04, 1.04 ) * a004 + r.zw;
}
float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
#if defined ( PHYSICALLY_CORRECT_LIGHTS )
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
#else
	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );
	}
	return 1.0;
#endif
}
vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {
	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );
	return ( 1.0 - specularColor ) * fresnel + specularColor;
}
vec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {
	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );
	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;
	return Fr * fresnel + F0;
}
float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	return 1.0 / ( gl * gv );
}
float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( incidentLight.direction + viewDir );
	float dotNL = saturate( dot( normal, incidentLight.direction ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( G * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
vec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	return specularColor * brdf.x + brdf.y;
}
void BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	vec3 FssEss = F * brdf.x + brdf.y;
	float Ess = brdf.x + brdf.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
}
float BlinnExponentToGGXRoughness( const in float blinnExponent ) {
	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );
}
#if defined( USE_SHEEN )
float D_Charlie(float roughness, float NoH) {
	float invAlpha = 1.0 / roughness;
	float cos2h = NoH * NoH;
	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);
}
float V_Neubelt(float NoV, float NoL) {
	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));
}
vec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {
	vec3 N = geometry.normal;
	vec3 V = geometry.viewDir;
	vec3 H = normalize( V + L );
	float dotNH = saturate( dot( N, H ) );
	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );
}
#endif`,Om=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,Bm=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,zm=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,km=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,Um=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,Hm=`#ifdef USE_COLOR
	diffuseColor.rgb *= vColor;
#endif`,Gm=`#ifdef USE_COLOR
	varying vec3 vColor;
#endif`,Vm=`#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,Wm=`#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor.xyz *= color.xyz;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,qm=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement(a) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract(sin(sn) * c);
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	float distance = dot( planeNormal, point - pointOnPlane );
	return - distance * planeNormal + point;
}
float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return sign( dot( point - pointOnPlane, planeNormal ) );
}
vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,jm=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_maxMipLevel 8.0
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_maxTileSize 256.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );
		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );
		vec2 f = fract( uv );
		uv += 0.5 - f;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		if ( mipInt < cubeUV_maxMipLevel ) {
			uv.y += 2.0 * cubeUV_maxTileSize;
		}
		uv.y += filterInt * 2.0 * cubeUV_minTileSize;
		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );
		uv *= texelSize;
		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x += texelSize;
		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.y += texelSize;
		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x -= texelSize;
		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		vec3 tm = mix( tl, tr, f.x );
		vec3 bm = mix( bl, br, f.x );
		return mix( tm, bm, f.y );
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,Xm=`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,Ym=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,Zm=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,Jm=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,Qm=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,$m="gl_FragColor = linearToOutputTexel( gl_FragColor );",Km=`
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value ) {
	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}`,tg=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifndef ENVMAP_TYPE_CUBE_UV
		envColor = envMapTexelToLinear( envColor );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,eg=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform int maxMipLevel;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,ng=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,ig=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,rg=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,sg=`#ifdef USE_FOG
	fogDepth = - mvPosition.z;
#endif`,og=`#ifdef USE_FOG
	varying float fogDepth;
#endif`,ag=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,lg=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float fogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,cg=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return texture2D( gradientMap, coord ).rgb;
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,hg=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel= texture2D( lightMap, vUv2 );
	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
#endif`,ug=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,dg=`vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );
		#endif
	}
	#pragma unroll_loop_end
#endif`,fg=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {
	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	return irradiance;
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		directLight.color = directionalLight.color;
		directLight.direction = directionalLight.direction;
		directLight.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = pointLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		directLight.color = pointLight.color;
		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );
		directLight.visible = ( directLight.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = spotLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		float angleCos = dot( directLight.direction, spotLight.direction );
		if ( angleCos > spotLight.coneCos ) {
			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );
			directLight.color = spotLight.color;
			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );
			directLight.visible = true;
		} else {
			directLight.color = vec3( 0.0 );
			directLight.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {
		float dotNL = dot( geometry.normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			irradiance *= PI;
		#endif
		return irradiance;
	}
#endif`,pg=`#if defined( USE_ENVMAP )
	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif
	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {
		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );
			#else
				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
		#else
			vec4 envMapColor = vec4( 0.0 );
		#endif
		return PI * envMapColor.rgb * envMapIntensity;
	}
	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {
		float maxMIPLevelScalar = float( maxMIPLevel );
		float sigma = PI * roughness * roughness / ( 1.0 + roughness );
		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );
		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
	}
	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( -viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
		#else
			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );
		#endif
		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );
			#else
				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
		#endif
		return envMapColor.rgb * envMapIntensity;
	}
#endif`,mg=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,gg=`varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,_g=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,xg=`varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,yg=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;
material.specularRoughness = min( material.specularRoughness, 1.0 );
#ifdef REFLECTIVITY
	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );
#endif
#ifdef CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheen;
#endif`,vg=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float specularRoughness;
	vec3 specularColor;
#ifdef CLEARCOAT
	float clearcoat;
	float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	vec3 sheenColor;
#endif
};
#define MAXIMUM_SPECULAR_COEFFICIENT 0.16
#define DEFAULT_SPECULAR_COEFFICIENT 0.04
float clearcoatDHRApprox( const in float roughness, const in float dotNL ) {
	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.specularRoughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	#ifdef CLEARCOAT
		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = ccDotNL * directLight.color;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			ccIrradiance *= PI;
		#endif
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
	#else
		float clearcoatDHR = 0.0;
	#endif
	#ifdef USE_SHEEN
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(
			material.specularRoughness,
			directLight.direction,
			geometry,
			material.sheenColor
		);
	#else
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);
	#endif
	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef CLEARCOAT
		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
		float ccDotNL = ccDotNV;
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
	#else
		float clearcoatDHR = 0.0;
	#endif
	float clearcoatInv = 1.0 - clearcoatDHR;
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,bg=`
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointDirectLightIrradiance( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotDirectLightIrradiance( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,wg=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );
	#ifdef CLEARCOAT
		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );
	#endif
#endif`,Mg=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,Sg=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,Tg=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,Eg=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,Ag=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,Lg=`#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif`,Cg=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,Rg=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,Pg=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,Dg=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,Ig=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,Fg=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
#endif`,Ng=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifndef USE_MORPHNORMALS
		uniform float morphTargetInfluences[ 8 ];
	#else
		uniform float morphTargetInfluences[ 4 ];
	#endif
#endif`,Og=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	transformed += morphTarget0 * morphTargetInfluences[ 0 ];
	transformed += morphTarget1 * morphTargetInfluences[ 1 ];
	transformed += morphTarget2 * morphTargetInfluences[ 2 ];
	transformed += morphTarget3 * morphTargetInfluences[ 3 ];
	#ifndef USE_MORPHNORMALS
		transformed += morphTarget4 * morphTargetInfluences[ 4 ];
		transformed += morphTarget5 * morphTargetInfluences[ 5 ];
		transformed += morphTarget6 * morphTargetInfluences[ 6 ];
		transformed += morphTarget7 * morphTargetInfluences[ 7 ];
	#endif
#endif`,Bg=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,zg=`#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,kg=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,Ug=`#ifdef CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,Hg=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,Gg=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,Vg=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,Wg=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,qg=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,jg=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,Xg=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,Yg=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,Zg=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,Jg=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,Qg=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,$g=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,Kg=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,t_=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,e_=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`,n_=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,i_=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,r_=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,s_=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,o_=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,a_=`#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,l_=`#ifdef USE_TRANSMISSIONMAP
	totalTransmission *= texture2D( transmissionMap, vUv ).r;
#endif`,c_=`#ifdef USE_TRANSMISSIONMAP
	uniform sampler2D transmissionMap;
#endif`,h_=`#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,u_=`#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,d_=`#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,f_=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,p_=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,m_=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,g_=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`,__=`uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,x_=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,y_=`#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,v_=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,b_=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,w_=`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,M_=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,S_=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,T_=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	vec4 texColor = texture2D( tEquirect, sampleUV );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,E_=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,A_=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,L_=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,C_=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
	
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,R_=`#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <skinbase_vertex>
	#ifdef USE_ENVMAP
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,P_=`uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,D_=`#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,I_=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );
	#else
		vec4 matcapColor = vec4( 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,F_=`#define MATCAP
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#ifndef FLAT_SHADED
		vNormal = normalize( transformedNormal );
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,N_=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,O_=`#define TOON
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,B_=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,z_=`#define PHONG
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,k_=`#define STANDARD
#ifdef PHYSICAL
	#define REFLECTIVITY
	#define CLEARCOAT
	#define TRANSMISSION
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef TRANSMISSION
	uniform float transmission;
#endif
#ifdef REFLECTIVITY
	uniform float reflectivity;
#endif
#ifdef CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheen;
#endif
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <transmissionmap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <lights_physical_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#ifdef TRANSMISSION
		float totalTransmission = transmission;
	#endif
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <transmissionmap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#ifdef TRANSMISSION
		diffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );
	#endif
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,U_=`#define STANDARD
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,H_=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <packing>
#include <uv_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}`,G_=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,V_=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,W_=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,q_=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,j_=`#include <common>
#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <begin_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,X_=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,Y_=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`;const St={alphamap_fragment:Lm,alphamap_pars_fragment:Cm,alphatest_fragment:Rm,aomap_fragment:Pm,aomap_pars_fragment:Dm,begin_vertex:Im,beginnormal_vertex:Fm,bsdfs:Nm,bumpmap_pars_fragment:Om,clipping_planes_fragment:Bm,clipping_planes_pars_fragment:zm,clipping_planes_pars_vertex:km,clipping_planes_vertex:Um,color_fragment:Hm,color_pars_fragment:Gm,color_pars_vertex:Vm,color_vertex:Wm,common:qm,cube_uv_reflection_fragment:jm,defaultnormal_vertex:Xm,displacementmap_pars_vertex:Ym,displacementmap_vertex:Zm,emissivemap_fragment:Jm,emissivemap_pars_fragment:Qm,encodings_fragment:$m,encodings_pars_fragment:Km,envmap_fragment:tg,envmap_common_pars_fragment:eg,envmap_pars_fragment:ng,envmap_pars_vertex:ig,envmap_physical_pars_fragment:pg,envmap_vertex:rg,fog_vertex:sg,fog_pars_vertex:og,fog_fragment:ag,fog_pars_fragment:lg,gradientmap_pars_fragment:cg,lightmap_fragment:hg,lightmap_pars_fragment:ug,lights_lambert_vertex:dg,lights_pars_begin:fg,lights_toon_fragment:mg,lights_toon_pars_fragment:gg,lights_phong_fragment:_g,lights_phong_pars_fragment:xg,lights_physical_fragment:yg,lights_physical_pars_fragment:vg,lights_fragment_begin:bg,lights_fragment_maps:wg,lights_fragment_end:Mg,logdepthbuf_fragment:Sg,logdepthbuf_pars_fragment:Tg,logdepthbuf_pars_vertex:Eg,logdepthbuf_vertex:Ag,map_fragment:Lg,map_pars_fragment:Cg,map_particle_fragment:Rg,map_particle_pars_fragment:Pg,metalnessmap_fragment:Dg,metalnessmap_pars_fragment:Ig,morphnormal_vertex:Fg,morphtarget_pars_vertex:Ng,morphtarget_vertex:Og,normal_fragment_begin:Bg,normal_fragment_maps:zg,normalmap_pars_fragment:kg,clearcoat_normal_fragment_begin:Ug,clearcoat_normal_fragment_maps:Hg,clearcoat_pars_fragment:Gg,packing:Vg,premultiplied_alpha_fragment:Wg,project_vertex:qg,dithering_fragment:jg,dithering_pars_fragment:Xg,roughnessmap_fragment:Yg,roughnessmap_pars_fragment:Zg,shadowmap_pars_fragment:Jg,shadowmap_pars_vertex:Qg,shadowmap_vertex:$g,shadowmask_pars_fragment:Kg,skinbase_vertex:t_,skinning_pars_vertex:e_,skinning_vertex:n_,skinnormal_vertex:i_,specularmap_fragment:r_,specularmap_pars_fragment:s_,tonemapping_fragment:o_,tonemapping_pars_fragment:a_,transmissionmap_fragment:l_,transmissionmap_pars_fragment:c_,uv_pars_fragment:h_,uv_pars_vertex:u_,uv_vertex:d_,uv2_pars_fragment:f_,uv2_pars_vertex:p_,uv2_vertex:m_,worldpos_vertex:g_,background_frag:__,background_vert:x_,cube_frag:y_,cube_vert:v_,depth_frag:b_,depth_vert:w_,distanceRGBA_frag:M_,distanceRGBA_vert:S_,equirect_frag:T_,equirect_vert:E_,linedashed_frag:A_,linedashed_vert:L_,meshbasic_frag:C_,meshbasic_vert:R_,meshlambert_frag:P_,meshlambert_vert:D_,meshmatcap_frag:I_,meshmatcap_vert:F_,meshtoon_frag:N_,meshtoon_vert:O_,meshphong_frag:B_,meshphong_vert:z_,meshphysical_frag:k_,meshphysical_vert:U_,normal_frag:H_,normal_vert:G_,points_frag:V_,points_vert:W_,shadow_frag:q_,shadow_vert:j_,sprite_frag:X_,sprite_vert:Y_},tt={common:{diffuse:{value:new pt(15658734)},opacity:{value:1},map:{value:null},uvTransform:{value:new ae},uv2Transform:{value:new ae},alphaMap:{value:null}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},refractionRatio:{value:.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new J(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new pt(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new pt(15658734)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},uvTransform:{value:new ae}},sprite:{diffuse:{value:new pt(15658734)},opacity:{value:1},center:{value:new J(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},uvTransform:{value:new ae}}},tn={basic:{uniforms:ce([tt.common,tt.specularmap,tt.envmap,tt.aomap,tt.lightmap,tt.fog]),vertexShader:St.meshbasic_vert,fragmentShader:St.meshbasic_frag},lambert:{uniforms:ce([tt.common,tt.specularmap,tt.envmap,tt.aomap,tt.lightmap,tt.emissivemap,tt.fog,tt.lights,{emissive:{value:new pt(0)}}]),vertexShader:St.meshlambert_vert,fragmentShader:St.meshlambert_frag},phong:{uniforms:ce([tt.common,tt.specularmap,tt.envmap,tt.aomap,tt.lightmap,tt.emissivemap,tt.bumpmap,tt.normalmap,tt.displacementmap,tt.fog,tt.lights,{emissive:{value:new pt(0)},specular:{value:new pt(1118481)},shininess:{value:30}}]),vertexShader:St.meshphong_vert,fragmentShader:St.meshphong_frag},standard:{uniforms:ce([tt.common,tt.envmap,tt.aomap,tt.lightmap,tt.emissivemap,tt.bumpmap,tt.normalmap,tt.displacementmap,tt.roughnessmap,tt.metalnessmap,tt.fog,tt.lights,{emissive:{value:new pt(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:St.meshphysical_vert,fragmentShader:St.meshphysical_frag},toon:{uniforms:ce([tt.common,tt.aomap,tt.lightmap,tt.emissivemap,tt.bumpmap,tt.normalmap,tt.displacementmap,tt.gradientmap,tt.fog,tt.lights,{emissive:{value:new pt(0)}}]),vertexShader:St.meshtoon_vert,fragmentShader:St.meshtoon_frag},matcap:{uniforms:ce([tt.common,tt.bumpmap,tt.normalmap,tt.displacementmap,tt.fog,{matcap:{value:null}}]),vertexShader:St.meshmatcap_vert,fragmentShader:St.meshmatcap_frag},points:{uniforms:ce([tt.points,tt.fog]),vertexShader:St.points_vert,fragmentShader:St.points_frag},dashed:{uniforms:ce([tt.common,tt.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:St.linedashed_vert,fragmentShader:St.linedashed_frag},depth:{uniforms:ce([tt.common,tt.displacementmap]),vertexShader:St.depth_vert,fragmentShader:St.depth_frag},normal:{uniforms:ce([tt.common,tt.bumpmap,tt.normalmap,tt.displacementmap,{opacity:{value:1}}]),vertexShader:St.normal_vert,fragmentShader:St.normal_frag},sprite:{uniforms:ce([tt.sprite,tt.fog]),vertexShader:St.sprite_vert,fragmentShader:St.sprite_frag},background:{uniforms:{uvTransform:{value:new ae},t2D:{value:null}},vertexShader:St.background_vert,fragmentShader:St.background_frag},cube:{uniforms:ce([tt.envmap,{opacity:{value:1}}]),vertexShader:St.cube_vert,fragmentShader:St.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:St.equirect_vert,fragmentShader:St.equirect_frag},distanceRGBA:{uniforms:ce([tt.common,tt.displacementmap,{referencePosition:{value:new A},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:St.distanceRGBA_vert,fragmentShader:St.distanceRGBA_frag},shadow:{uniforms:ce([tt.lights,tt.fog,{color:{value:new pt(0)},opacity:{value:1}}]),vertexShader:St.shadow_vert,fragmentShader:St.shadow_frag}};tn.physical={uniforms:ce([tn.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new J(1,1)},clearcoatNormalMap:{value:null},sheen:{value:new pt(0)},transmission:{value:0},transmissionMap:{value:null}}]),vertexShader:St.meshphysical_vert,fragmentShader:St.meshphysical_frag};function Z_(n,t,e,i,r){const s=new pt(0);let o=0,a,l,c=null,h=0,u=null;function d(p,_,x,g){let m=_.isScene===!0?_.background:null;m&&m.isTexture&&(m=t.get(m));const S=n.xr,M=S.getSession&&S.getSession();M&&M.environmentBlendMode==="additive"&&(m=null),m===null?f(s,o):m&&m.isColor&&(f(m,1),g=!0),(n.autoClear||g)&&n.clear(n.autoClearColor,n.autoClearDepth,n.autoClearStencil),m&&(m.isCubeTexture||m.isWebGLCubeRenderTarget||m.mapping===Ka)?(l===void 0&&(l=new ne(new rl(1,1,1),new Ue({name:"BackgroundCubeMaterial",uniforms:Ui(tn.cube.uniforms),vertexShader:tn.cube.vertexShader,fragmentShader:tn.cube.fragmentShader,side:Kt,depthTest:!1,depthWrite:!1,fog:!1})),l.geometry.deleteAttribute("normal"),l.geometry.deleteAttribute("uv"),l.onBeforeRender=function(v,y,T){this.matrixWorld.copyPosition(T.matrixWorld)},Object.defineProperty(l.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),i.update(l)),m.isWebGLCubeRenderTarget&&(m=m.texture),l.material.uniforms.envMap.value=m,l.material.uniforms.flipEnvMap.value=m.isCubeTexture&&m._needsFlipEnvMap?-1:1,(c!==m||h!==m.version||u!==n.toneMapping)&&(l.material.needsUpdate=!0,c=m,h=m.version,u=n.toneMapping),p.unshift(l,l.geometry,l.material,0,0,null)):m&&m.isTexture&&(a===void 0&&(a=new ne(new Su(2,2),new Ue({name:"BackgroundMaterial",uniforms:Ui(tn.background.uniforms),vertexShader:tn.background.vertexShader,fragmentShader:tn.background.fragmentShader,side:Zs,depthTest:!1,depthWrite:!1,fog:!1})),a.geometry.deleteAttribute("normal"),Object.defineProperty(a.material,"map",{get:function(){return this.uniforms.t2D.value}}),i.update(a)),a.material.uniforms.t2D.value=m,m.matrixAutoUpdate===!0&&m.updateMatrix(),a.material.uniforms.uvTransform.value.copy(m.matrix),(c!==m||h!==m.version||u!==n.toneMapping)&&(a.material.needsUpdate=!0,c=m,h=m.version,u=n.toneMapping),p.unshift(a,a.geometry,a.material,0,0,null))}function f(p,_){e.buffers.color.setClear(p.r,p.g,p.b,_,r)}return{getClearColor:function(){return s},setClearColor:function(p,_=1){s.set(p),o=_,f(s,o)},getClearAlpha:function(){return o},setClearAlpha:function(p){o=p,f(s,o)},render:d}}function J_(n,t,e,i){const r=n.getParameter(34921),s=i.isWebGL2?null:t.get("OES_vertex_array_object"),o=i.isWebGL2||s!==null,a={},l=_(null);let c=l;function h(I,C,P,O,G){let Y=!1;if(o){const Q=p(O,P,C);c!==Q&&(c=Q,d(c.object)),Y=x(O,G),Y&&g(O,G)}else{const Q=C.wireframe===!0;(c.geometry!==O.id||c.program!==P.id||c.wireframe!==Q)&&(c.geometry=O.id,c.program=P.id,c.wireframe=Q,Y=!0)}I.isInstancedMesh===!0&&(Y=!0),G!==null&&e.update(G,34963),Y&&(T(I,C,P,O),G!==null&&n.bindBuffer(34963,e.get(G).buffer))}function u(){return i.isWebGL2?n.createVertexArray():s.createVertexArrayOES()}function d(I){return i.isWebGL2?n.bindVertexArray(I):s.bindVertexArrayOES(I)}function f(I){return i.isWebGL2?n.deleteVertexArray(I):s.deleteVertexArrayOES(I)}function p(I,C,P){const O=P.wireframe===!0;let G=a[I.id];G===void 0&&(G={},a[I.id]=G);let Y=G[C.id];Y===void 0&&(Y={},G[C.id]=Y);let Q=Y[O];return Q===void 0&&(Q=_(u()),Y[O]=Q),Q}function _(I){const C=[],P=[],O=[];for(let G=0;G<r;G++)C[G]=0,P[G]=0,O[G]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:C,enabledAttributes:P,attributeDivisors:O,object:I,attributes:{},index:null}}function x(I,C){const P=c.attributes,O=I.attributes;let G=0;for(const Y in O){const Q=P[Y],it=O[Y];if(Q===void 0||Q.attribute!==it||Q.data!==it.data)return!0;G++}return c.attributesNum!==G||c.index!==C}function g(I,C){const P={},O=I.attributes;let G=0;for(const Y in O){const Q=O[Y],it={};it.attribute=Q,Q.data&&(it.data=Q.data),P[Y]=it,G++}c.attributes=P,c.attributesNum=G,c.index=C}function m(){const I=c.newAttributes;for(let C=0,P=I.length;C<P;C++)I[C]=0}function S(I){M(I,0)}function M(I,C){const P=c.newAttributes,O=c.enabledAttributes,G=c.attributeDivisors;P[I]=1,O[I]===0&&(n.enableVertexAttribArray(I),O[I]=1),G[I]!==C&&((i.isWebGL2?n:t.get("ANGLE_instanced_arrays"))[i.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](I,C),G[I]=C)}function v(){const I=c.newAttributes,C=c.enabledAttributes;for(let P=0,O=C.length;P<O;P++)C[P]!==I[P]&&(n.disableVertexAttribArray(P),C[P]=0)}function y(I,C,P,O,G,Y){i.isWebGL2===!0&&(P===5124||P===5125)?n.vertexAttribIPointer(I,C,P,G,Y):n.vertexAttribPointer(I,C,P,O,G,Y)}function T(I,C,P,O){if(i.isWebGL2===!1&&(I.isInstancedMesh||O.isInstancedBufferGeometry)&&t.get("ANGLE_instanced_arrays")===null)return;m();const G=O.attributes,Y=P.getAttributes(),Q=C.defaultAttributeValues;for(const it in Y){const et=Y[it];if(et>=0){const wt=G[it];if(wt!==void 0){const ot=wt.normalized,Et=wt.itemSize,Ct=e.get(wt);if(Ct===void 0)continue;const H=Ct.buffer,Ht=Ct.type,Lt=Ct.bytesPerElement;if(wt.isInterleavedBufferAttribute){const Rt=wt.data,gt=Rt.stride,Pt=wt.offset;Rt&&Rt.isInstancedInterleavedBuffer?(M(et,Rt.meshPerAttribute),O._maxInstanceCount===void 0&&(O._maxInstanceCount=Rt.meshPerAttribute*Rt.count)):S(et),n.bindBuffer(34962,H),y(et,Et,Ht,ot,gt*Lt,Pt*Lt)}else wt.isInstancedBufferAttribute?(M(et,wt.meshPerAttribute),O._maxInstanceCount===void 0&&(O._maxInstanceCount=wt.meshPerAttribute*wt.count)):S(et),n.bindBuffer(34962,H),y(et,Et,Ht,ot,0,0)}else if(it==="instanceMatrix"){const ot=e.get(I.instanceMatrix);if(ot===void 0)continue;const Et=ot.buffer,Ct=ot.type;M(et+0,1),M(et+1,1),M(et+2,1),M(et+3,1),n.bindBuffer(34962,Et),n.vertexAttribPointer(et+0,4,Ct,!1,64,0),n.vertexAttribPointer(et+1,4,Ct,!1,64,16),n.vertexAttribPointer(et+2,4,Ct,!1,64,32),n.vertexAttribPointer(et+3,4,Ct,!1,64,48)}else if(it==="instanceColor"){const ot=e.get(I.instanceColor);if(ot===void 0)continue;const Et=ot.buffer,Ct=ot.type;M(et,1),n.bindBuffer(34962,Et),n.vertexAttribPointer(et,3,Ct,!1,12,0)}else if(Q!==void 0){const ot=Q[it];if(ot!==void 0)switch(ot.length){case 2:n.vertexAttrib2fv(et,ot);break;case 3:n.vertexAttrib3fv(et,ot);break;case 4:n.vertexAttrib4fv(et,ot);break;default:n.vertexAttrib1fv(et,ot)}}}}v()}function D(){N();for(const I in a){const C=a[I];for(const P in C){const O=C[P];for(const G in O)f(O[G].object),delete O[G];delete C[P]}delete a[I]}}function L(I){if(a[I.id]===void 0)return;const C=a[I.id];for(const P in C){const O=C[P];for(const G in O)f(O[G].object),delete O[G];delete C[P]}delete a[I.id]}function F(I){for(const C in a){const P=a[C];if(P[I.id]===void 0)continue;const O=P[I.id];for(const G in O)f(O[G].object),delete O[G];delete P[I.id]}}function N(){k(),c!==l&&(c=l,d(c.object))}function k(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:h,reset:N,resetDefaultState:k,dispose:D,releaseStatesOfGeometry:L,releaseStatesOfProgram:F,initAttributes:m,enableAttribute:S,disableUnusedAttributes:v}}function Q_(n,t,e,i){const r=i.isWebGL2;let s;function o(c){s=c}function a(c,h){n.drawArrays(s,c,h),e.update(h,s,1)}function l(c,h,u){if(u===0)return;let d,f;if(r)d=n,f="drawArraysInstanced";else if(d=t.get("ANGLE_instanced_arrays"),f="drawArraysInstancedANGLE",d===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}d[f](s,c,h,u),e.update(h,s,u)}this.setMode=o,this.render=a,this.renderInstances=l}function $_(n,t,e){let i;function r(){if(i!==void 0)return i;if(t.has("EXT_texture_filter_anisotropic")===!0){const y=t.get("EXT_texture_filter_anisotropic");i=n.getParameter(y.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else i=0;return i}function s(y){if(y==="highp"){if(n.getShaderPrecisionFormat(35633,36338).precision>0&&n.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";y="mediump"}return y==="mediump"&&n.getShaderPrecisionFormat(35633,36337).precision>0&&n.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const o=typeof WebGL2RenderingContext!="undefined"&&n instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext!="undefined"&&n instanceof WebGL2ComputeRenderingContext;let a=e.precision!==void 0?e.precision:"highp";const l=s(a);l!==a&&(console.warn("THREE.WebGLRenderer:",a,"not supported, using",l,"instead."),a=l);const c=e.logarithmicDepthBuffer===!0,h=n.getParameter(34930),u=n.getParameter(35660),d=n.getParameter(3379),f=n.getParameter(34076),p=n.getParameter(34921),_=n.getParameter(36347),x=n.getParameter(36348),g=n.getParameter(36349),m=u>0,S=o||t.has("OES_texture_float"),M=m&&S,v=o?n.getParameter(36183):0;return{isWebGL2:o,getMaxAnisotropy:r,getMaxPrecision:s,precision:a,logarithmicDepthBuffer:c,maxTextures:h,maxVertexTextures:u,maxTextureSize:d,maxCubemapSize:f,maxAttributes:p,maxVertexUniforms:_,maxVaryings:x,maxFragmentUniforms:g,vertexTextures:m,floatFragmentTextures:S,floatVertexTextures:M,maxSamples:v}}function K_(n){const t=this;let e=null,i=0,r=!1,s=!1;const o=new Ke,a=new ae,l={value:null,needsUpdate:!1};this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(u,d,f){const p=u.length!==0||d||i!==0||r;return r=d,e=h(u,f,0),i=u.length,p},this.beginShadows=function(){s=!0,h(null)},this.endShadows=function(){s=!1,c()},this.setState=function(u,d,f){const p=u.clippingPlanes,_=u.clipIntersection,x=u.clipShadows,g=n.get(u);if(!r||p===null||p.length===0||s&&!x)s?h(null):c();else{const m=s?0:i,S=m*4;let M=g.clippingState||null;l.value=M,M=h(p,d,S,f);for(let v=0;v!==S;++v)M[v]=e[v];g.clippingState=M,this.numIntersection=_?this.numPlanes:0,this.numPlanes+=m}};function c(){l.value!==e&&(l.value=e,l.needsUpdate=i>0),t.numPlanes=i,t.numIntersection=0}function h(u,d,f,p){const _=u!==null?u.length:0;let x=null;if(_!==0){if(x=l.value,p!==!0||x===null){const g=f+_*4,m=d.matrixWorldInverse;a.getNormalMatrix(m),(x===null||x.length<g)&&(x=new Float32Array(g));for(let S=0,M=f;S!==_;++S,M+=4)o.copy(u[S]).applyMatrix4(m,a),o.normal.toArray(x,M),x[M+3]=o.constant}l.value=x,l.needsUpdate=!0}return t.numPlanes=_,t.numIntersection=0,x}}function t0(n){let t=new WeakMap;function e(o,a){return a===Yl?o.mapping=Qa:a===Zl&&(o.mapping=$a),o}function i(o){if(o&&o.isTexture){const a=o.mapping;if(a===Yl||a===Zl)if(t.has(o)){const l=t.get(o).texture;return e(l,o.mapping)}else{const l=o.image;if(l&&l.height>0){const c=n.getRenderTarget(),h=new wu(l.height/2);return h.fromEquirectangularTexture(n,o),t.set(o,h),n.setRenderTarget(c),o.addEventListener("dispose",r),e(h.texture,o.mapping)}else return null}}return o}function r(o){const a=o.target;a.removeEventListener("dispose",r);const l=t.get(a);l!==void 0&&(t.delete(a),l.dispose())}function s(){t=new WeakMap}return{get:i,dispose:s}}function e0(n){const t={};function e(i){if(t[i]!==void 0)return t[i];let r;switch(i){case"WEBGL_depth_texture":r=n.getExtension("WEBGL_depth_texture")||n.getExtension("MOZ_WEBGL_depth_texture")||n.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":r=n.getExtension("EXT_texture_filter_anisotropic")||n.getExtension("MOZ_EXT_texture_filter_anisotropic")||n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":r=n.getExtension("WEBGL_compressed_texture_s3tc")||n.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":r=n.getExtension("WEBGL_compressed_texture_pvrtc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:r=n.getExtension(i)}return t[i]=r,r}return{has:function(i){return e(i)!==null},init:function(i){i.isWebGL2?e("EXT_color_buffer_float"):(e("WEBGL_depth_texture"),e("OES_texture_float"),e("OES_texture_half_float"),e("OES_texture_half_float_linear"),e("OES_standard_derivatives"),e("OES_element_index_uint"),e("OES_vertex_array_object"),e("ANGLE_instanced_arrays")),e("OES_texture_float_linear"),e("EXT_color_buffer_half_float")},get:function(i){const r=e(i);return r===null&&console.warn("THREE.WebGLRenderer: "+i+" extension not supported."),r}}}function n0(n,t,e,i){const r={},s=new WeakMap;function o(u){const d=u.target;d.index!==null&&t.remove(d.index);for(const p in d.attributes)t.remove(d.attributes[p]);d.removeEventListener("dispose",o),delete r[d.id];const f=s.get(d);f&&(t.remove(f),s.delete(d)),i.releaseStatesOfGeometry(d),d.isInstancedBufferGeometry===!0&&delete d._maxInstanceCount,e.memory.geometries--}function a(u,d){return r[d.id]===!0||(d.addEventListener("dispose",o),r[d.id]=!0,e.memory.geometries++),d}function l(u){const d=u.attributes;for(const p in d)t.update(d[p],34962);const f=u.morphAttributes;for(const p in f){const _=f[p];for(let x=0,g=_.length;x<g;x++)t.update(_[x],34962)}}function c(u){const d=[],f=u.index,p=u.attributes.position;let _=0;if(f!==null){const m=f.array;_=f.version;for(let S=0,M=m.length;S<M;S+=3){const v=m[S+0],y=m[S+1],T=m[S+2];d.push(v,y,y,T,T,v)}}else{const m=p.array;_=p.version;for(let S=0,M=m.length/3-1;S<M;S+=3){const v=S+0,y=S+1,T=S+2;d.push(v,y,y,T,T,v)}}const x=new(bu(d)>65535?Or:Nr)(d,1);x.version=_;const g=s.get(u);g&&t.remove(g),s.set(u,x)}function h(u){const d=s.get(u);if(d){const f=u.index;f!==null&&d.version<f.version&&c(u)}else c(u);return s.get(u)}return{get:a,update:l,getWireframeAttribute:h}}function i0(n,t,e,i){const r=i.isWebGL2;let s;function o(d){s=d}let a,l;function c(d){a=d.type,l=d.bytesPerElement}function h(d,f){n.drawElements(s,f,a,d*l),e.update(f,s,1)}function u(d,f,p){if(p===0)return;let _,x;if(r)_=n,x="drawElementsInstanced";else if(_=t.get("ANGLE_instanced_arrays"),x="drawElementsInstancedANGLE",_===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}_[x](s,f,a,d*l,p),e.update(f,s,p)}this.setMode=o,this.setIndex=c,this.render=h,this.renderInstances=u}function r0(n){const t={geometries:0,textures:0},e={frame:0,calls:0,triangles:0,points:0,lines:0};function i(s,o,a){switch(e.calls++,o){case 4:e.triangles+=a*(s/3);break;case 1:e.lines+=a*(s/2);break;case 3:e.lines+=a*(s-1);break;case 2:e.lines+=a*s;break;case 0:e.points+=a*s;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",o);break}}function r(){e.frame++,e.calls=0,e.triangles=0,e.points=0,e.lines=0}return{memory:t,render:e,programs:null,autoReset:!0,reset:r,update:i}}function s0(n,t){return n[0]-t[0]}function o0(n,t){return Math.abs(t[1])-Math.abs(n[1])}function a0(n){const t={},e=new Float32Array(8),i=[];for(let s=0;s<8;s++)i[s]=[s,0];function r(s,o,a,l){const c=s.morphTargetInfluences,h=c===void 0?0:c.length;let u=t[o.id];if(u===void 0){u=[];for(let x=0;x<h;x++)u[x]=[x,0];t[o.id]=u}for(let x=0;x<h;x++){const g=u[x];g[0]=x,g[1]=c[x]}u.sort(o0);for(let x=0;x<8;x++)x<h&&u[x][1]?(i[x][0]=u[x][0],i[x][1]=u[x][1]):(i[x][0]=Number.MAX_SAFE_INTEGER,i[x][1]=0);i.sort(s0);const d=a.morphTargets&&o.morphAttributes.position,f=a.morphNormals&&o.morphAttributes.normal;let p=0;for(let x=0;x<8;x++){const g=i[x],m=g[0],S=g[1];m!==Number.MAX_SAFE_INTEGER&&S?(d&&o.getAttribute("morphTarget"+x)!==d[m]&&o.setAttribute("morphTarget"+x,d[m]),f&&o.getAttribute("morphNormal"+x)!==f[m]&&o.setAttribute("morphNormal"+x,f[m]),e[x]=S,p+=S):(d&&o.hasAttribute("morphTarget"+x)===!0&&o.deleteAttribute("morphTarget"+x),f&&o.hasAttribute("morphNormal"+x)===!0&&o.deleteAttribute("morphNormal"+x),e[x]=0)}const _=o.morphTargetsRelative?1:1-p;l.getUniforms().setValue(n,"morphTargetBaseInfluence",_),l.getUniforms().setValue(n,"morphTargetInfluences",e)}return{update:r}}function l0(n,t,e,i){let r=new WeakMap;function s(l){const c=i.render.frame,h=l.geometry,u=t.get(l,h);return r.get(u)!==c&&(t.update(u),r.set(u,c)),l.isInstancedMesh&&(l.hasEventListener("dispose",a)===!1&&l.addEventListener("dispose",a),e.update(l.instanceMatrix,34962),l.instanceColor!==null&&e.update(l.instanceColor,34962)),u}function o(){r=new WeakMap}function a(l){const c=l.target;c.removeEventListener("dispose",a),e.remove(c.instanceMatrix),c.instanceColor!==null&&e.remove(c.instanceColor)}return{update:s,dispose:o}}class Tu extends le{constructor(t=null,e=1,i=1,r=1){super(null),this.image={data:t,width:e,height:i,depth:r},this.magFilter=pe,this.minFilter=pe,this.wrapR=Le,this.generateMipmaps=!1,this.flipY=!1,this.needsUpdate=!0}}Tu.prototype.isDataTexture2DArray=!0;class Eu extends le{constructor(t=null,e=1,i=1,r=1){super(null),this.image={data:t,width:e,height:i,depth:r},this.magFilter=pe,this.minFilter=pe,this.wrapR=Le,this.generateMipmaps=!1,this.flipY=!1,this.needsUpdate=!0}}Eu.prototype.isDataTexture3D=!0;const Au=new le,c0=new Tu,h0=new Eu,Lu=new Ks,yc=[],vc=[],bc=new Float32Array(16),wc=new Float32Array(9),Mc=new Float32Array(4);function Yi(n,t,e){const i=n[0];if(i<=0||i>0)return n;const r=t*e;let s=yc[r];if(s===void 0&&(s=new Float32Array(r),yc[r]=s),t!==0){i.toArray(s,0);for(let o=1,a=0;o!==t;++o)a+=e,n[o].toArray(s,a)}return s}function He(n,t){if(n.length!==t.length)return!1;for(let e=0,i=n.length;e<i;e++)if(n[e]!==t[e])return!1;return!0}function Pe(n,t){for(let e=0,i=t.length;e<i;e++)n[e]=t[e]}function Cu(n,t){let e=vc[t];e===void 0&&(e=new Int32Array(t),vc[t]=e);for(let i=0;i!==t;++i)e[i]=n.allocateTextureUnit();return e}function u0(n,t){const e=this.cache;e[0]!==t&&(n.uniform1f(this.addr,t),e[0]=t)}function d0(n,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y)&&(n.uniform2f(this.addr,t.x,t.y),e[0]=t.x,e[1]=t.y);else{if(He(e,t))return;n.uniform2fv(this.addr,t),Pe(e,t)}}function f0(n,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z)&&(n.uniform3f(this.addr,t.x,t.y,t.z),e[0]=t.x,e[1]=t.y,e[2]=t.z);else if(t.r!==void 0)(e[0]!==t.r||e[1]!==t.g||e[2]!==t.b)&&(n.uniform3f(this.addr,t.r,t.g,t.b),e[0]=t.r,e[1]=t.g,e[2]=t.b);else{if(He(e,t))return;n.uniform3fv(this.addr,t),Pe(e,t)}}function p0(n,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z||e[3]!==t.w)&&(n.uniform4f(this.addr,t.x,t.y,t.z,t.w),e[0]=t.x,e[1]=t.y,e[2]=t.z,e[3]=t.w);else{if(He(e,t))return;n.uniform4fv(this.addr,t),Pe(e,t)}}function m0(n,t){const e=this.cache,i=t.elements;if(i===void 0){if(He(e,t))return;n.uniformMatrix2fv(this.addr,!1,t),Pe(e,t)}else{if(He(e,i))return;Mc.set(i),n.uniformMatrix2fv(this.addr,!1,Mc),Pe(e,i)}}function g0(n,t){const e=this.cache,i=t.elements;if(i===void 0){if(He(e,t))return;n.uniformMatrix3fv(this.addr,!1,t),Pe(e,t)}else{if(He(e,i))return;wc.set(i),n.uniformMatrix3fv(this.addr,!1,wc),Pe(e,i)}}function _0(n,t){const e=this.cache,i=t.elements;if(i===void 0){if(He(e,t))return;n.uniformMatrix4fv(this.addr,!1,t),Pe(e,t)}else{if(He(e,i))return;bc.set(i),n.uniformMatrix4fv(this.addr,!1,bc),Pe(e,i)}}function x0(n,t,e){const i=this.cache,r=e.allocateTextureUnit();i[0]!==r&&(n.uniform1i(this.addr,r),i[0]=r),e.safeSetTexture2D(t||Au,r)}function y0(n,t,e){const i=this.cache,r=e.allocateTextureUnit();i[0]!==r&&(n.uniform1i(this.addr,r),i[0]=r),e.setTexture2DArray(t||c0,r)}function v0(n,t,e){const i=this.cache,r=e.allocateTextureUnit();i[0]!==r&&(n.uniform1i(this.addr,r),i[0]=r),e.setTexture3D(t||h0,r)}function b0(n,t,e){const i=this.cache,r=e.allocateTextureUnit();i[0]!==r&&(n.uniform1i(this.addr,r),i[0]=r),e.safeSetTextureCube(t||Lu,r)}function w0(n,t){const e=this.cache;e[0]!==t&&(n.uniform1i(this.addr,t),e[0]=t)}function M0(n,t){const e=this.cache;He(e,t)||(n.uniform2iv(this.addr,t),Pe(e,t))}function S0(n,t){const e=this.cache;He(e,t)||(n.uniform3iv(this.addr,t),Pe(e,t))}function T0(n,t){const e=this.cache;He(e,t)||(n.uniform4iv(this.addr,t),Pe(e,t))}function E0(n,t){const e=this.cache;e[0]!==t&&(n.uniform1ui(this.addr,t),e[0]=t)}function A0(n){switch(n){case 5126:return u0;case 35664:return d0;case 35665:return f0;case 35666:return p0;case 35674:return m0;case 35675:return g0;case 35676:return _0;case 5124:case 35670:return w0;case 35667:case 35671:return M0;case 35668:case 35672:return S0;case 35669:case 35673:return T0;case 5125:return E0;case 35678:case 36198:case 36298:case 36306:case 35682:return x0;case 35679:case 36299:case 36307:return v0;case 35680:case 36300:case 36308:case 36293:return b0;case 36289:case 36303:case 36311:case 36292:return y0}}function L0(n,t){n.uniform1fv(this.addr,t)}function C0(n,t){n.uniform1iv(this.addr,t)}function R0(n,t){n.uniform2iv(this.addr,t)}function P0(n,t){n.uniform3iv(this.addr,t)}function D0(n,t){n.uniform4iv(this.addr,t)}function I0(n,t){const e=Yi(t,this.size,2);n.uniform2fv(this.addr,e)}function F0(n,t){const e=Yi(t,this.size,3);n.uniform3fv(this.addr,e)}function N0(n,t){const e=Yi(t,this.size,4);n.uniform4fv(this.addr,e)}function O0(n,t){const e=Yi(t,this.size,4);n.uniformMatrix2fv(this.addr,!1,e)}function B0(n,t){const e=Yi(t,this.size,9);n.uniformMatrix3fv(this.addr,!1,e)}function z0(n,t){const e=Yi(t,this.size,16);n.uniformMatrix4fv(this.addr,!1,e)}function k0(n,t,e){const i=t.length,r=Cu(e,i);n.uniform1iv(this.addr,r);for(let s=0;s!==i;++s)e.safeSetTexture2D(t[s]||Au,r[s])}function U0(n,t,e){const i=t.length,r=Cu(e,i);n.uniform1iv(this.addr,r);for(let s=0;s!==i;++s)e.safeSetTextureCube(t[s]||Lu,r[s])}function H0(n){switch(n){case 5126:return L0;case 35664:return I0;case 35665:return F0;case 35666:return N0;case 35674:return O0;case 35675:return B0;case 35676:return z0;case 5124:case 35670:return C0;case 35667:case 35671:return R0;case 35668:case 35672:return P0;case 35669:case 35673:return D0;case 35678:case 36198:case 36298:case 36306:case 35682:return k0;case 35680:case 36300:case 36308:case 36293:return U0}}function G0(n,t,e){this.id=n,this.addr=e,this.cache=[],this.setValue=A0(t.type)}function Ru(n,t,e){this.id=n,this.addr=e,this.cache=[],this.size=t.size,this.setValue=H0(t.type)}Ru.prototype.updateCache=function(n){const t=this.cache;n instanceof Float32Array&&t.length!==n.length&&(this.cache=new Float32Array(n.length)),Pe(t,n)};function Pu(n){this.id=n,this.seq=[],this.map={}}Pu.prototype.setValue=function(n,t,e){const i=this.seq;for(let r=0,s=i.length;r!==s;++r){const o=i[r];o.setValue(n,t[o.id],e)}};const Ho=/(\w+)(\])?(\[|\.)?/g;function Sc(n,t){n.seq.push(t),n.map[t.id]=t}function V0(n,t,e){const i=n.name,r=i.length;for(Ho.lastIndex=0;;){const s=Ho.exec(i),o=Ho.lastIndex;let a=s[1];const l=s[2]==="]",c=s[3];if(l&&(a=a|0),c===void 0||c==="["&&o+2===r){Sc(e,c===void 0?new G0(a,n,t):new Ru(a,n,t));break}else{let u=e.map[a];u===void 0&&(u=new Pu(a),Sc(e,u)),e=u}}}function Dn(n,t){this.seq=[],this.map={};const e=n.getProgramParameter(t,35718);for(let i=0;i<e;++i){const r=n.getActiveUniform(t,i),s=n.getUniformLocation(t,r.name);V0(r,s,this)}}Dn.prototype.setValue=function(n,t,e,i){const r=this.map[t];r!==void 0&&r.setValue(n,e,i)};Dn.prototype.setOptional=function(n,t,e){const i=t[e];i!==void 0&&this.setValue(n,e,i)};Dn.upload=function(n,t,e,i){for(let r=0,s=t.length;r!==s;++r){const o=t[r],a=e[o.id];a.needsUpdate!==!1&&o.setValue(n,a.value,i)}};Dn.seqWithValue=function(n,t){const e=[];for(let i=0,r=n.length;i!==r;++i){const s=n[i];s.id in t&&e.push(s)}return e};function Tc(n,t,e){const i=n.createShader(t);return n.shaderSource(i,e),n.compileShader(i),i}let W0=0;function q0(n){const t=n.split(`
`);for(let e=0;e<t.length;e++)t[e]=e+1+": "+t[e];return t.join(`
`)}function Du(n){switch(n){case Wr:return["Linear","( value )"];case xu:return["sRGB","( value )"];case em:return["RGBE","( value )"];case im:return["RGBM","( value, 7.0 )"];case rm:return["RGBM","( value, 16.0 )"];case sm:return["RGBD","( value, 256.0 )"];case tm:return["Gamma","( value, float( GAMMA_FACTOR ) )"];case nm:return["LogLuv","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",n),["Linear","( value )"]}}function Ec(n,t,e){const i=n.getShaderParameter(t,35713),r=n.getShaderInfoLog(t).trim();if(i&&r==="")return"";const s=n.getShaderSource(t);return"THREE.WebGLShader: gl.getShaderInfoLog() "+e+`
`+r+q0(s)}function sr(n,t){const e=Du(t);return"vec4 "+n+"( vec4 value ) { return "+e[0]+"ToLinear"+e[1]+"; }"}function j0(n,t){const e=Du(t);return"vec4 "+n+"( vec4 value ) { return LinearTo"+e[0]+e[1]+"; }"}function X0(n,t){let e;switch(t){case Kf:e="Linear";break;case tp:e="Reinhard";break;case ep:e="OptimizedCineon";break;case np:e="ACESFilmic";break;case ip:e="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",t),e="Linear"}return"vec3 "+n+"( vec3 color ) { return "+e+"ToneMapping( color ); }"}function Y0(n){return[n.extensionDerivatives||n.envMapCubeUV||n.bumpMap||n.tangentSpaceNormalMap||n.clearcoatNormalMap||n.flatShading||n.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(n.extensionFragDepth||n.logarithmicDepthBuffer)&&n.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",n.extensionDrawBuffers&&n.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(n.extensionShaderTextureLOD||n.envMap)&&n.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(pr).join(`
`)}function Z0(n){const t=[];for(const e in n){const i=n[e];i!==!1&&t.push("#define "+e+" "+i)}return t.join(`
`)}function J0(n,t){const e={},i=n.getProgramParameter(t,35721);for(let r=0;r<i;r++){const o=n.getActiveAttrib(t,r).name;e[o]=n.getAttribLocation(t,o)}return e}function pr(n){return n!==""}function Ac(n,t){return n.replace(/NUM_DIR_LIGHTS/g,t.numDirLights).replace(/NUM_SPOT_LIGHTS/g,t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,t.numPointLights).replace(/NUM_HEMI_LIGHTS/g,t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,t.numPointLightShadows)}function Lc(n,t){return n.replace(/NUM_CLIPPING_PLANES/g,t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,t.numClippingPlanes-t.numClipIntersection)}const Q0=/^[ \t]*#include +<([\w\d./]+)>/gm;function xa(n){return n.replace(Q0,$0)}function $0(n,t){const e=St[t];if(e===void 0)throw new Error("Can not resolve #include <"+t+">");return xa(e)}const K0=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,tx=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function Cc(n){return n.replace(tx,Iu).replace(K0,ex)}function ex(n,t,e,i){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),Iu(n,t,e,i)}function Iu(n,t,e,i){let r="";for(let s=parseInt(t);s<parseInt(e);s++)r+=i.replace(/\[\s*i\s*\]/g,"[ "+s+" ]").replace(/UNROLLED_LOOP_INDEX/g,s);return r}function Rc(n){let t="precision "+n.precision+` float;
precision `+n.precision+" int;";return n.precision==="highp"?t+=`
#define HIGH_PRECISION`:n.precision==="mediump"?t+=`
#define MEDIUM_PRECISION`:n.precision==="lowp"&&(t+=`
#define LOW_PRECISION`),t}function nx(n){let t="SHADOWMAP_TYPE_BASIC";return n.shadowMapType===fu?t="SHADOWMAP_TYPE_PCF":n.shadowMapType===Pf?t="SHADOWMAP_TYPE_PCF_SOFT":n.shadowMapType===fr&&(t="SHADOWMAP_TYPE_VSM"),t}function ix(n){let t="ENVMAP_TYPE_CUBE";if(n.envMap)switch(n.envMapMode){case Qa:case $a:t="ENVMAP_TYPE_CUBE";break;case Ka:case tl:t="ENVMAP_TYPE_CUBE_UV";break}return t}function rx(n){let t="ENVMAP_MODE_REFLECTION";if(n.envMap)switch(n.envMapMode){case $a:case tl:t="ENVMAP_MODE_REFRACTION";break}return t}function sx(n){let t="ENVMAP_BLENDING_NONE";if(n.envMap)switch(n.combine){case Js:t="ENVMAP_BLENDING_MULTIPLY";break;case Qf:t="ENVMAP_BLENDING_MIX";break;case $f:t="ENVMAP_BLENDING_ADD";break}return t}function ox(n,t,e,i){const r=n.getContext(),s=e.defines;let o=e.vertexShader,a=e.fragmentShader;const l=nx(e),c=ix(e),h=rx(e),u=sx(e),d=n.gammaFactor>0?n.gammaFactor:1,f=e.isWebGL2?"":Y0(e),p=Z0(s),_=r.createProgram();let x,g,m=e.glslVersion?"#version "+e.glslVersion+`
`:"";e.isRawShaderMaterial?(x=[p].filter(pr).join(`
`),x.length>0&&(x+=`
`),g=[f,p].filter(pr).join(`
`),g.length>0&&(g+=`
`)):(x=[Rc(e),"#define SHADER_NAME "+e.shaderName,p,e.instancing?"#define USE_INSTANCING":"",e.instancingColor?"#define USE_INSTANCING_COLOR":"",e.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+d,"#define MAX_BONES "+e.maxBones,e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.map?"#define USE_MAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+h:"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMap&&e.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",e.normalMap&&e.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.displacementMap&&e.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.vertexTangents?"#define USE_TANGENT":"",e.vertexColors?"#define USE_COLOR":"",e.vertexUvs?"#define USE_UV":"",e.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",e.flatShading?"#define FLAT_SHADED":"",e.skinning?"#define USE_SKINNING":"",e.useVertexTexture?"#define BONE_TEXTURE":"",e.morphTargets?"#define USE_MORPHTARGETS":"",e.morphNormals&&e.flatShading===!1?"#define USE_MORPHNORMALS":"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+l:"",e.sizeAttenuation?"#define USE_SIZEATTENUATION":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.logarithmicDepthBuffer&&e.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#ifdef USE_COLOR","	attribute vec3 color;","#endif","#ifdef USE_MORPHTARGETS","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(pr).join(`
`),g=[f,Rc(e),"#define SHADER_NAME "+e.shaderName,p,e.alphaTest?"#define ALPHATEST "+e.alphaTest+(e.alphaTest%1?"":".0"):"","#define GAMMA_FACTOR "+d,e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.map?"#define USE_MAP":"",e.matcap?"#define USE_MATCAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+c:"",e.envMap?"#define "+h:"",e.envMap?"#define "+u:"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMap&&e.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",e.normalMap&&e.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.sheen?"#define USE_SHEEN":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.vertexTangents?"#define USE_TANGENT":"",e.vertexColors||e.instancingColor?"#define USE_COLOR":"",e.vertexUvs?"#define USE_UV":"",e.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",e.gradientMap?"#define USE_GRADIENTMAP":"",e.flatShading?"#define FLAT_SHADED":"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+l:"",e.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",e.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.logarithmicDepthBuffer&&e.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(e.extensionShaderTextureLOD||e.envMap)&&e.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",e.toneMapping!==br?"#define TONE_MAPPING":"",e.toneMapping!==br?St.tonemapping_pars_fragment:"",e.toneMapping!==br?X0("toneMapping",e.toneMapping):"",e.dithering?"#define DITHERING":"",St.encodings_pars_fragment,e.map?sr("mapTexelToLinear",e.mapEncoding):"",e.matcap?sr("matcapTexelToLinear",e.matcapEncoding):"",e.envMap?sr("envMapTexelToLinear",e.envMapEncoding):"",e.emissiveMap?sr("emissiveMapTexelToLinear",e.emissiveMapEncoding):"",e.lightMap?sr("lightMapTexelToLinear",e.lightMapEncoding):"",j0("linearToOutputTexel",e.outputEncoding),e.depthPacking?"#define DEPTH_PACKING "+e.depthPacking:"",`
`].filter(pr).join(`
`)),o=xa(o),o=Ac(o,e),o=Lc(o,e),a=xa(a),a=Ac(a,e),a=Lc(a,e),o=Cc(o),a=Cc(a),e.isWebGL2&&e.isRawShaderMaterial!==!0&&(m=`#version 300 es
`,x=["#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+x,g=["#define varying in",e.glslVersion===lc?"":"out highp vec4 pc_fragColor;",e.glslVersion===lc?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+g);const S=m+x+o,M=m+g+a,v=Tc(r,35633,S),y=Tc(r,35632,M);if(r.attachShader(_,v),r.attachShader(_,y),e.index0AttributeName!==void 0?r.bindAttribLocation(_,0,e.index0AttributeName):e.morphTargets===!0&&r.bindAttribLocation(_,0,"position"),r.linkProgram(_),n.debug.checkShaderErrors){const L=r.getProgramInfoLog(_).trim(),F=r.getShaderInfoLog(v).trim(),N=r.getShaderInfoLog(y).trim();let k=!0,I=!0;if(r.getProgramParameter(_,35714)===!1){k=!1;const C=Ec(r,v,"vertex"),P=Ec(r,y,"fragment");console.error("THREE.WebGLProgram: shader error: ",r.getError(),"35715",r.getProgramParameter(_,35715),"gl.getProgramInfoLog",L,C,P)}else L!==""?console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()",L):(F===""||N==="")&&(I=!1);I&&(this.diagnostics={runnable:k,programLog:L,vertexShader:{log:F,prefix:x},fragmentShader:{log:N,prefix:g}})}r.deleteShader(v),r.deleteShader(y);let T;this.getUniforms=function(){return T===void 0&&(T=new Dn(r,_)),T};let D;return this.getAttributes=function(){return D===void 0&&(D=J0(r,_)),D},this.destroy=function(){i.releaseStatesOfProgram(this),r.deleteProgram(_),this.program=void 0},this.name=e.shaderName,this.id=W0++,this.cacheKey=t,this.usedTimes=1,this.program=_,this.vertexShader=v,this.fragmentShader=y,this}function ax(n,t,e,i,r,s){const o=[],a=i.isWebGL2,l=i.logarithmicDepthBuffer,c=i.floatVertexTextures,h=i.maxVertexUniforms,u=i.vertexTextures;let d=i.precision;const f={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},p=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","instancingColor","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap","roughnessMap","metalnessMap","gradientMap","alphaMap","combine","vertexColors","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","maxMorphTargets","maxMorphNormals","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","alphaTest","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","sheen","transmissionMap"];function _(y){const D=y.skeleton.bones;if(c)return 1024;{const F=Math.floor((h-20)/4),N=Math.min(F,D.length);return N<D.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+D.length+" bones. This GPU supports "+N+"."),0):N}}function x(y){let T;return y&&y.isTexture?T=y.encoding:y&&y.isWebGLRenderTarget?(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),T=y.texture.encoding):T=Wr,T}function g(y,T,D,L,F){const N=L.fog,k=y.isMeshStandardMaterial?L.environment:null,I=t.get(y.envMap||k),C=f[y.type],P=F.isSkinnedMesh?_(F):0;y.precision!==null&&(d=i.getMaxPrecision(y.precision),d!==y.precision&&console.warn("THREE.WebGLProgram.getParameters:",y.precision,"not supported, using",d,"instead."));let O,G;if(C){const it=tn[C];O=it.vertexShader,G=it.fragmentShader}else O=y.vertexShader,G=y.fragmentShader;const Y=n.getRenderTarget();return{isWebGL2:a,shaderID:C,shaderName:y.type,vertexShader:O,fragmentShader:G,defines:y.defines,isRawShaderMaterial:y.isRawShaderMaterial===!0,glslVersion:y.glslVersion,precision:d,instancing:F.isInstancedMesh===!0,instancingColor:F.isInstancedMesh===!0&&F.instanceColor!==null,supportsVertexTextures:u,outputEncoding:Y!==null?x(Y.texture):n.outputEncoding,map:!!y.map,mapEncoding:x(y.map),matcap:!!y.matcap,matcapEncoding:x(y.matcap),envMap:!!I,envMapMode:I&&I.mapping,envMapEncoding:x(I),envMapCubeUV:!!I&&(I.mapping===Ka||I.mapping===tl),lightMap:!!y.lightMap,lightMapEncoding:x(y.lightMap),aoMap:!!y.aoMap,emissiveMap:!!y.emissiveMap,emissiveMapEncoding:x(y.emissiveMap),bumpMap:!!y.bumpMap,normalMap:!!y.normalMap,objectSpaceNormalMap:y.normalMapType===lm,tangentSpaceNormalMap:y.normalMapType===Wi,clearcoatMap:!!y.clearcoatMap,clearcoatRoughnessMap:!!y.clearcoatRoughnessMap,clearcoatNormalMap:!!y.clearcoatNormalMap,displacementMap:!!y.displacementMap,roughnessMap:!!y.roughnessMap,metalnessMap:!!y.metalnessMap,specularMap:!!y.specularMap,alphaMap:!!y.alphaMap,gradientMap:!!y.gradientMap,sheen:!!y.sheen,transmissionMap:!!y.transmissionMap,combine:y.combine,vertexTangents:y.normalMap&&y.vertexTangents,vertexColors:y.vertexColors,vertexUvs:!!y.map||!!y.bumpMap||!!y.normalMap||!!y.specularMap||!!y.alphaMap||!!y.emissiveMap||!!y.roughnessMap||!!y.metalnessMap||!!y.clearcoatMap||!!y.clearcoatRoughnessMap||!!y.clearcoatNormalMap||!!y.displacementMap||!!y.transmissionMap,uvsVertexOnly:!(!!y.map||!!y.bumpMap||!!y.normalMap||!!y.specularMap||!!y.alphaMap||!!y.emissiveMap||!!y.roughnessMap||!!y.metalnessMap||!!y.clearcoatNormalMap||!!y.transmissionMap)&&!!y.displacementMap,fog:!!N,useFog:y.fog,fogExp2:N&&N.isFogExp2,flatShading:!!y.flatShading,sizeAttenuation:y.sizeAttenuation,logarithmicDepthBuffer:l,skinning:y.skinning&&P>0,maxBones:P,useVertexTexture:c,morphTargets:y.morphTargets,morphNormals:y.morphNormals,maxMorphTargets:n.maxMorphTargets,maxMorphNormals:n.maxMorphNormals,numDirLights:T.directional.length,numPointLights:T.point.length,numSpotLights:T.spot.length,numRectAreaLights:T.rectArea.length,numHemiLights:T.hemi.length,numDirLightShadows:T.directionalShadowMap.length,numPointLightShadows:T.pointShadowMap.length,numSpotLightShadows:T.spotShadowMap.length,numClippingPlanes:s.numPlanes,numClipIntersection:s.numIntersection,dithering:y.dithering,shadowMapEnabled:n.shadowMap.enabled&&D.length>0,shadowMapType:n.shadowMap.type,toneMapping:y.toneMapped?n.toneMapping:br,physicallyCorrectLights:n.physicallyCorrectLights,premultipliedAlpha:y.premultipliedAlpha,alphaTest:y.alphaTest,doubleSided:y.side===Vr,flipSided:y.side===Kt,depthPacking:y.depthPacking!==void 0?y.depthPacking:!1,index0AttributeName:y.index0AttributeName,extensionDerivatives:y.extensions&&y.extensions.derivatives,extensionFragDepth:y.extensions&&y.extensions.fragDepth,extensionDrawBuffers:y.extensions&&y.extensions.drawBuffers,extensionShaderTextureLOD:y.extensions&&y.extensions.shaderTextureLOD,rendererExtensionFragDepth:a||e.has("EXT_frag_depth"),rendererExtensionDrawBuffers:a||e.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:a||e.has("EXT_shader_texture_lod"),customProgramCacheKey:y.customProgramCacheKey()}}function m(y){const T=[];if(y.shaderID?T.push(y.shaderID):(T.push(y.fragmentShader),T.push(y.vertexShader)),y.defines!==void 0)for(const D in y.defines)T.push(D),T.push(y.defines[D]);if(y.isRawShaderMaterial===!1){for(let D=0;D<p.length;D++)T.push(y[p[D]]);T.push(n.outputEncoding),T.push(n.gammaFactor)}return T.push(y.customProgramCacheKey),T.join()}function S(y){const T=f[y.type];let D;if(T){const L=tn[T];D=Sm.clone(L.uniforms)}else D=y.uniforms;return D}function M(y,T){let D;for(let L=0,F=o.length;L<F;L++){const N=o[L];if(N.cacheKey===T){D=N,++D.usedTimes;break}}return D===void 0&&(D=new ox(n,T,y,r),o.push(D)),D}function v(y){if(--y.usedTimes===0){const T=o.indexOf(y);o[T]=o[o.length-1],o.pop(),y.destroy()}}return{getParameters:g,getProgramCacheKey:m,getUniforms:S,acquireProgram:M,releaseProgram:v,programs:o}}function lx(){let n=new WeakMap;function t(s){let o=n.get(s);return o===void 0&&(o={},n.set(s,o)),o}function e(s){n.delete(s)}function i(s,o,a){n.get(s)[o]=a}function r(){n=new WeakMap}return{get:t,remove:e,update:i,dispose:r}}function cx(n,t){return n.groupOrder!==t.groupOrder?n.groupOrder-t.groupOrder:n.renderOrder!==t.renderOrder?n.renderOrder-t.renderOrder:n.program!==t.program?n.program.id-t.program.id:n.material.id!==t.material.id?n.material.id-t.material.id:n.z!==t.z?n.z-t.z:n.id-t.id}function hx(n,t){return n.groupOrder!==t.groupOrder?n.groupOrder-t.groupOrder:n.renderOrder!==t.renderOrder?n.renderOrder-t.renderOrder:n.z!==t.z?t.z-n.z:n.id-t.id}function Pc(n){const t=[];let e=0;const i=[],r=[],s={id:-1};function o(){e=0,i.length=0,r.length=0}function a(d,f,p,_,x,g){let m=t[e];const S=n.get(p);return m===void 0?(m={id:d.id,object:d,geometry:f,material:p,program:S.program||s,groupOrder:_,renderOrder:d.renderOrder,z:x,group:g},t[e]=m):(m.id=d.id,m.object=d,m.geometry=f,m.material=p,m.program=S.program||s,m.groupOrder=_,m.renderOrder=d.renderOrder,m.z=x,m.group=g),e++,m}function l(d,f,p,_,x,g){const m=a(d,f,p,_,x,g);(p.transparent===!0?r:i).push(m)}function c(d,f,p,_,x,g){const m=a(d,f,p,_,x,g);(p.transparent===!0?r:i).unshift(m)}function h(d,f){i.length>1&&i.sort(d||cx),r.length>1&&r.sort(f||hx)}function u(){for(let d=e,f=t.length;d<f;d++){const p=t[d];if(p.id===null)break;p.id=null,p.object=null,p.geometry=null,p.material=null,p.program=null,p.group=null}}return{opaque:i,transparent:r,init:o,push:l,unshift:c,finish:u,sort:h}}function ux(n){let t=new WeakMap;function e(r,s){let o;return t.has(r)===!1?(o=new Pc(n),t.set(r,[o])):s>=t.get(r).length?(o=new Pc(n),t.get(r).push(o)):o=t.get(r)[s],o}function i(){t=new WeakMap}return{get:e,dispose:i}}function dx(){const n={};return{get:function(t){if(n[t.id]!==void 0)return n[t.id];let e;switch(t.type){case"DirectionalLight":e={direction:new A,color:new pt};break;case"SpotLight":e={position:new A,direction:new A,color:new pt,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":e={position:new A,color:new pt,distance:0,decay:0};break;case"HemisphereLight":e={direction:new A,skyColor:new pt,groundColor:new pt};break;case"RectAreaLight":e={color:new pt,position:new A,halfWidth:new A,halfHeight:new A};break}return n[t.id]=e,e}}}function fx(){const n={};return{get:function(t){if(n[t.id]!==void 0)return n[t.id];let e;switch(t.type){case"DirectionalLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new J};break;case"SpotLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new J};break;case"PointLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new J,shadowCameraNear:1,shadowCameraFar:1e3};break}return n[t.id]=e,e}}}let px=0;function mx(n,t){return(t.castShadow?1:0)-(n.castShadow?1:0)}function gx(n,t){const e=new dx,i=fx(),r={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let h=0;h<9;h++)r.probe.push(new A);const s=new A,o=new dt,a=new dt;function l(h){let u=0,d=0,f=0;for(let T=0;T<9;T++)r.probe[T].set(0,0,0);let p=0,_=0,x=0,g=0,m=0,S=0,M=0,v=0;h.sort(mx);for(let T=0,D=h.length;T<D;T++){const L=h[T],F=L.color,N=L.intensity,k=L.distance,I=L.shadow&&L.shadow.map?L.shadow.map.texture:null;if(L.isAmbientLight)u+=F.r*N,d+=F.g*N,f+=F.b*N;else if(L.isLightProbe)for(let C=0;C<9;C++)r.probe[C].addScaledVector(L.sh.coefficients[C],N);else if(L.isDirectionalLight){const C=e.get(L);if(C.color.copy(L.color).multiplyScalar(L.intensity),L.castShadow){const P=L.shadow,O=i.get(L);O.shadowBias=P.bias,O.shadowNormalBias=P.normalBias,O.shadowRadius=P.radius,O.shadowMapSize=P.mapSize,r.directionalShadow[p]=O,r.directionalShadowMap[p]=I,r.directionalShadowMatrix[p]=L.shadow.matrix,S++}r.directional[p]=C,p++}else if(L.isSpotLight){const C=e.get(L);if(C.position.setFromMatrixPosition(L.matrixWorld),C.color.copy(F).multiplyScalar(N),C.distance=k,C.coneCos=Math.cos(L.angle),C.penumbraCos=Math.cos(L.angle*(1-L.penumbra)),C.decay=L.decay,L.castShadow){const P=L.shadow,O=i.get(L);O.shadowBias=P.bias,O.shadowNormalBias=P.normalBias,O.shadowRadius=P.radius,O.shadowMapSize=P.mapSize,r.spotShadow[x]=O,r.spotShadowMap[x]=I,r.spotShadowMatrix[x]=L.shadow.matrix,v++}r.spot[x]=C,x++}else if(L.isRectAreaLight){const C=e.get(L);C.color.copy(F).multiplyScalar(N),C.halfWidth.set(L.width*.5,0,0),C.halfHeight.set(0,L.height*.5,0),r.rectArea[g]=C,g++}else if(L.isPointLight){const C=e.get(L);if(C.color.copy(L.color).multiplyScalar(L.intensity),C.distance=L.distance,C.decay=L.decay,L.castShadow){const P=L.shadow,O=i.get(L);O.shadowBias=P.bias,O.shadowNormalBias=P.normalBias,O.shadowRadius=P.radius,O.shadowMapSize=P.mapSize,O.shadowCameraNear=P.camera.near,O.shadowCameraFar=P.camera.far,r.pointShadow[_]=O,r.pointShadowMap[_]=I,r.pointShadowMatrix[_]=L.shadow.matrix,M++}r.point[_]=C,_++}else if(L.isHemisphereLight){const C=e.get(L);C.skyColor.copy(L.color).multiplyScalar(N),C.groundColor.copy(L.groundColor).multiplyScalar(N),r.hemi[m]=C,m++}}g>0&&(t.isWebGL2||n.has("OES_texture_float_linear")===!0?(r.rectAreaLTC1=tt.LTC_FLOAT_1,r.rectAreaLTC2=tt.LTC_FLOAT_2):n.has("OES_texture_half_float_linear")===!0?(r.rectAreaLTC1=tt.LTC_HALF_1,r.rectAreaLTC2=tt.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),r.ambient[0]=u,r.ambient[1]=d,r.ambient[2]=f;const y=r.hash;(y.directionalLength!==p||y.pointLength!==_||y.spotLength!==x||y.rectAreaLength!==g||y.hemiLength!==m||y.numDirectionalShadows!==S||y.numPointShadows!==M||y.numSpotShadows!==v)&&(r.directional.length=p,r.spot.length=x,r.rectArea.length=g,r.point.length=_,r.hemi.length=m,r.directionalShadow.length=S,r.directionalShadowMap.length=S,r.pointShadow.length=M,r.pointShadowMap.length=M,r.spotShadow.length=v,r.spotShadowMap.length=v,r.directionalShadowMatrix.length=S,r.pointShadowMatrix.length=M,r.spotShadowMatrix.length=v,y.directionalLength=p,y.pointLength=_,y.spotLength=x,y.rectAreaLength=g,y.hemiLength=m,y.numDirectionalShadows=S,y.numPointShadows=M,y.numSpotShadows=v,r.version=px++)}function c(h,u){let d=0,f=0,p=0,_=0,x=0;const g=u.matrixWorldInverse;for(let m=0,S=h.length;m<S;m++){const M=h[m];if(M.isDirectionalLight){const v=r.directional[d];v.direction.setFromMatrixPosition(M.matrixWorld),s.setFromMatrixPosition(M.target.matrixWorld),v.direction.sub(s),v.direction.transformDirection(g),d++}else if(M.isSpotLight){const v=r.spot[p];v.position.setFromMatrixPosition(M.matrixWorld),v.position.applyMatrix4(g),v.direction.setFromMatrixPosition(M.matrixWorld),s.setFromMatrixPosition(M.target.matrixWorld),v.direction.sub(s),v.direction.transformDirection(g),p++}else if(M.isRectAreaLight){const v=r.rectArea[_];v.position.setFromMatrixPosition(M.matrixWorld),v.position.applyMatrix4(g),a.identity(),o.copy(M.matrixWorld),o.premultiply(g),a.extractRotation(o),v.halfWidth.set(M.width*.5,0,0),v.halfHeight.set(0,M.height*.5,0),v.halfWidth.applyMatrix4(a),v.halfHeight.applyMatrix4(a),_++}else if(M.isPointLight){const v=r.point[f];v.position.setFromMatrixPosition(M.matrixWorld),v.position.applyMatrix4(g),f++}else if(M.isHemisphereLight){const v=r.hemi[x];v.direction.setFromMatrixPosition(M.matrixWorld),v.direction.transformDirection(g),v.direction.normalize(),x++}}}return{setup:l,setupView:c,state:r}}function Dc(n,t){const e=new gx(n,t),i=[],r=[];function s(){i.length=0,r.length=0}function o(u){i.push(u)}function a(u){r.push(u)}function l(){e.setup(i)}function c(u){e.setupView(i,u)}return{init:s,state:{lightsArray:i,shadowsArray:r,lights:e},setupLights:l,setupLightsView:c,pushLight:o,pushShadow:a}}function _x(n,t){let e=new WeakMap;function i(s,o=0){let a;return e.has(s)===!1?(a=new Dc(n,t),e.set(s,[a])):o>=e.get(s).length?(a=new Dc(n,t),e.get(s).push(a)):a=e.get(s)[o],a}function r(){e=new WeakMap}return{get:i,dispose:r}}class Fu extends Xt{constructor(t){super(),this.type="MeshDepthMaterial",this.depthPacking=om,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(t)}copy(t){return super.copy(t),this.depthPacking=t.depthPacking,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this}}Fu.prototype.isMeshDepthMaterial=!0;class Nu extends Xt{constructor(t){super(),this.type="MeshDistanceMaterial",this.referencePosition=new A,this.nearDistance=1,this.farDistance=1e3,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(t)}copy(t){return super.copy(t),this.referencePosition.copy(t.referencePosition),this.nearDistance=t.nearDistance,this.farDistance=t.farDistance,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this}}Nu.prototype.isMeshDistanceMaterial=!0;var xx=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	float mean = 0.0;
	float squared_mean = 0.0;
	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );
	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean * HALF_SAMPLE_RATE;
	squared_mean = squared_mean * HALF_SAMPLE_RATE;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`,yx=`void main() {
	gl_Position = vec4( position, 1.0 );
}`;function Ou(n,t,e){let i=new to;const r=new J,s=new J,o=new Ft,a=[],l=[],c={},h={0:Kt,1:Zs,2:Vr},u=new Ue({defines:{SAMPLE_RATE:2/8,HALF_SAMPLE_RATE:1/8},uniforms:{shadow_pass:{value:null},resolution:{value:new J},radius:{value:4}},vertexShader:yx,fragmentShader:xx}),d=u.clone();d.defines.HORIZONTAL_PASS=1;const f=new Dt;f.setAttribute("position",new Mt(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const p=new ne(f,u),_=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=fu,this.render=function(v,y,T){if(_.enabled===!1||_.autoUpdate===!1&&_.needsUpdate===!1||v.length===0)return;const D=n.getRenderTarget(),L=n.getActiveCubeFace(),F=n.getActiveMipmapLevel(),N=n.state;N.setBlending(yr),N.buffers.color.setClear(1,1,1,1),N.buffers.depth.setTest(!0),N.setScissorTest(!1);for(let k=0,I=v.length;k<I;k++){const C=v[k],P=C.shadow;if(P===void 0){console.warn("THREE.WebGLShadowMap:",C,"has no shadow.");continue}if(P.autoUpdate===!1&&P.needsUpdate===!1)continue;r.copy(P.mapSize);const O=P.getFrameExtents();if(r.multiply(O),s.copy(P.mapSize),(r.x>e||r.y>e)&&(r.x>e&&(s.x=Math.floor(e/O.x),r.x=s.x*O.x,P.mapSize.x=s.x),r.y>e&&(s.y=Math.floor(e/O.y),r.y=s.y*O.y,P.mapSize.y=s.y)),P.map===null&&!P.isPointLightShadow&&this.type===fr){const Y={minFilter:oe,magFilter:oe,format:Ye};P.map=new ti(r.x,r.y,Y),P.map.texture.name=C.name+".shadowMap",P.mapPass=new ti(r.x,r.y,Y),P.camera.updateProjectionMatrix()}if(P.map===null){const Y={minFilter:pe,magFilter:pe,format:Ye};P.map=new ti(r.x,r.y,Y),P.map.texture.name=C.name+".shadowMap",P.camera.updateProjectionMatrix()}n.setRenderTarget(P.map),n.clear();const G=P.getViewportCount();for(let Y=0;Y<G;Y++){const Q=P.getViewport(Y);o.set(s.x*Q.x,s.y*Q.y,s.x*Q.z,s.y*Q.w),N.viewport(o),P.updateMatrices(C,Y),i=P.getFrustum(),M(y,T,P.camera,C,this.type)}!P.isPointLightShadow&&this.type===fr&&x(P,T),P.needsUpdate=!1}_.needsUpdate=!1,n.setRenderTarget(D,L,F)};function x(v,y){const T=t.update(p);u.uniforms.shadow_pass.value=v.map.texture,u.uniforms.resolution.value=v.mapSize,u.uniforms.radius.value=v.radius,n.setRenderTarget(v.mapPass),n.clear(),n.renderBufferDirect(y,null,T,u,p,null),d.uniforms.shadow_pass.value=v.mapPass.texture,d.uniforms.resolution.value=v.mapSize,d.uniforms.radius.value=v.radius,n.setRenderTarget(v.map),n.clear(),n.renderBufferDirect(y,null,T,d,p,null)}function g(v,y,T){const D=v<<0|y<<1|T<<2;let L=a[D];return L===void 0&&(L=new Fu({depthPacking:am,morphTargets:v,skinning:y}),a[D]=L),L}function m(v,y,T){const D=v<<0|y<<1|T<<2;let L=l[D];return L===void 0&&(L=new Nu({morphTargets:v,skinning:y}),l[D]=L),L}function S(v,y,T,D,L,F,N){let k=null,I=g,C=v.customDepthMaterial;if(D.isPointLight===!0&&(I=m,C=v.customDistanceMaterial),C===void 0){let P=!1;T.morphTargets===!0&&(P=y.morphAttributes&&y.morphAttributes.position&&y.morphAttributes.position.length>0);let O=!1;v.isSkinnedMesh===!0&&(T.skinning===!0?O=!0:console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",v));const G=v.isInstancedMesh===!0;k=I(P,O,G)}else k=C;if(n.localClippingEnabled&&T.clipShadows===!0&&T.clippingPlanes.length!==0){const P=k.uuid,O=T.uuid;let G=c[P];G===void 0&&(G={},c[P]=G);let Y=G[O];Y===void 0&&(Y=k.clone(),G[O]=Y),k=Y}return k.visible=T.visible,k.wireframe=T.wireframe,N===fr?k.side=T.shadowSide!==null?T.shadowSide:T.side:k.side=T.shadowSide!==null?T.shadowSide:h[T.side],k.clipShadows=T.clipShadows,k.clippingPlanes=T.clippingPlanes,k.clipIntersection=T.clipIntersection,k.wireframeLinewidth=T.wireframeLinewidth,k.linewidth=T.linewidth,D.isPointLight===!0&&k.isMeshDistanceMaterial===!0&&(k.referencePosition.setFromMatrixPosition(D.matrixWorld),k.nearDistance=L,k.farDistance=F),k}function M(v,y,T,D,L){if(v.visible===!1)return;if(v.layers.test(y.layers)&&(v.isMesh||v.isLine||v.isPoints)&&(v.castShadow||v.receiveShadow&&L===fr)&&(!v.frustumCulled||i.intersectsObject(v))){v.modelViewMatrix.multiplyMatrices(T.matrixWorldInverse,v.matrixWorld);const k=t.update(v),I=v.material;if(Array.isArray(I)){const C=k.groups;for(let P=0,O=C.length;P<O;P++){const G=C[P],Y=I[G.materialIndex];if(Y&&Y.visible){const Q=S(v,k,Y,D,T.near,T.far,L);n.renderBufferDirect(T,null,k,Q,v,G)}}}else if(I.visible){const C=S(v,k,I,D,T.near,T.far,L);n.renderBufferDirect(T,null,k,C,v,null)}}const N=v.children;for(let k=0,I=N.length;k<I;k++)M(N[k],y,T,D,L)}}function vx(n,t,e){const i=e.isWebGL2;function r(){let R=!1;const X=new Ft;let nt=null;const st=new Ft(0,0,0,0);return{setMask:function(j){nt!==j&&!R&&(n.colorMask(j,j,j,j),nt=j)},setLocked:function(j){R=j},setClear:function(j,ut,ft,at,ct){ct===!0&&(j*=at,ut*=at,ft*=at),X.set(j,ut,ft,at),st.equals(X)===!1&&(n.clearColor(j,ut,ft,at),st.copy(X))},reset:function(){R=!1,nt=null,st.set(-1,0,0,0)}}}function s(){let R=!1,X=null,nt=null,st=null;return{setTest:function(j){j?it(2929):et(2929)},setMask:function(j){X!==j&&!R&&(n.depthMask(j),X=j)},setFunc:function(j){if(nt!==j){if(j)switch(j){case Wf:n.depthFunc(512);break;case qf:n.depthFunc(519);break;case jf:n.depthFunc(513);break;case ca:n.depthFunc(515);break;case Xf:n.depthFunc(514);break;case Yf:n.depthFunc(518);break;case Zf:n.depthFunc(516);break;case Jf:n.depthFunc(517);break;default:n.depthFunc(515)}else n.depthFunc(515);nt=j}},setLocked:function(j){R=j},setClear:function(j){st!==j&&(n.clearDepth(j),st=j)},reset:function(){R=!1,X=null,nt=null,st=null}}}function o(){let R=!1,X=null,nt=null,st=null,j=null,ut=null,ft=null,at=null,ct=null;return{setTest:function(ht){R||(ht?it(2960):et(2960))},setMask:function(ht){X!==ht&&!R&&(n.stencilMask(ht),X=ht)},setFunc:function(ht,Wt,_e){(nt!==ht||st!==Wt||j!==_e)&&(n.stencilFunc(ht,Wt,_e),nt=ht,st=Wt,j=_e)},setOp:function(ht,Wt,_e){(ut!==ht||ft!==Wt||at!==_e)&&(n.stencilOp(ht,Wt,_e),ut=ht,ft=Wt,at=_e)},setLocked:function(ht){R=ht},setClear:function(ht){ct!==ht&&(n.clearStencil(ht),ct=ht)},reset:function(){R=!1,X=null,nt=null,st=null,j=null,ut=null,ft=null,at=null,ct=null}}}const a=new r,l=new s,c=new o;let h={},u=null,d=!1,f=null,p=null,_=null,x=null,g=null,m=null,S=null,M=!1,v=null,y=null,T=null,D=null,L=null;const F=n.getParameter(35661);let N=!1,k=0;const I=n.getParameter(7938);I.indexOf("WebGL")!==-1?(k=parseFloat(/^WebGL (\d)/.exec(I)[1]),N=k>=1):I.indexOf("OpenGL ES")!==-1&&(k=parseFloat(/^OpenGL ES (\d)/.exec(I)[1]),N=k>=2);let C=null,P={};const O=new Ft,G=new Ft;function Y(R,X,nt){const st=new Uint8Array(4),j=n.createTexture();n.bindTexture(R,j),n.texParameteri(R,10241,9728),n.texParameteri(R,10240,9728);for(let ut=0;ut<nt;ut++)n.texImage2D(X+ut,0,6408,1,1,0,6408,5121,st);return j}const Q={};Q[3553]=Y(3553,3553,1),Q[34067]=Y(34067,34069,6),a.setClear(0,0,0,1),l.setClear(1),c.setClear(0),it(2929),l.setFunc(ca),Ht(!1),Lt(Gl),it(2884),Ct(yr);function it(R){h[R]!==!0&&(n.enable(R),h[R]=!0)}function et(R){h[R]!==!1&&(n.disable(R),h[R]=!1)}function wt(R){return u!==R?(n.useProgram(R),u=R,!0):!1}const ot={[Ti]:32774,[If]:32778,[Ff]:32779};if(i)ot[jl]=32775,ot[Xl]=32776;else{const R=t.get("EXT_blend_minmax");R!==null&&(ot[jl]=R.MIN_EXT,ot[Xl]=R.MAX_EXT)}const Et={[Nf]:0,[Of]:1,[Bf]:768,[pu]:770,[Vf]:776,[Hf]:774,[kf]:772,[zf]:769,[mu]:771,[Gf]:775,[Uf]:773};function Ct(R,X,nt,st,j,ut,ft,at){if(R===yr){d===!0&&(et(3042),d=!1);return}if(d===!1&&(it(3042),d=!0),R!==Df){if(R!==f||at!==M){if((p!==Ti||g!==Ti)&&(n.blendEquation(32774),p=Ti,g=Ti),at)switch(R){case vr:n.blendFuncSeparate(1,771,1,771);break;case Vl:n.blendFunc(1,1);break;case Wl:n.blendFuncSeparate(0,0,769,771);break;case ql:n.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",R);break}else switch(R){case vr:n.blendFuncSeparate(770,771,1,771);break;case Vl:n.blendFunc(770,1);break;case Wl:n.blendFunc(0,769);break;case ql:n.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",R);break}_=null,x=null,m=null,S=null,f=R,M=at}return}j=j||X,ut=ut||nt,ft=ft||st,(X!==p||j!==g)&&(n.blendEquationSeparate(ot[X],ot[j]),p=X,g=j),(nt!==_||st!==x||ut!==m||ft!==S)&&(n.blendFuncSeparate(Et[nt],Et[st],Et[ut],Et[ft]),_=nt,x=st,m=ut,S=ft),f=R,M=null}function H(R,X){R.side===Vr?et(2884):it(2884);let nt=R.side===Kt;X&&(nt=!nt),Ht(nt),R.blending===vr&&R.transparent===!1?Ct(yr):Ct(R.blending,R.blendEquation,R.blendSrc,R.blendDst,R.blendEquationAlpha,R.blendSrcAlpha,R.blendDstAlpha,R.premultipliedAlpha),l.setFunc(R.depthFunc),l.setTest(R.depthTest),l.setMask(R.depthWrite),a.setMask(R.colorWrite);const st=R.stencilWrite;c.setTest(st),st&&(c.setMask(R.stencilWriteMask),c.setFunc(R.stencilFunc,R.stencilRef,R.stencilFuncMask),c.setOp(R.stencilFail,R.stencilZFail,R.stencilZPass)),gt(R.polygonOffset,R.polygonOffsetFactor,R.polygonOffsetUnits)}function Ht(R){v!==R&&(R?n.frontFace(2304):n.frontFace(2305),v=R)}function Lt(R){R!==Cf?(it(2884),R!==y&&(R===Gl?n.cullFace(1029):R===Rf?n.cullFace(1028):n.cullFace(1032))):et(2884),y=R}function Rt(R){R!==T&&(N&&n.lineWidth(R),T=R)}function gt(R,X,nt){R?(it(32823),(D!==X||L!==nt)&&(n.polygonOffset(X,nt),D=X,L=nt)):et(32823)}function Pt(R){R?it(3089):et(3089)}function q(R){R===void 0&&(R=33984+F-1),C!==R&&(n.activeTexture(R),C=R)}function Z(R,X){C===null&&q();let nt=P[C];nt===void 0&&(nt={type:void 0,texture:void 0},P[C]=nt),(nt.type!==R||nt.texture!==X)&&(n.bindTexture(R,X||Q[R]),nt.type=R,nt.texture=X)}function $(){const R=P[C];R!==void 0&&R.type!==void 0&&(n.bindTexture(R.type,null),R.type=void 0,R.texture=void 0)}function lt(){try{n.compressedTexImage2D.apply(n,arguments)}catch(R){console.error("THREE.WebGLState:",R)}}function rt(){try{n.texImage2D.apply(n,arguments)}catch(R){console.error("THREE.WebGLState:",R)}}function E(){try{n.texImage3D.apply(n,arguments)}catch(R){console.error("THREE.WebGLState:",R)}}function w(R){O.equals(R)===!1&&(n.scissor(R.x,R.y,R.z,R.w),O.copy(R))}function V(R){G.equals(R)===!1&&(n.viewport(R.x,R.y,R.z,R.w),G.copy(R))}function W(){n.disable(3042),n.disable(2884),n.disable(2929),n.disable(32823),n.disable(3089),n.disable(2960),n.blendEquation(32774),n.blendFunc(1,0),n.blendFuncSeparate(1,0,1,0),n.colorMask(!0,!0,!0,!0),n.clearColor(0,0,0,0),n.depthMask(!0),n.depthFunc(513),n.clearDepth(1),n.stencilMask(4294967295),n.stencilFunc(519,0,4294967295),n.stencilOp(7680,7680,7680),n.clearStencil(0),n.cullFace(1029),n.frontFace(2305),n.polygonOffset(0,0),n.activeTexture(33984),n.useProgram(null),n.lineWidth(1),n.scissor(0,0,n.canvas.width,n.canvas.height),n.viewport(0,0,n.canvas.width,n.canvas.height),h={},C=null,P={},u=null,d=!1,f=null,p=null,_=null,x=null,g=null,m=null,S=null,M=!1,v=null,y=null,T=null,D=null,L=null,a.reset(),l.reset(),c.reset()}return{buffers:{color:a,depth:l,stencil:c},enable:it,disable:et,useProgram:wt,setBlending:Ct,setMaterial:H,setFlipSided:Ht,setCullFace:Lt,setLineWidth:Rt,setPolygonOffset:gt,setScissorTest:Pt,activeTexture:q,bindTexture:Z,unbindTexture:$,compressedTexImage2D:lt,texImage2D:rt,texImage3D:E,scissor:w,viewport:V,reset:W}}function bx(n,t,e,i,r,s,o){const a=r.isWebGL2,l=r.maxTextures,c=r.maxCubemapSize,h=r.maxTextureSize,u=r.maxSamples,d=new WeakMap;let f,p=!1;try{p=typeof OffscreenCanvas!="undefined"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function _(E,w){return p?new OffscreenCanvas(E,w):document.createElementNS("http://www.w3.org/1999/xhtml","canvas")}function x(E,w,V,W){let R=1;if((E.width>W||E.height>W)&&(R=W/Math.max(E.width,E.height)),R<1||w===!0)if(typeof HTMLImageElement!="undefined"&&E instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&E instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&E instanceof ImageBitmap){const X=w?bt.floorPowerOfTwo:Math.floor,nt=X(R*E.width),st=X(R*E.height);f===void 0&&(f=_(nt,st));const j=V?_(nt,st):f;return j.width=nt,j.height=st,j.getContext("2d").drawImage(E,0,0,nt,st),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+E.width+"x"+E.height+") to ("+nt+"x"+st+")."),j}else return"data"in E&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+E.width+"x"+E.height+")."),E;return E}function g(E){return bt.isPowerOfTwo(E.width)&&bt.isPowerOfTwo(E.height)}function m(E){return a?!1:E.wrapS!==Le||E.wrapT!==Le||E.minFilter!==pe&&E.minFilter!==oe}function S(E,w){return E.generateMipmaps&&w&&E.minFilter!==pe&&E.minFilter!==oe}function M(E,w,V,W){n.generateMipmap(E);const R=i.get(w);R.__maxMipLevel=Math.log2(Math.max(V,W))}function v(E,w,V){if(a===!1)return w;if(E!==null){if(n[E]!==void 0)return n[E];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+E+"'")}let W=w;return w===6403&&(V===5126&&(W=33326),V===5131&&(W=33325),V===5121&&(W=33321)),w===6407&&(V===5126&&(W=34837),V===5131&&(W=34843),V===5121&&(W=32849)),w===6408&&(V===5126&&(W=34836),V===5131&&(W=34842),V===5121&&(W=32856)),(W===33325||W===33326||W===34842||W===34836)&&t.get("EXT_color_buffer_float"),W}function y(E){return E===pe||E===Jl||E===Ql?9728:9729}function T(E){const w=E.target;w.removeEventListener("dispose",T),L(w),w.isVideoTexture&&d.delete(w),o.memory.textures--}function D(E){const w=E.target;w.removeEventListener("dispose",D),F(w),o.memory.textures--}function L(E){const w=i.get(E);w.__webglInit!==void 0&&(n.deleteTexture(w.__webglTexture),i.remove(E))}function F(E){const w=E.texture,V=i.get(E),W=i.get(w);if(!!E){if(W.__webglTexture!==void 0&&n.deleteTexture(W.__webglTexture),E.depthTexture&&E.depthTexture.dispose(),E.isWebGLCubeRenderTarget)for(let R=0;R<6;R++)n.deleteFramebuffer(V.__webglFramebuffer[R]),V.__webglDepthbuffer&&n.deleteRenderbuffer(V.__webglDepthbuffer[R]);else n.deleteFramebuffer(V.__webglFramebuffer),V.__webglDepthbuffer&&n.deleteRenderbuffer(V.__webglDepthbuffer),V.__webglMultisampledFramebuffer&&n.deleteFramebuffer(V.__webglMultisampledFramebuffer),V.__webglColorRenderbuffer&&n.deleteRenderbuffer(V.__webglColorRenderbuffer),V.__webglDepthRenderbuffer&&n.deleteRenderbuffer(V.__webglDepthRenderbuffer);i.remove(w),i.remove(E)}}let N=0;function k(){N=0}function I(){const E=N;return E>=l&&console.warn("THREE.WebGLTextures: Trying to use "+E+" texture units while this GPU supports only "+l),N+=1,E}function C(E,w){const V=i.get(E);if(E.isVideoTexture&&q(E),E.version>0&&V.__version!==E.version){const W=E.image;if(W===void 0)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else if(W.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{wt(V,E,w);return}}e.activeTexture(33984+w),e.bindTexture(3553,V.__webglTexture)}function P(E,w){const V=i.get(E);if(E.version>0&&V.__version!==E.version){wt(V,E,w);return}e.activeTexture(33984+w),e.bindTexture(35866,V.__webglTexture)}function O(E,w){const V=i.get(E);if(E.version>0&&V.__version!==E.version){wt(V,E,w);return}e.activeTexture(33984+w),e.bindTexture(32879,V.__webglTexture)}function G(E,w){const V=i.get(E);if(E.version>0&&V.__version!==E.version){ot(V,E,w);return}e.activeTexture(33984+w),e.bindTexture(34067,V.__webglTexture)}const Y={[ha]:10497,[Le]:33071,[ua]:33648},Q={[pe]:9728,[Jl]:9984,[Ql]:9986,[oe]:9729,[rp]:9985,[Qs]:9987};function it(E,w,V){if(V?(n.texParameteri(E,10242,Y[w.wrapS]),n.texParameteri(E,10243,Y[w.wrapT]),(E===32879||E===35866)&&n.texParameteri(E,32882,Y[w.wrapR]),n.texParameteri(E,10240,Q[w.magFilter]),n.texParameteri(E,10241,Q[w.minFilter])):(n.texParameteri(E,10242,33071),n.texParameteri(E,10243,33071),(E===32879||E===35866)&&n.texParameteri(E,32882,33071),(w.wrapS!==Le||w.wrapT!==Le)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),n.texParameteri(E,10240,y(w.magFilter)),n.texParameteri(E,10241,y(w.minFilter)),w.minFilter!==pe&&w.minFilter!==oe&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),t.has("EXT_texture_filter_anisotropic")===!0){const W=t.get("EXT_texture_filter_anisotropic");if(w.type===Tn&&t.has("OES_texture_float_linear")===!1||a===!1&&w.type===Ns&&t.has("OES_texture_half_float_linear")===!1)return;(w.anisotropy>1||i.get(w).__currentAnisotropy)&&(n.texParameterf(E,W.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(w.anisotropy,r.getMaxAnisotropy())),i.get(w).__currentAnisotropy=w.anisotropy)}}function et(E,w){E.__webglInit===void 0&&(E.__webglInit=!0,w.addEventListener("dispose",T),E.__webglTexture=n.createTexture(),o.memory.textures++)}function wt(E,w,V){let W=3553;w.isDataTexture2DArray&&(W=35866),w.isDataTexture3D&&(W=32879),et(E,w),e.activeTexture(33984+V),e.bindTexture(W,E.__webglTexture),n.pixelStorei(37440,w.flipY),n.pixelStorei(37441,w.premultiplyAlpha),n.pixelStorei(3317,w.unpackAlignment),n.pixelStorei(37443,0);const R=m(w)&&g(w.image)===!1,X=x(w.image,R,!1,h),nt=g(X)||a,st=s.convert(w.format);let j=s.convert(w.type),ut=v(w.internalFormat,st,j);it(W,w,nt);let ft;const at=w.mipmaps;if(w.isDepthTexture)ut=6402,a?w.type===Tn?ut=36012:w.type===Ts?ut=33190:w.type===wr?ut=35056:ut=33189:w.type===Tn&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),w.format===Fi&&ut===6402&&w.type!==Fs&&w.type!==Ts&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),w.type=Fs,j=s.convert(w.type)),w.format===Ir&&ut===6402&&(ut=34041,w.type!==wr&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),w.type=wr,j=s.convert(w.type))),e.texImage2D(3553,0,ut,X.width,X.height,0,st,j,null);else if(w.isDataTexture)if(at.length>0&&nt){for(let ct=0,ht=at.length;ct<ht;ct++)ft=at[ct],e.texImage2D(3553,ct,ut,ft.width,ft.height,0,st,j,ft.data);w.generateMipmaps=!1,E.__maxMipLevel=at.length-1}else e.texImage2D(3553,0,ut,X.width,X.height,0,st,j,X.data),E.__maxMipLevel=0;else if(w.isCompressedTexture){for(let ct=0,ht=at.length;ct<ht;ct++)ft=at[ct],w.format!==Ye&&w.format!==Kn?st!==null?e.compressedTexImage2D(3553,ct,ut,ft.width,ft.height,0,ft.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):e.texImage2D(3553,ct,ut,ft.width,ft.height,0,st,j,ft.data);E.__maxMipLevel=at.length-1}else if(w.isDataTexture2DArray)e.texImage3D(35866,0,ut,X.width,X.height,X.depth,0,st,j,X.data),E.__maxMipLevel=0;else if(w.isDataTexture3D)e.texImage3D(32879,0,ut,X.width,X.height,X.depth,0,st,j,X.data),E.__maxMipLevel=0;else if(at.length>0&&nt){for(let ct=0,ht=at.length;ct<ht;ct++)ft=at[ct],e.texImage2D(3553,ct,ut,st,j,ft);w.generateMipmaps=!1,E.__maxMipLevel=at.length-1}else e.texImage2D(3553,0,ut,st,j,X),E.__maxMipLevel=0;S(w,nt)&&M(W,w,X.width,X.height),E.__version=w.version,w.onUpdate&&w.onUpdate(w)}function ot(E,w,V){if(w.image.length!==6)return;et(E,w),e.activeTexture(33984+V),e.bindTexture(34067,E.__webglTexture),n.pixelStorei(37440,w.flipY),n.pixelStorei(37441,w.premultiplyAlpha),n.pixelStorei(3317,w.unpackAlignment),n.pixelStorei(37443,0);const W=w&&(w.isCompressedTexture||w.image[0].isCompressedTexture),R=w.image[0]&&w.image[0].isDataTexture,X=[];for(let ct=0;ct<6;ct++)!W&&!R?X[ct]=x(w.image[ct],!1,!0,c):X[ct]=R?w.image[ct].image:w.image[ct];const nt=X[0],st=g(nt)||a,j=s.convert(w.format),ut=s.convert(w.type),ft=v(w.internalFormat,j,ut);it(34067,w,st);let at;if(W){for(let ct=0;ct<6;ct++){at=X[ct].mipmaps;for(let ht=0;ht<at.length;ht++){const Wt=at[ht];w.format!==Ye&&w.format!==Kn?j!==null?e.compressedTexImage2D(34069+ct,ht,ft,Wt.width,Wt.height,0,Wt.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):e.texImage2D(34069+ct,ht,ft,Wt.width,Wt.height,0,j,ut,Wt.data)}}E.__maxMipLevel=at.length-1}else{at=w.mipmaps;for(let ct=0;ct<6;ct++)if(R){e.texImage2D(34069+ct,0,ft,X[ct].width,X[ct].height,0,j,ut,X[ct].data);for(let ht=0;ht<at.length;ht++){const _e=at[ht].image[ct].image;e.texImage2D(34069+ct,ht+1,ft,_e.width,_e.height,0,j,ut,_e.data)}}else{e.texImage2D(34069+ct,0,ft,j,ut,X[ct]);for(let ht=0;ht<at.length;ht++){const Wt=at[ht];e.texImage2D(34069+ct,ht+1,ft,j,ut,Wt.image[ct])}}E.__maxMipLevel=at.length}S(w,st)&&M(34067,w,nt.width,nt.height),E.__version=w.version,w.onUpdate&&w.onUpdate(w)}function Et(E,w,V,W){const R=w.texture,X=s.convert(R.format),nt=s.convert(R.type),st=v(R.internalFormat,X,nt);W===32879||W===35866?e.texImage3D(W,0,st,w.width,w.height,w.depth,0,X,nt,null):e.texImage2D(W,0,st,w.width,w.height,0,X,nt,null),n.bindFramebuffer(36160,E),n.framebufferTexture2D(36160,V,W,i.get(R).__webglTexture,0),n.bindFramebuffer(36160,null)}function Ct(E,w,V){if(n.bindRenderbuffer(36161,E),w.depthBuffer&&!w.stencilBuffer){let W=33189;if(V){const R=w.depthTexture;R&&R.isDepthTexture&&(R.type===Tn?W=36012:R.type===Ts&&(W=33190));const X=Pt(w);n.renderbufferStorageMultisample(36161,X,W,w.width,w.height)}else n.renderbufferStorage(36161,W,w.width,w.height);n.framebufferRenderbuffer(36160,36096,36161,E)}else if(w.depthBuffer&&w.stencilBuffer){if(V){const W=Pt(w);n.renderbufferStorageMultisample(36161,W,35056,w.width,w.height)}else n.renderbufferStorage(36161,34041,w.width,w.height);n.framebufferRenderbuffer(36160,33306,36161,E)}else{const W=w.texture,R=s.convert(W.format),X=s.convert(W.type),nt=v(W.internalFormat,R,X);if(V){const st=Pt(w);n.renderbufferStorageMultisample(36161,st,nt,w.width,w.height)}else n.renderbufferStorage(36161,nt,w.width,w.height)}n.bindRenderbuffer(36161,null)}function H(E,w){if(w&&w.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(n.bindFramebuffer(36160,E),!(w.depthTexture&&w.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!i.get(w.depthTexture).__webglTexture||w.depthTexture.image.width!==w.width||w.depthTexture.image.height!==w.height)&&(w.depthTexture.image.width=w.width,w.depthTexture.image.height=w.height,w.depthTexture.needsUpdate=!0),C(w.depthTexture,0);const W=i.get(w.depthTexture).__webglTexture;if(w.depthTexture.format===Fi)n.framebufferTexture2D(36160,36096,3553,W,0);else if(w.depthTexture.format===Ir)n.framebufferTexture2D(36160,33306,3553,W,0);else throw new Error("Unknown depthTexture format")}function Ht(E){const w=i.get(E),V=E.isWebGLCubeRenderTarget===!0;if(E.depthTexture){if(V)throw new Error("target.depthTexture not supported in Cube render targets");H(w.__webglFramebuffer,E)}else if(V){w.__webglDepthbuffer=[];for(let W=0;W<6;W++)n.bindFramebuffer(36160,w.__webglFramebuffer[W]),w.__webglDepthbuffer[W]=n.createRenderbuffer(),Ct(w.__webglDepthbuffer[W],E,!1)}else n.bindFramebuffer(36160,w.__webglFramebuffer),w.__webglDepthbuffer=n.createRenderbuffer(),Ct(w.__webglDepthbuffer,E,!1);n.bindFramebuffer(36160,null)}function Lt(E){const w=E.texture,V=i.get(E),W=i.get(w);E.addEventListener("dispose",D),W.__webglTexture=n.createTexture(),o.memory.textures++;const R=E.isWebGLCubeRenderTarget===!0,X=E.isWebGLMultisampleRenderTarget===!0,nt=w.isDataTexture3D||w.isDataTexture2DArray,st=g(E)||a;if(a&&w.format===Kn&&(w.type===Tn||w.type===Ns)&&(w.format=Ye,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),R){V.__webglFramebuffer=[];for(let j=0;j<6;j++)V.__webglFramebuffer[j]=n.createFramebuffer()}else if(V.__webglFramebuffer=n.createFramebuffer(),X)if(a){V.__webglMultisampledFramebuffer=n.createFramebuffer(),V.__webglColorRenderbuffer=n.createRenderbuffer(),n.bindRenderbuffer(36161,V.__webglColorRenderbuffer);const j=s.convert(w.format),ut=s.convert(w.type),ft=v(w.internalFormat,j,ut),at=Pt(E);n.renderbufferStorageMultisample(36161,at,ft,E.width,E.height),n.bindFramebuffer(36160,V.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(36160,36064,36161,V.__webglColorRenderbuffer),n.bindRenderbuffer(36161,null),E.depthBuffer&&(V.__webglDepthRenderbuffer=n.createRenderbuffer(),Ct(V.__webglDepthRenderbuffer,E,!0)),n.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(R){e.bindTexture(34067,W.__webglTexture),it(34067,w,st);for(let j=0;j<6;j++)Et(V.__webglFramebuffer[j],E,36064,34069+j);S(w,st)&&M(34067,w,E.width,E.height),e.bindTexture(34067,null)}else{let j=3553;nt&&(a?j=w.isDataTexture3D?32879:35866:console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")),e.bindTexture(j,W.__webglTexture),it(j,w,st),Et(V.__webglFramebuffer,E,36064,j),S(w,st)&&M(3553,w,E.width,E.height),e.bindTexture(3553,null)}E.depthBuffer&&Ht(E)}function Rt(E){const w=E.texture,V=g(E)||a;if(S(w,V)){const W=E.isWebGLCubeRenderTarget?34067:3553,R=i.get(w).__webglTexture;e.bindTexture(W,R),M(W,w,E.width,E.height),e.bindTexture(W,null)}}function gt(E){if(E.isWebGLMultisampleRenderTarget)if(a){const w=i.get(E);n.bindFramebuffer(36008,w.__webglMultisampledFramebuffer),n.bindFramebuffer(36009,w.__webglFramebuffer);const V=E.width,W=E.height;let R=16384;E.depthBuffer&&(R|=256),E.stencilBuffer&&(R|=1024),n.blitFramebuffer(0,0,V,W,0,0,V,W,R,9728),n.bindFramebuffer(36160,w.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")}function Pt(E){return a&&E.isWebGLMultisampleRenderTarget?Math.min(u,E.samples):0}function q(E){const w=o.render.frame;d.get(E)!==w&&(d.set(E,w),E.update())}let Z=!1,$=!1;function lt(E,w){E&&E.isWebGLRenderTarget&&(Z===!1&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),Z=!0),E=E.texture),C(E,w)}function rt(E,w){E&&E.isWebGLCubeRenderTarget&&($===!1&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),$=!0),E=E.texture),G(E,w)}this.allocateTextureUnit=I,this.resetTextureUnits=k,this.setTexture2D=C,this.setTexture2DArray=P,this.setTexture3D=O,this.setTextureCube=G,this.setupRenderTarget=Lt,this.updateRenderTargetMipmap=Rt,this.updateMultisampleRenderTarget=gt,this.safeSetTexture2D=lt,this.safeSetTextureCube=rt}function wx(n,t,e){const i=e.isWebGL2;function r(s){let o;if(s===el)return 5121;if(s===lp)return 32819;if(s===cp)return 32820;if(s===hp)return 33635;if(s===sp)return 5120;if(s===op)return 5122;if(s===Fs)return 5123;if(s===ap)return 5124;if(s===Ts)return 5125;if(s===Tn)return 5126;if(s===Ns)return i?5131:(o=t.get("OES_texture_half_float"),o!==null?o.HALF_FLOAT_OES:null);if(s===up)return 6406;if(s===Kn)return 6407;if(s===Ye)return 6408;if(s===dp)return 6409;if(s===fp)return 6410;if(s===Fi)return 6402;if(s===Ir)return 34041;if(s===pp)return 6403;if(s===mp)return 36244;if(s===gp)return 33319;if(s===_p)return 33320;if(s===xp)return 36248;if(s===yp)return 36249;if(s===$l||s===Kl||s===tc||s===ec)if(o=t.get("WEBGL_compressed_texture_s3tc"),o!==null){if(s===$l)return o.COMPRESSED_RGB_S3TC_DXT1_EXT;if(s===Kl)return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(s===tc)return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(s===ec)return o.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(s===nc||s===ic||s===rc||s===sc)if(o=t.get("WEBGL_compressed_texture_pvrtc"),o!==null){if(s===nc)return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(s===ic)return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(s===rc)return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(s===sc)return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(s===vp)return o=t.get("WEBGL_compressed_texture_etc1"),o!==null?o.COMPRESSED_RGB_ETC1_WEBGL:null;if((s===oc||s===ac)&&(o=t.get("WEBGL_compressed_texture_etc"),o!==null)){if(s===oc)return o.COMPRESSED_RGB8_ETC2;if(s===ac)return o.COMPRESSED_RGBA8_ETC2_EAC}if(s===bp||s===wp||s===Mp||s===Sp||s===Tp||s===Ep||s===Ap||s===Lp||s===Cp||s===Rp||s===Pp||s===Dp||s===Ip||s===Fp||s===Op||s===Bp||s===zp||s===kp||s===Up||s===Hp||s===Gp||s===Vp||s===Wp||s===qp||s===jp||s===Xp||s===Yp||s===Zp)return o=t.get("WEBGL_compressed_texture_astc"),o!==null?s:null;if(s===Np)return o=t.get("EXT_texture_compression_bptc"),o!==null?s:null;if(s===wr)return i?34042:(o=t.get("WEBGL_depth_texture"),o!==null?o.UNSIGNED_INT_24_8_WEBGL:null)}return{convert:r}}function ya(n=[]){ue.call(this),this.cameras=n}ya.prototype=Object.assign(Object.create(ue.prototype),{constructor:ya,isArrayCamera:!0});class mr extends xt{constructor(){super(),this.type="Group"}}mr.prototype.isGroup=!0;function Mr(){this._targetRay=null,this._grip=null,this._hand=null}Object.assign(Mr.prototype,{constructor:Mr,getHandSpace:function(){return this._hand===null&&(this._hand=new mr,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand},getTargetRaySpace:function(){return this._targetRay===null&&(this._targetRay=new mr,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1),this._targetRay},getGripSpace:function(){return this._grip===null&&(this._grip=new mr,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1),this._grip},dispatchEvent:function(n){return this._targetRay!==null&&this._targetRay.dispatchEvent(n),this._grip!==null&&this._grip.dispatchEvent(n),this._hand!==null&&this._hand.dispatchEvent(n),this},disconnect:function(n){return this.dispatchEvent({type:"disconnected",data:n}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this},update:function(n,t,e){let i=null,r=null,s=null;const o=this._targetRay,a=this._grip,l=this._hand;if(n&&t.session.visibilityState!=="visible-blurred")if(l&&n.hand){s=!0;for(const p of n.hand.values()){const _=t.getJointPose(p,e);if(l.joints[p.jointName]===void 0){const g=new mr;g.matrixAutoUpdate=!1,g.visible=!1,l.joints[p.jointName]=g,l.add(g)}const x=l.joints[p.jointName];_!==null&&(x.matrix.fromArray(_.transform.matrix),x.matrix.decompose(x.position,x.rotation,x.scale),x.jointRadius=_.radius),x.visible=_!==null}const c=l.joints["index-finger-tip"],h=l.joints["thumb-tip"],u=c.position.distanceTo(h.position),d=.02,f=.005;l.inputState.pinching&&u>d+f?(l.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:n.handedness,target:this})):!l.inputState.pinching&&u<=d-f&&(l.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:n.handedness,target:this}))}else o!==null&&(i=t.getPose(n.targetRaySpace,e),i!==null&&(o.matrix.fromArray(i.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale))),a!==null&&n.gripSpace&&(r=t.getPose(n.gripSpace,e),r!==null&&(a.matrix.fromArray(r.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale)));return o!==null&&(o.visible=i!==null),a!==null&&(a.visible=r!==null),l!==null&&(l.visible=s!==null),this}});function Bu(n,t){const e=this;let i=null,r=1,s=null,o="local-floor",a=null;const l=[],c=new Map,h=new ue;h.layers.enable(1),h.viewport=new Ft;const u=new ue;u.layers.enable(2),u.viewport=new Ft;const d=[h,u],f=new ya;f.layers.enable(1),f.layers.enable(2);let p=null,_=null;this.enabled=!1,this.isPresenting=!1,this.getController=function(F){let N=l[F];return N===void 0&&(N=new Mr,l[F]=N),N.getTargetRaySpace()},this.getControllerGrip=function(F){let N=l[F];return N===void 0&&(N=new Mr,l[F]=N),N.getGripSpace()},this.getHand=function(F){let N=l[F];return N===void 0&&(N=new Mr,l[F]=N),N.getHandSpace()};function x(F){const N=c.get(F.inputSource);N&&N.dispatchEvent({type:F.type,data:F.inputSource})}function g(){c.forEach(function(F,N){F.disconnect(N)}),c.clear(),p=null,_=null,n.setFramebuffer(null),n.setRenderTarget(n.getRenderTarget()),L.stop(),e.isPresenting=!1,e.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(F){r=F,e.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(F){o=F,e.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return s},this.getSession=function(){return i},this.setSession=async function(F){if(i=F,i!==null){i.addEventListener("select",x),i.addEventListener("selectstart",x),i.addEventListener("selectend",x),i.addEventListener("squeeze",x),i.addEventListener("squeezestart",x),i.addEventListener("squeezeend",x),i.addEventListener("end",g),i.addEventListener("inputsourceschange",m);const N=t.getContextAttributes();N.xrCompatible!==!0&&await t.makeXRCompatible();const k={antialias:N.antialias,alpha:N.alpha,depth:N.depth,stencil:N.stencil,framebufferScaleFactor:r},I=new XRWebGLLayer(i,t,k);i.updateRenderState({baseLayer:I}),s=await i.requestReferenceSpace(o),L.setContext(i),L.start(),e.isPresenting=!0,e.dispatchEvent({type:"sessionstart"})}};function m(F){const N=i.inputSources;for(let k=0;k<l.length;k++)c.set(N[k],l[k]);for(let k=0;k<F.removed.length;k++){const I=F.removed[k],C=c.get(I);C&&(C.dispatchEvent({type:"disconnected",data:I}),c.delete(I))}for(let k=0;k<F.added.length;k++){const I=F.added[k],C=c.get(I);C&&C.dispatchEvent({type:"connected",data:I})}}const S=new A,M=new A;function v(F,N,k){S.setFromMatrixPosition(N.matrixWorld),M.setFromMatrixPosition(k.matrixWorld);const I=S.distanceTo(M),C=N.projectionMatrix.elements,P=k.projectionMatrix.elements,O=C[14]/(C[10]-1),G=C[14]/(C[10]+1),Y=(C[9]+1)/C[5],Q=(C[9]-1)/C[5],it=(C[8]-1)/C[0],et=(P[8]+1)/P[0],wt=O*it,ot=O*et,Et=I/(-it+et),Ct=Et*-it;N.matrixWorld.decompose(F.position,F.quaternion,F.scale),F.translateX(Ct),F.translateZ(Et),F.matrixWorld.compose(F.position,F.quaternion,F.scale),F.matrixWorldInverse.copy(F.matrixWorld).invert();const H=O+Et,Ht=G+Et,Lt=wt-Ct,Rt=ot+(I-Ct),gt=Y*G/Ht*H,Pt=Q*G/Ht*H;F.projectionMatrix.makePerspective(Lt,Rt,gt,Pt,H,Ht)}function y(F,N){N===null?F.matrixWorld.copy(F.matrix):F.matrixWorld.multiplyMatrices(N.matrixWorld,F.matrix),F.matrixWorldInverse.copy(F.matrixWorld).invert()}this.getCamera=function(F){f.near=u.near=h.near=F.near,f.far=u.far=h.far=F.far,(p!==f.near||_!==f.far)&&(i.updateRenderState({depthNear:f.near,depthFar:f.far}),p=f.near,_=f.far);const N=F.parent,k=f.cameras;y(f,N);for(let C=0;C<k.length;C++)y(k[C],N);F.matrixWorld.copy(f.matrixWorld),F.matrix.copy(f.matrix),F.matrix.decompose(F.position,F.quaternion,F.scale);const I=F.children;for(let C=0,P=I.length;C<P;C++)I[C].updateMatrixWorld(!0);return k.length===2?v(f,h,u):f.projectionMatrix.copy(h.projectionMatrix),f};let T=null;function D(F,N){if(a=N.getViewerPose(s),a!==null){const I=a.views,C=i.renderState.baseLayer;n.setFramebuffer(C.framebuffer);let P=!1;I.length!==f.cameras.length&&(f.cameras.length=0,P=!0);for(let O=0;O<I.length;O++){const G=I[O],Y=C.getViewport(G),Q=d[O];Q.matrix.fromArray(G.transform.matrix),Q.projectionMatrix.fromArray(G.projectionMatrix),Q.viewport.set(Y.x,Y.y,Y.width,Y.height),O===0&&f.matrix.copy(Q.matrix),P===!0&&f.cameras.push(Q)}}const k=i.inputSources;for(let I=0;I<l.length;I++){const C=l[I],P=k[I];C.update(P,N,s)}T&&T(F,N)}const L=new Mu;L.setAnimationLoop(D),this.setAnimationLoop=function(F){T=F},this.dispose=function(){}}Object.assign(Bu.prototype,kn.prototype);function Mx(n){function t(g,m){g.fogColor.value.copy(m.color),m.isFog?(g.fogNear.value=m.near,g.fogFar.value=m.far):m.isFogExp2&&(g.fogDensity.value=m.density)}function e(g,m,S,M){m.isMeshBasicMaterial?i(g,m):m.isMeshLambertMaterial?(i(g,m),l(g,m)):m.isMeshToonMaterial?(i(g,m),h(g,m)):m.isMeshPhongMaterial?(i(g,m),c(g,m)):m.isMeshStandardMaterial?(i(g,m),m.isMeshPhysicalMaterial?d(g,m):u(g,m)):m.isMeshMatcapMaterial?(i(g,m),f(g,m)):m.isMeshDepthMaterial?(i(g,m),p(g,m)):m.isMeshDistanceMaterial?(i(g,m),_(g,m)):m.isMeshNormalMaterial?(i(g,m),x(g,m)):m.isLineBasicMaterial?(r(g,m),m.isLineDashedMaterial&&s(g,m)):m.isPointsMaterial?o(g,m,S,M):m.isSpriteMaterial?a(g,m):m.isShadowMaterial?(g.color.value.copy(m.color),g.opacity.value=m.opacity):m.isShaderMaterial&&(m.uniformsNeedUpdate=!1)}function i(g,m){g.opacity.value=m.opacity,m.color&&g.diffuse.value.copy(m.color),m.emissive&&g.emissive.value.copy(m.emissive).multiplyScalar(m.emissiveIntensity),m.map&&(g.map.value=m.map),m.alphaMap&&(g.alphaMap.value=m.alphaMap),m.specularMap&&(g.specularMap.value=m.specularMap);const S=n.get(m).envMap;if(S){g.envMap.value=S,g.flipEnvMap.value=S.isCubeTexture&&S._needsFlipEnvMap?-1:1,g.reflectivity.value=m.reflectivity,g.refractionRatio.value=m.refractionRatio;const y=n.get(S).__maxMipLevel;y!==void 0&&(g.maxMipLevel.value=y)}m.lightMap&&(g.lightMap.value=m.lightMap,g.lightMapIntensity.value=m.lightMapIntensity),m.aoMap&&(g.aoMap.value=m.aoMap,g.aoMapIntensity.value=m.aoMapIntensity);let M;m.map?M=m.map:m.specularMap?M=m.specularMap:m.displacementMap?M=m.displacementMap:m.normalMap?M=m.normalMap:m.bumpMap?M=m.bumpMap:m.roughnessMap?M=m.roughnessMap:m.metalnessMap?M=m.metalnessMap:m.alphaMap?M=m.alphaMap:m.emissiveMap?M=m.emissiveMap:m.clearcoatMap?M=m.clearcoatMap:m.clearcoatNormalMap?M=m.clearcoatNormalMap:m.clearcoatRoughnessMap&&(M=m.clearcoatRoughnessMap),M!==void 0&&(M.isWebGLRenderTarget&&(M=M.texture),M.matrixAutoUpdate===!0&&M.updateMatrix(),g.uvTransform.value.copy(M.matrix));let v;m.aoMap?v=m.aoMap:m.lightMap&&(v=m.lightMap),v!==void 0&&(v.isWebGLRenderTarget&&(v=v.texture),v.matrixAutoUpdate===!0&&v.updateMatrix(),g.uv2Transform.value.copy(v.matrix))}function r(g,m){g.diffuse.value.copy(m.color),g.opacity.value=m.opacity}function s(g,m){g.dashSize.value=m.dashSize,g.totalSize.value=m.dashSize+m.gapSize,g.scale.value=m.scale}function o(g,m,S,M){g.diffuse.value.copy(m.color),g.opacity.value=m.opacity,g.size.value=m.size*S,g.scale.value=M*.5,m.map&&(g.map.value=m.map),m.alphaMap&&(g.alphaMap.value=m.alphaMap);let v;m.map?v=m.map:m.alphaMap&&(v=m.alphaMap),v!==void 0&&(v.matrixAutoUpdate===!0&&v.updateMatrix(),g.uvTransform.value.copy(v.matrix))}function a(g,m){g.diffuse.value.copy(m.color),g.opacity.value=m.opacity,g.rotation.value=m.rotation,m.map&&(g.map.value=m.map),m.alphaMap&&(g.alphaMap.value=m.alphaMap);let S;m.map?S=m.map:m.alphaMap&&(S=m.alphaMap),S!==void 0&&(S.matrixAutoUpdate===!0&&S.updateMatrix(),g.uvTransform.value.copy(S.matrix))}function l(g,m){m.emissiveMap&&(g.emissiveMap.value=m.emissiveMap)}function c(g,m){g.specular.value.copy(m.specular),g.shininess.value=Math.max(m.shininess,1e-4),m.emissiveMap&&(g.emissiveMap.value=m.emissiveMap),m.bumpMap&&(g.bumpMap.value=m.bumpMap,g.bumpScale.value=m.bumpScale,m.side===Kt&&(g.bumpScale.value*=-1)),m.normalMap&&(g.normalMap.value=m.normalMap,g.normalScale.value.copy(m.normalScale),m.side===Kt&&g.normalScale.value.negate()),m.displacementMap&&(g.displacementMap.value=m.displacementMap,g.displacementScale.value=m.displacementScale,g.displacementBias.value=m.displacementBias)}function h(g,m){m.gradientMap&&(g.gradientMap.value=m.gradientMap),m.emissiveMap&&(g.emissiveMap.value=m.emissiveMap),m.bumpMap&&(g.bumpMap.value=m.bumpMap,g.bumpScale.value=m.bumpScale,m.side===Kt&&(g.bumpScale.value*=-1)),m.normalMap&&(g.normalMap.value=m.normalMap,g.normalScale.value.copy(m.normalScale),m.side===Kt&&g.normalScale.value.negate()),m.displacementMap&&(g.displacementMap.value=m.displacementMap,g.displacementScale.value=m.displacementScale,g.displacementBias.value=m.displacementBias)}function u(g,m){g.roughness.value=m.roughness,g.metalness.value=m.metalness,m.roughnessMap&&(g.roughnessMap.value=m.roughnessMap),m.metalnessMap&&(g.metalnessMap.value=m.metalnessMap),m.emissiveMap&&(g.emissiveMap.value=m.emissiveMap),m.bumpMap&&(g.bumpMap.value=m.bumpMap,g.bumpScale.value=m.bumpScale,m.side===Kt&&(g.bumpScale.value*=-1)),m.normalMap&&(g.normalMap.value=m.normalMap,g.normalScale.value.copy(m.normalScale),m.side===Kt&&g.normalScale.value.negate()),m.displacementMap&&(g.displacementMap.value=m.displacementMap,g.displacementScale.value=m.displacementScale,g.displacementBias.value=m.displacementBias),n.get(m).envMap&&(g.envMapIntensity.value=m.envMapIntensity)}function d(g,m){u(g,m),g.reflectivity.value=m.reflectivity,g.clearcoat.value=m.clearcoat,g.clearcoatRoughness.value=m.clearcoatRoughness,m.sheen&&g.sheen.value.copy(m.sheen),m.clearcoatMap&&(g.clearcoatMap.value=m.clearcoatMap),m.clearcoatRoughnessMap&&(g.clearcoatRoughnessMap.value=m.clearcoatRoughnessMap),m.clearcoatNormalMap&&(g.clearcoatNormalScale.value.copy(m.clearcoatNormalScale),g.clearcoatNormalMap.value=m.clearcoatNormalMap,m.side===Kt&&g.clearcoatNormalScale.value.negate()),g.transmission.value=m.transmission,m.transmissionMap&&(g.transmissionMap.value=m.transmissionMap)}function f(g,m){m.matcap&&(g.matcap.value=m.matcap),m.bumpMap&&(g.bumpMap.value=m.bumpMap,g.bumpScale.value=m.bumpScale,m.side===Kt&&(g.bumpScale.value*=-1)),m.normalMap&&(g.normalMap.value=m.normalMap,g.normalScale.value.copy(m.normalScale),m.side===Kt&&g.normalScale.value.negate()),m.displacementMap&&(g.displacementMap.value=m.displacementMap,g.displacementScale.value=m.displacementScale,g.displacementBias.value=m.displacementBias)}function p(g,m){m.displacementMap&&(g.displacementMap.value=m.displacementMap,g.displacementScale.value=m.displacementScale,g.displacementBias.value=m.displacementBias)}function _(g,m){m.displacementMap&&(g.displacementMap.value=m.displacementMap,g.displacementScale.value=m.displacementScale,g.displacementBias.value=m.displacementBias),g.referencePosition.value.copy(m.referencePosition),g.nearDistance.value=m.nearDistance,g.farDistance.value=m.farDistance}function x(g,m){m.bumpMap&&(g.bumpMap.value=m.bumpMap,g.bumpScale.value=m.bumpScale,m.side===Kt&&(g.bumpScale.value*=-1)),m.normalMap&&(g.normalMap.value=m.normalMap,g.normalScale.value.copy(m.normalScale),m.side===Kt&&g.normalScale.value.negate()),m.displacementMap&&(g.displacementMap.value=m.displacementMap,g.displacementScale.value=m.displacementScale,g.displacementBias.value=m.displacementBias)}return{refreshFogUniforms:t,refreshMaterialUniforms:e}}function Sx(){const n=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");return n.style.display="block",n}function Nt(n){n=n||{};const t=n.canvas!==void 0?n.canvas:Sx(),e=n.context!==void 0?n.context:null,i=n.alpha!==void 0?n.alpha:!1,r=n.depth!==void 0?n.depth:!0,s=n.stencil!==void 0?n.stencil:!0,o=n.antialias!==void 0?n.antialias:!1,a=n.premultipliedAlpha!==void 0?n.premultipliedAlpha:!0,l=n.preserveDrawingBuffer!==void 0?n.preserveDrawingBuffer:!1,c=n.powerPreference!==void 0?n.powerPreference:"default",h=n.failIfMajorPerformanceCaveat!==void 0?n.failIfMajorPerformanceCaveat:!1;let u=null,d=null;const f=[],p=[];this.domElement=t,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=Wr,this.physicallyCorrectLights=!1,this.toneMapping=br,this.toneMappingExposure=1,this.maxMorphTargets=8,this.maxMorphNormals=4;const _=this;let x=!1,g=null,m=0,S=0,M=null,v=null,y=-1,T=null;const D=new Ft,L=new Ft;let F=null,N=t.width,k=t.height,I=1,C=null,P=null;const O=new Ft(0,0,N,k),G=new Ft(0,0,N,k);let Y=!1;const Q=new to;let it=!1,et=!1;const wt=new dt,ot=new A,Et={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function Ct(){return M===null?I:1}let H=e;function Ht(b,z){for(let B=0;B<b.length;B++){const U=b[B],K=t.getContext(U,z);if(K!==null)return K}return null}try{const b={alpha:i,depth:r,stencil:s,antialias:o,premultipliedAlpha:a,preserveDrawingBuffer:l,powerPreference:c,failIfMajorPerformanceCaveat:h};if(t.addEventListener("webglcontextlost",_e,!1),t.addEventListener("webglcontextrestored",vl,!1),H===null){const z=["webgl2","webgl","experimental-webgl"];if(_.isWebGL1Renderer===!0&&z.shift(),H=Ht(z,b),H===null)throw Ht(z)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}H.getShaderPrecisionFormat===void 0&&(H.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(b){throw console.error("THREE.WebGLRenderer: "+b.message),b}let Lt,Rt,gt,Pt,q,Z,$,lt,rt,E,w,V,W,R,X,nt,st,j,ut,ft,at;function ct(){Lt=new e0(H),Rt=new $_(H,Lt,n),Lt.init(Rt),ft=new wx(H,Lt,Rt),gt=new vx(H,Lt,Rt),gt.scissor(L.copy(G).multiplyScalar(I).floor()),gt.viewport(D.copy(O).multiplyScalar(I).floor()),Pt=new r0,q=new lx,Z=new bx(H,Lt,gt,q,Rt,ft,Pt),$=new t0(_),lt=new Am(H,Rt),at=new J_(H,Lt,lt,Rt),rt=new n0(H,lt,Pt,at),E=new l0(H,rt,lt,Pt),st=new a0(H),X=new K_(q),w=new ax(_,$,Lt,Rt,at,X),V=new Mx(q),W=new ux(q),R=new _x(Lt,Rt),nt=new Z_(_,$,gt,E,a),j=new Q_(H,Lt,Pt,Rt),ut=new i0(H,Lt,Pt,Rt),Pt.programs=w.programs,_.capabilities=Rt,_.extensions=Lt,_.properties=q,_.renderLists=W,_.state=gt,_.info=Pt}ct();const ht=new Bu(_,H);this.xr=ht;const Wt=new Ou(_,E,Rt.maxTextureSize);this.shadowMap=Wt,this.getContext=function(){return H},this.getContextAttributes=function(){return H.getContextAttributes()},this.forceContextLoss=function(){const b=Lt.get("WEBGL_lose_context");b&&b.loseContext()},this.forceContextRestore=function(){const b=Lt.get("WEBGL_lose_context");b&&b.restoreContext()},this.getPixelRatio=function(){return I},this.setPixelRatio=function(b){b!==void 0&&(I=b,this.setSize(N,k,!1))},this.getSize=function(b){return b===void 0&&(console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"),b=new J),b.set(N,k)},this.setSize=function(b,z,B){if(ht.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}N=b,k=z,t.width=Math.floor(b*I),t.height=Math.floor(z*I),B!==!1&&(t.style.width=b+"px",t.style.height=z+"px"),this.setViewport(0,0,b,z)},this.getDrawingBufferSize=function(b){return b===void 0&&(console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"),b=new J),b.set(N*I,k*I).floor()},this.setDrawingBufferSize=function(b,z,B){N=b,k=z,I=B,t.width=Math.floor(b*B),t.height=Math.floor(z*B),this.setViewport(0,0,b,z)},this.getCurrentViewport=function(b){return b===void 0&&(console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"),b=new Ft),b.copy(D)},this.getViewport=function(b){return b.copy(O)},this.setViewport=function(b,z,B,U){b.isVector4?O.set(b.x,b.y,b.z,b.w):O.set(b,z,B,U),gt.viewport(D.copy(O).multiplyScalar(I).floor())},this.getScissor=function(b){return b.copy(G)},this.setScissor=function(b,z,B,U){b.isVector4?G.set(b.x,b.y,b.z,b.w):G.set(b,z,B,U),gt.scissor(L.copy(G).multiplyScalar(I).floor())},this.getScissorTest=function(){return Y},this.setScissorTest=function(b){gt.setScissorTest(Y=b)},this.setOpaqueSort=function(b){C=b},this.setTransparentSort=function(b){P=b},this.getClearColor=function(b){return b===void 0&&(console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"),b=new pt),b.copy(nt.getClearColor())},this.setClearColor=function(){nt.setClearColor.apply(nt,arguments)},this.getClearAlpha=function(){return nt.getClearAlpha()},this.setClearAlpha=function(){nt.setClearAlpha.apply(nt,arguments)},this.clear=function(b,z,B){let U=0;(b===void 0||b)&&(U|=16384),(z===void 0||z)&&(U|=256),(B===void 0||B)&&(U|=1024),H.clear(U)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",_e,!1),t.removeEventListener("webglcontextrestored",vl,!1),W.dispose(),R.dispose(),q.dispose(),$.dispose(),E.dispose(),at.dispose(),ht.dispose(),Qi.stop()};function _e(b){b.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),x=!0}function vl(){console.log("THREE.WebGLRenderer: Context Restored."),x=!1,ct()}function bl(b){const z=b.target;z.removeEventListener("dispose",bl),pd(z)}function pd(b){wl(b),q.remove(b)}function wl(b){const z=q.get(b).program;z!==void 0&&w.releaseProgram(z)}function md(b,z){b.render(function(B){_.renderBufferImmediate(B,z)})}this.renderBufferImmediate=function(b,z){at.initAttributes();const B=q.get(b);b.hasPositions&&!B.position&&(B.position=H.createBuffer()),b.hasNormals&&!B.normal&&(B.normal=H.createBuffer()),b.hasUvs&&!B.uv&&(B.uv=H.createBuffer()),b.hasColors&&!B.color&&(B.color=H.createBuffer());const U=z.getAttributes();b.hasPositions&&(H.bindBuffer(34962,B.position),H.bufferData(34962,b.positionArray,35048),at.enableAttribute(U.position),H.vertexAttribPointer(U.position,3,5126,!1,0,0)),b.hasNormals&&(H.bindBuffer(34962,B.normal),H.bufferData(34962,b.normalArray,35048),at.enableAttribute(U.normal),H.vertexAttribPointer(U.normal,3,5126,!1,0,0)),b.hasUvs&&(H.bindBuffer(34962,B.uv),H.bufferData(34962,b.uvArray,35048),at.enableAttribute(U.uv),H.vertexAttribPointer(U.uv,2,5126,!1,0,0)),b.hasColors&&(H.bindBuffer(34962,B.color),H.bufferData(34962,b.colorArray,35048),at.enableAttribute(U.color),H.vertexAttribPointer(U.color,3,5126,!1,0,0)),at.disableUnusedAttributes(),H.drawArrays(4,0,b.count),b.count=0},this.renderBufferDirect=function(b,z,B,U,K,Tt){z===null&&(z=Et);const mt=K.isMesh&&K.matrixWorld.determinant()<0,yt=El(b,z,U,K);gt.setMaterial(U,mt);let vt=B.index;const Yt=B.attributes.position;if(vt===null){if(Yt===void 0||Yt.count===0)return}else if(vt.count===0)return;let zt=1;U.wireframe===!0&&(vt=rt.getWireframeAttribute(B),zt=2),(U.morphTargets||U.morphNormals)&&st.update(K,B,U,yt),at.setup(K,U,yt,B,vt);let _t,It=j;vt!==null&&(_t=lt.get(vt),It=ut,It.setIndex(_t));const Ve=vt!==null?vt.count:Yt.count,kt=B.drawRange.start*zt,on=B.drawRange.count*zt,Qt=Tt!==null?Tt.start*zt:0,lo=Tt!==null?Tt.count*zt:1/0,xe=Math.max(kt,Qt),$i=Math.min(Ve,kt+on,Qt+lo)-1,oi=Math.max(0,$i-xe+1);if(oi!==0){if(K.isMesh)U.wireframe===!0?(gt.setLineWidth(U.wireframeLinewidth*Ct()),It.setMode(1)):It.setMode(4);else if(K.isLine){let Ki=U.linewidth;Ki===void 0&&(Ki=1),gt.setLineWidth(Ki*Ct()),K.isLineSegments?It.setMode(1):K.isLineLoop?It.setMode(2):It.setMode(3)}else K.isPoints?It.setMode(0):K.isSprite&&It.setMode(4);if(K.isInstancedMesh)It.renderInstances(xe,oi,K.count);else if(B.isInstancedBufferGeometry){const Ki=Math.min(B.instanceCount,B._maxInstanceCount);It.renderInstances(xe,oi,Ki)}else It.render(xe,oi)}},this.compile=function(b,z){d=R.get(b),d.init(),b.traverseVisible(function(U){U.isLight&&U.layers.test(z.layers)&&(d.pushLight(U),U.castShadow&&d.pushShadow(U))}),d.setupLights();const B=new WeakMap;b.traverse(function(U){const K=U.material;if(K)if(Array.isArray(K))for(let Tt=0;Tt<K.length;Tt++){const mt=K[Tt];B.has(mt)===!1&&(sn(mt,b,U),B.set(mt))}else B.has(K)===!1&&(sn(K,b,U),B.set(K))})};let ao=null;function gd(b){ht.isPresenting||ao&&ao(b)}const Qi=new Mu;Qi.setAnimationLoop(gd),typeof window!="undefined"&&Qi.setContext(window),this.setAnimationLoop=function(b){ao=b,ht.setAnimationLoop(b),b===null?Qi.stop():Qi.start()},this.render=function(b,z){let B,U;if(arguments[2]!==void 0&&(console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."),B=arguments[2]),arguments[3]!==void 0&&(console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."),U=arguments[3]),z!==void 0&&z.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(x===!0)return;at.resetDefaultState(),y=-1,T=null,b.autoUpdate===!0&&b.updateMatrixWorld(),z.parent===null&&z.updateMatrixWorld(),ht.enabled===!0&&ht.isPresenting===!0&&(z=ht.getCamera(z)),b.isScene===!0&&b.onBeforeRender(_,b,z,B||M),d=R.get(b,p.length),d.init(),p.push(d),wt.multiplyMatrices(z.projectionMatrix,z.matrixWorldInverse),Q.setFromProjectionMatrix(wt),et=this.localClippingEnabled,it=X.init(this.clippingPlanes,et,z),u=W.get(b,f.length),u.init(),f.push(u),Ml(b,z,0,_.sortObjects),u.finish(),_.sortObjects===!0&&u.sort(C,P),it===!0&&X.beginShadows();const K=d.state.shadowsArray;Wt.render(K,b,z),d.setupLights(),d.setupLightsView(z),it===!0&&X.endShadows(),this.info.autoReset===!0&&this.info.reset(),B!==void 0&&this.setRenderTarget(B),nt.render(u,b,z,U);const Tt=u.opaque,mt=u.transparent;Tt.length>0&&Sl(Tt,b,z),mt.length>0&&Sl(mt,b,z),b.isScene===!0&&b.onAfterRender(_,b,z),M!==null&&(Z.updateRenderTargetMipmap(M),Z.updateMultisampleRenderTarget(M)),gt.buffers.depth.setTest(!0),gt.buffers.depth.setMask(!0),gt.buffers.color.setMask(!0),gt.setPolygonOffset(!1),p.pop(),p.length>0?d=p[p.length-1]:d=null,f.pop(),f.length>0?u=f[f.length-1]:u=null};function Ml(b,z,B,U){if(b.visible===!1)return;if(b.layers.test(z.layers)){if(b.isGroup)B=b.renderOrder;else if(b.isLOD)b.autoUpdate===!0&&b.update(z);else if(b.isLight)d.pushLight(b),b.castShadow&&d.pushShadow(b);else if(b.isSprite){if(!b.frustumCulled||Q.intersectsSprite(b)){U&&ot.setFromMatrixPosition(b.matrixWorld).applyMatrix4(wt);const mt=E.update(b),yt=b.material;yt.visible&&u.push(b,mt,yt,B,ot.z,null)}}else if(b.isImmediateRenderObject)U&&ot.setFromMatrixPosition(b.matrixWorld).applyMatrix4(wt),u.push(b,null,b.material,B,ot.z,null);else if((b.isMesh||b.isLine||b.isPoints)&&(b.isSkinnedMesh&&b.skeleton.frame!==Pt.render.frame&&(b.skeleton.update(),b.skeleton.frame=Pt.render.frame),!b.frustumCulled||Q.intersectsObject(b))){U&&ot.setFromMatrixPosition(b.matrixWorld).applyMatrix4(wt);const mt=E.update(b),yt=b.material;if(Array.isArray(yt)){const vt=mt.groups;for(let Yt=0,zt=vt.length;Yt<zt;Yt++){const _t=vt[Yt],It=yt[_t.materialIndex];It&&It.visible&&u.push(b,mt,It,B,ot.z,_t)}}else yt.visible&&u.push(b,mt,yt,B,ot.z,null)}}const Tt=b.children;for(let mt=0,yt=Tt.length;mt<yt;mt++)Ml(Tt[mt],z,B,U)}function Sl(b,z,B){const U=z.isScene===!0?z.overrideMaterial:null;for(let K=0,Tt=b.length;K<Tt;K++){const mt=b[K],yt=mt.object,vt=mt.geometry,Yt=U===null?mt.material:U,zt=mt.group;if(B.isArrayCamera){const _t=B.cameras;for(let It=0,Ve=_t.length;It<Ve;It++){const kt=_t[It];yt.layers.test(kt.layers)&&(gt.viewport(D.copy(kt.viewport)),d.setupLightsView(kt),Tl(yt,z,kt,vt,Yt,zt))}}else Tl(yt,z,B,vt,Yt,zt)}}function Tl(b,z,B,U,K,Tt){if(b.onBeforeRender(_,z,B,U,K,Tt),b.modelViewMatrix.multiplyMatrices(B.matrixWorldInverse,b.matrixWorld),b.normalMatrix.getNormalMatrix(b.modelViewMatrix),b.isImmediateRenderObject){const mt=El(B,z,K,b);gt.setMaterial(K),at.reset(),md(b,mt)}else _.renderBufferDirect(B,z,U,K,b,Tt);b.onAfterRender(_,z,B,U,K,Tt)}function sn(b,z,B){z.isScene!==!0&&(z=Et);const U=q.get(b),K=d.state.lights,Tt=d.state.shadowsArray,mt=K.state.version,yt=w.getParameters(b,K.state,Tt,z,B),vt=w.getProgramCacheKey(yt);let Yt=U.program,zt=!0;if(U.environment=b.isMeshStandardMaterial?z.environment:null,U.fog=z.fog,U.envMap=$.get(b.envMap||U.environment),Yt===void 0)b.addEventListener("dispose",bl);else if(Yt.cacheKey!==vt)wl(b);else if(U.lightsStateVersion!==mt)zt=!1;else{if(yt.shaderID!==void 0)return;zt=!1}zt&&(yt.uniforms=w.getUniforms(b),b.onBeforeCompile(yt,_),Yt=w.acquireProgram(yt,vt),U.program=Yt,U.uniforms=yt.uniforms,U.outputEncoding=yt.outputEncoding);const _t=U.uniforms;(!b.isShaderMaterial&&!b.isRawShaderMaterial||b.clipping===!0)&&(U.numClippingPlanes=X.numPlanes,U.numIntersection=X.numIntersection,_t.clippingPlanes=X.uniform),U.needsLights=xd(b),U.lightsStateVersion=mt,U.needsLights&&(_t.ambientLightColor.value=K.state.ambient,_t.lightProbe.value=K.state.probe,_t.directionalLights.value=K.state.directional,_t.directionalLightShadows.value=K.state.directionalShadow,_t.spotLights.value=K.state.spot,_t.spotLightShadows.value=K.state.spotShadow,_t.rectAreaLights.value=K.state.rectArea,_t.ltc_1.value=K.state.rectAreaLTC1,_t.ltc_2.value=K.state.rectAreaLTC2,_t.pointLights.value=K.state.point,_t.pointLightShadows.value=K.state.pointShadow,_t.hemisphereLights.value=K.state.hemi,_t.directionalShadowMap.value=K.state.directionalShadowMap,_t.directionalShadowMatrix.value=K.state.directionalShadowMatrix,_t.spotShadowMap.value=K.state.spotShadowMap,_t.spotShadowMatrix.value=K.state.spotShadowMatrix,_t.pointShadowMap.value=K.state.pointShadowMap,_t.pointShadowMatrix.value=K.state.pointShadowMatrix);const It=U.program.getUniforms(),Ve=Dn.seqWithValue(It.seq,_t);U.uniformsList=Ve}function El(b,z,B,U){z.isScene!==!0&&(z=Et),Z.resetTextureUnits();const K=z.fog,Tt=B.isMeshStandardMaterial?z.environment:null,mt=M===null?_.outputEncoding:M.texture.encoding,yt=$.get(B.envMap||Tt),vt=q.get(B),Yt=d.state.lights;if(it===!0&&(et===!0||b!==T)){const Qt=b===T&&B.id===y;X.setState(B,b,Qt)}B.version===vt.__version?(B.fog&&vt.fog!==K||vt.environment!==Tt||vt.needsLights&&vt.lightsStateVersion!==Yt.state.version||vt.numClippingPlanes!==void 0&&(vt.numClippingPlanes!==X.numPlanes||vt.numIntersection!==X.numIntersection)||vt.outputEncoding!==mt||vt.envMap!==yt)&&sn(B,z,U):(sn(B,z,U),vt.__version=B.version);let zt=!1,_t=!1,It=!1;const Ve=vt.program,kt=Ve.getUniforms(),on=vt.uniforms;if(gt.useProgram(Ve.program)&&(zt=!0,_t=!0,It=!0),B.id!==y&&(y=B.id,_t=!0),zt||T!==b){if(kt.setValue(H,"projectionMatrix",b.projectionMatrix),Rt.logarithmicDepthBuffer&&kt.setValue(H,"logDepthBufFC",2/(Math.log(b.far+1)/Math.LN2)),T!==b&&(T=b,_t=!0,It=!0),B.isShaderMaterial||B.isMeshPhongMaterial||B.isMeshToonMaterial||B.isMeshStandardMaterial||B.envMap){const Qt=kt.map.cameraPosition;Qt!==void 0&&Qt.setValue(H,ot.setFromMatrixPosition(b.matrixWorld))}(B.isMeshPhongMaterial||B.isMeshToonMaterial||B.isMeshLambertMaterial||B.isMeshBasicMaterial||B.isMeshStandardMaterial||B.isShaderMaterial)&&kt.setValue(H,"isOrthographic",b.isOrthographicCamera===!0),(B.isMeshPhongMaterial||B.isMeshToonMaterial||B.isMeshLambertMaterial||B.isMeshBasicMaterial||B.isMeshStandardMaterial||B.isShaderMaterial||B.isShadowMaterial||B.skinning)&&kt.setValue(H,"viewMatrix",b.matrixWorldInverse)}if(B.skinning){kt.setOptional(H,U,"bindMatrix"),kt.setOptional(H,U,"bindMatrixInverse");const Qt=U.skeleton;if(Qt){const lo=Qt.bones;if(Rt.floatVertexTextures){if(Qt.boneTexture===null){let xe=Math.sqrt(lo.length*4);xe=bt.ceilPowerOfTwo(xe),xe=Math.max(xe,4);const $i=new Float32Array(xe*xe*4);$i.set(Qt.boneMatrices);const oi=new ol($i,xe,xe,Ye,Tn);Qt.boneMatrices=$i,Qt.boneTexture=oi,Qt.boneTextureSize=xe}kt.setValue(H,"boneTexture",Qt.boneTexture,Z),kt.setValue(H,"boneTextureSize",Qt.boneTextureSize)}else kt.setOptional(H,Qt,"boneMatrices")}}return(_t||vt.receiveShadow!==U.receiveShadow)&&(vt.receiveShadow=U.receiveShadow,kt.setValue(H,"receiveShadow",U.receiveShadow)),_t&&(kt.setValue(H,"toneMappingExposure",_.toneMappingExposure),vt.needsLights&&_d(on,It),K&&B.fog&&V.refreshFogUniforms(on,K),V.refreshMaterialUniforms(on,B,I,k),Dn.upload(H,vt.uniformsList,on,Z)),B.isShaderMaterial&&B.uniformsNeedUpdate===!0&&(Dn.upload(H,vt.uniformsList,on,Z),B.uniformsNeedUpdate=!1),B.isSpriteMaterial&&kt.setValue(H,"center",U.center),kt.setValue(H,"modelViewMatrix",U.modelViewMatrix),kt.setValue(H,"normalMatrix",U.normalMatrix),kt.setValue(H,"modelMatrix",U.matrixWorld),Ve}function _d(b,z){b.ambientLightColor.needsUpdate=z,b.lightProbe.needsUpdate=z,b.directionalLights.needsUpdate=z,b.directionalLightShadows.needsUpdate=z,b.pointLights.needsUpdate=z,b.pointLightShadows.needsUpdate=z,b.spotLights.needsUpdate=z,b.spotLightShadows.needsUpdate=z,b.rectAreaLights.needsUpdate=z,b.hemisphereLights.needsUpdate=z}function xd(b){return b.isMeshLambertMaterial||b.isMeshToonMaterial||b.isMeshPhongMaterial||b.isMeshStandardMaterial||b.isShadowMaterial||b.isShaderMaterial&&b.lights===!0}this.setFramebuffer=function(b){g!==b&&M===null&&H.bindFramebuffer(36160,b),g=b},this.getActiveCubeFace=function(){return m},this.getActiveMipmapLevel=function(){return S},this.getRenderTarget=function(){return M},this.setRenderTarget=function(b,z=0,B=0){M=b,m=z,S=B,b&&q.get(b).__webglFramebuffer===void 0&&Z.setupRenderTarget(b);let U=g,K=!1,Tt=!1;if(b){const mt=b.texture;(mt.isDataTexture3D||mt.isDataTexture2DArray)&&(Tt=!0);const yt=q.get(b).__webglFramebuffer;b.isWebGLCubeRenderTarget?(U=yt[z],K=!0):b.isWebGLMultisampleRenderTarget?U=q.get(b).__webglMultisampledFramebuffer:U=yt,D.copy(b.viewport),L.copy(b.scissor),F=b.scissorTest}else D.copy(O).multiplyScalar(I).floor(),L.copy(G).multiplyScalar(I).floor(),F=Y;if(v!==U&&(H.bindFramebuffer(36160,U),v=U),gt.viewport(D),gt.scissor(L),gt.setScissorTest(F),K){const mt=q.get(b.texture);H.framebufferTexture2D(36160,36064,34069+z,mt.__webglTexture,B)}else if(Tt){const mt=q.get(b.texture),yt=z||0;H.framebufferTextureLayer(36160,36064,mt.__webglTexture,B||0,yt)}},this.readRenderTargetPixels=function(b,z,B,U,K,Tt,mt){if(!(b&&b.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let yt=q.get(b).__webglFramebuffer;if(b.isWebGLCubeRenderTarget&&mt!==void 0&&(yt=yt[mt]),yt){let vt=!1;yt!==v&&(H.bindFramebuffer(36160,yt),vt=!0);try{const Yt=b.texture,zt=Yt.format,_t=Yt.type;if(zt!==Ye&&ft.convert(zt)!==H.getParameter(35739)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const It=_t===Ns&&(Lt.has("EXT_color_buffer_half_float")||Rt.isWebGL2&&Lt.has("EXT_color_buffer_float"));if(_t!==el&&ft.convert(_t)!==H.getParameter(35738)&&!(_t===Tn&&(Rt.isWebGL2||Lt.has("OES_texture_float")||Lt.has("WEBGL_color_buffer_float")))&&!It){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}H.checkFramebufferStatus(36160)===36053?z>=0&&z<=b.width-U&&B>=0&&B<=b.height-K&&H.readPixels(z,B,U,K,ft.convert(zt),ft.convert(_t),Tt):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{vt&&H.bindFramebuffer(36160,v)}}},this.copyFramebufferToTexture=function(b,z,B=0){const U=Math.pow(2,-B),K=Math.floor(z.image.width*U),Tt=Math.floor(z.image.height*U),mt=ft.convert(z.format);Z.setTexture2D(z,0),H.copyTexImage2D(3553,B,mt,b.x,b.y,K,Tt,0),gt.unbindTexture()},this.copyTextureToTexture=function(b,z,B,U=0){const K=z.image.width,Tt=z.image.height,mt=ft.convert(B.format),yt=ft.convert(B.type);Z.setTexture2D(B,0),H.pixelStorei(37440,B.flipY),H.pixelStorei(37441,B.premultiplyAlpha),H.pixelStorei(3317,B.unpackAlignment),z.isDataTexture?H.texSubImage2D(3553,U,b.x,b.y,K,Tt,mt,yt,z.image.data):z.isCompressedTexture?H.compressedTexSubImage2D(3553,U,b.x,b.y,z.mipmaps[0].width,z.mipmaps[0].height,mt,z.mipmaps[0].data):H.texSubImage2D(3553,U,b.x,b.y,mt,yt,z.image),U===0&&B.generateMipmaps&&H.generateMipmap(3553),gt.unbindTexture()},this.copyTextureToTexture3D=function(b,z,B,U,K=0){if(_.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const{width:Tt,height:mt,data:yt}=B.image,vt=ft.convert(U.format),Yt=ft.convert(U.type);let zt;if(U.isDataTexture3D)Z.setTexture3D(U,0),zt=32879;else if(U.isDataTexture2DArray)Z.setTexture2DArray(U,0),zt=35866;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}H.pixelStorei(37440,U.flipY),H.pixelStorei(37441,U.premultiplyAlpha),H.pixelStorei(3317,U.unpackAlignment);const _t=H.getParameter(3314),It=H.getParameter(32878),Ve=H.getParameter(3316),kt=H.getParameter(3315),on=H.getParameter(32877);H.pixelStorei(3314,Tt),H.pixelStorei(32878,mt),H.pixelStorei(3316,b.min.x),H.pixelStorei(3315,b.min.y),H.pixelStorei(32877,b.min.z),H.texSubImage3D(zt,K,z.x,z.y,z.z,b.max.x-b.min.x+1,b.max.y-b.min.y+1,b.max.z-b.min.z+1,vt,Yt,yt),H.pixelStorei(3314,_t),H.pixelStorei(32878,It),H.pixelStorei(3316,Ve),H.pixelStorei(3315,kt),H.pixelStorei(32877,on),K===0&&U.generateMipmaps&&H.generateMipmap(zt),gt.unbindTexture()},this.initTexture=function(b){Z.setTexture2D(b,0),gt.unbindTexture()},this.resetState=function(){gt.reset(),at.reset()},typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}class Tx extends Nt{}Tx.prototype.isWebGL1Renderer=!0;class al extends xt{constructor(){super(),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,e){return super.copy(t,e),t.background!==null&&(this.background=t.background.clone()),t.environment!==null&&(this.environment=t.environment.clone()),t.fog!==null&&(this.fog=t.fog.clone()),t.overrideMaterial!==null&&(this.overrideMaterial=t.overrideMaterial.clone()),this.autoUpdate=t.autoUpdate,this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const e=super.toJSON(t);return this.background!==null&&(e.object.background=this.background.toJSON(t)),this.environment!==null&&(e.object.environment=this.environment.toJSON(t)),this.fog!==null&&(e.object.fog=this.fog.toJSON()),e}}al.prototype.isScene=!0;function Oe(n,t){this.array=n,this.stride=t,this.count=n!==void 0?n.length/t:0,this.usage=$s,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=bt.generateUUID()}Object.defineProperty(Oe.prototype,"needsUpdate",{set:function(n){n===!0&&this.version++}});Object.assign(Oe.prototype,{isInterleavedBuffer:!0,onUploadCallback:function(){},setUsage:function(n){return this.usage=n,this},copy:function(n){return this.array=new n.array.constructor(n.array),this.count=n.count,this.stride=n.stride,this.usage=n.usage,this},copyAt:function(n,t,e){n*=this.stride,e*=t.stride;for(let i=0,r=this.stride;i<r;i++)this.array[n+i]=t.array[e+i];return this},set:function(n,t=0){return this.array.set(n,t),this},clone:function(n){n.arrayBuffers===void 0&&(n.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=bt.generateUUID()),n.arrayBuffers[this.array.buffer._uuid]===void 0&&(n.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const t=new this.array.constructor(n.arrayBuffers[this.array.buffer._uuid]),e=new Oe(t,this.stride);return e.setUsage(this.usage),e},onUpload:function(n){return this.onUploadCallback=n,this},toJSON:function(n){return n.arrayBuffers===void 0&&(n.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=bt.generateUUID()),n.arrayBuffers[this.array.buffer._uuid]===void 0&&(n.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}});const Wn=new A;function Br(n,t,e,i){this.name="",this.data=n,this.itemSize=t,this.offset=e,this.normalized=i===!0}Object.defineProperties(Br.prototype,{count:{get:function(){return this.data.count}},array:{get:function(){return this.data.array}},needsUpdate:{set:function(n){this.data.needsUpdate=n}}});Object.assign(Br.prototype,{isInterleavedBufferAttribute:!0,applyMatrix4:function(n){for(let t=0,e=this.data.count;t<e;t++)Wn.x=this.getX(t),Wn.y=this.getY(t),Wn.z=this.getZ(t),Wn.applyMatrix4(n),this.setXYZ(t,Wn.x,Wn.y,Wn.z);return this},setX:function(n,t){return this.data.array[n*this.data.stride+this.offset]=t,this},setY:function(n,t){return this.data.array[n*this.data.stride+this.offset+1]=t,this},setZ:function(n,t){return this.data.array[n*this.data.stride+this.offset+2]=t,this},setW:function(n,t){return this.data.array[n*this.data.stride+this.offset+3]=t,this},getX:function(n){return this.data.array[n*this.data.stride+this.offset]},getY:function(n){return this.data.array[n*this.data.stride+this.offset+1]},getZ:function(n){return this.data.array[n*this.data.stride+this.offset+2]},getW:function(n){return this.data.array[n*this.data.stride+this.offset+3]},setXY:function(n,t,e){return n=n*this.data.stride+this.offset,this.data.array[n+0]=t,this.data.array[n+1]=e,this},setXYZ:function(n,t,e,i){return n=n*this.data.stride+this.offset,this.data.array[n+0]=t,this.data.array[n+1]=e,this.data.array[n+2]=i,this},setXYZW:function(n,t,e,i,r){return n=n*this.data.stride+this.offset,this.data.array[n+0]=t,this.data.array[n+1]=e,this.data.array[n+2]=i,this.data.array[n+3]=r,this},clone:function(n){if(n===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let e=0;e<this.count;e++){const i=e*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)t.push(this.data.array[i+r])}return new Mt(new this.array.constructor(t),this.itemSize,this.normalized)}else return n.interleavedBuffers===void 0&&(n.interleavedBuffers={}),n.interleavedBuffers[this.data.uuid]===void 0&&(n.interleavedBuffers[this.data.uuid]=this.data.clone(n)),new Br(n.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)},toJSON:function(n){if(n===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let e=0;e<this.count;e++){const i=e*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)t.push(this.data.array[i+r])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}else return n.interleavedBuffers===void 0&&(n.interleavedBuffers={}),n.interleavedBuffers[this.data.uuid]===void 0&&(n.interleavedBuffers[this.data.uuid]=this.data.toJSON(n)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}});class zu extends Xt{constructor(t){super(),this.type="SpriteMaterial",this.color=new pt(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.rotation=t.rotation,this.sizeAttenuation=t.sizeAttenuation,this}}zu.prototype.isSpriteMaterial=!0;let bi;const or=new A,wi=new A,Mi=new A,Si=new J,ar=new J,ku=new dt,ds=new A,lr=new A,fs=new A,Ic=new J,Go=new J,Fc=new J;class Ex extends xt{constructor(t){if(super(),this.type="Sprite",bi===void 0){bi=new Dt;const e=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),i=new Oe(e,5);bi.setIndex([0,1,2,0,2,3]),bi.setAttribute("position",new Br(i,3,0,!1)),bi.setAttribute("uv",new Br(i,2,3,!1))}this.geometry=bi,this.material=t!==void 0?t:new zu,this.center=new J(.5,.5)}raycast(t,e){t.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),wi.setFromMatrixScale(this.matrixWorld),ku.copy(t.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse,this.matrixWorld),Mi.setFromMatrixPosition(this.modelViewMatrix),t.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&wi.multiplyScalar(-Mi.z);const i=this.material.rotation;let r,s;i!==0&&(s=Math.cos(i),r=Math.sin(i));const o=this.center;ps(ds.set(-.5,-.5,0),Mi,o,wi,r,s),ps(lr.set(.5,-.5,0),Mi,o,wi,r,s),ps(fs.set(.5,.5,0),Mi,o,wi,r,s),Ic.set(0,0),Go.set(1,0),Fc.set(1,1);let a=t.ray.intersectTriangle(ds,lr,fs,!1,or);if(a===null&&(ps(lr.set(-.5,.5,0),Mi,o,wi,r,s),Go.set(0,1),a=t.ray.intersectTriangle(ds,fs,lr,!1,or),a===null))return;const l=t.ray.origin.distanceTo(or);l<t.near||l>t.far||e.push({distance:l,point:or.clone(),uv:Jt.getUV(or,ds,lr,fs,Ic,Go,Fc,new J),face:null,object:this})}copy(t){return super.copy(t),t.center!==void 0&&this.center.copy(t.center),this.material=t.material,this}}Ex.prototype.isSprite=!0;function ps(n,t,e,i,r,s){Si.subVectors(n,e).addScalar(.5).multiply(i),r!==void 0?(ar.x=s*Si.x-r*Si.y,ar.y=r*Si.x+s*Si.y):ar.copy(Si),n.copy(t),n.x+=ar.x,n.y+=ar.y,n.applyMatrix4(ku)}const Nc=new A,Oc=new Ft,Bc=new Ft,Ax=new A,zc=new dt;function va(n,t){ne.call(this,n,t),this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new dt,this.bindMatrixInverse=new dt}va.prototype=Object.assign(Object.create(ne.prototype),{constructor:va,isSkinnedMesh:!0,copy:function(n){return ne.prototype.copy.call(this,n),this.bindMode=n.bindMode,this.bindMatrix.copy(n.bindMatrix),this.bindMatrixInverse.copy(n.bindMatrixInverse),this.skeleton=n.skeleton,this},bind:function(n,t){this.skeleton=n,t===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.copy(t).invert()},pose:function(){this.skeleton.pose()},normalizeSkinWeights:function(){const n=new Ft,t=this.geometry.attributes.skinWeight;for(let e=0,i=t.count;e<i;e++){n.x=t.getX(e),n.y=t.getY(e),n.z=t.getZ(e),n.w=t.getW(e);const r=1/n.manhattanLength();r!==1/0?n.multiplyScalar(r):n.set(1,0,0,0),t.setXYZW(e,n.x,n.y,n.z,n.w)}},updateMatrixWorld:function(n){ne.prototype.updateMatrixWorld.call(this,n),this.bindMode==="attached"?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode==="detached"?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)},boneTransform:function(n,t){const e=this.skeleton,i=this.geometry;Oc.fromBufferAttribute(i.attributes.skinIndex,n),Bc.fromBufferAttribute(i.attributes.skinWeight,n),Nc.fromBufferAttribute(i.attributes.position,n).applyMatrix4(this.bindMatrix),t.set(0,0,0);for(let r=0;r<4;r++){const s=Bc.getComponent(r);if(s!==0){const o=Oc.getComponent(r);zc.multiplyMatrices(e.bones[o].matrixWorld,e.boneInverses[o]),t.addScaledVector(Ax.copy(Nc).applyMatrix4(zc),s)}}return t.applyMatrix4(this.bindMatrixInverse)}});function kc(){xt.call(this),this.type="Bone"}kc.prototype=Object.assign(Object.create(xt.prototype),{constructor:kc,isBone:!0});const Uc=new dt,Hc=new dt,ms=[],cr=new ne;function Gc(n,t,e){ne.call(this,n,t),this.instanceMatrix=new Mt(new Float32Array(e*16),16),this.instanceColor=null,this.count=e,this.frustumCulled=!1}Gc.prototype=Object.assign(Object.create(ne.prototype),{constructor:Gc,isInstancedMesh:!0,copy:function(n){return ne.prototype.copy.call(this,n),this.instanceMatrix.copy(n.instanceMatrix),n.instanceColor!==null&&(this.instanceColor=n.instanceColor.clone()),this.count=n.count,this},getColorAt:function(n,t){t.fromArray(this.instanceColor.array,n*3)},getMatrixAt:function(n,t){t.fromArray(this.instanceMatrix.array,n*16)},raycast:function(n,t){const e=this.matrixWorld,i=this.count;if(cr.geometry=this.geometry,cr.material=this.material,cr.material!==void 0)for(let r=0;r<i;r++){this.getMatrixAt(r,Uc),Hc.multiplyMatrices(e,Uc),cr.matrixWorld=Hc,cr.raycast(n,ms);for(let s=0,o=ms.length;s<o;s++){const a=ms[s];a.instanceId=r,a.object=this,t.push(a)}ms.length=0}},setColorAt:function(n,t){this.instanceColor===null&&(this.instanceColor=new Mt(new Float32Array(this.count*3),3)),t.toArray(this.instanceColor.array,n*3)},setMatrixAt:function(n,t){t.toArray(this.instanceMatrix.array,n*16)},updateMorphTargets:function(){},dispose:function(){this.dispatchEvent({type:"dispose"})}});class qr extends Xt{constructor(t){super(),this.type="LineBasicMaterial",this.color=new pt(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.morphTargets=!1,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this.morphTargets=t.morphTargets,this}}qr.prototype.isLineBasicMaterial=!0;const Vc=new A,Wc=new A,qc=new dt,Vo=new si,gs=new ji;function zr(n=new Dt,t=new qr){xt.call(this),this.type="Line",this.geometry=n,this.material=t,this.updateMorphTargets()}zr.prototype=Object.assign(Object.create(xt.prototype),{constructor:zr,isLine:!0,copy:function(n){return xt.prototype.copy.call(this,n),this.material=n.material,this.geometry=n.geometry,this},computeLineDistances:function(){const n=this.geometry;if(n.isBufferGeometry)if(n.index===null){const t=n.attributes.position,e=[0];for(let i=1,r=t.count;i<r;i++)Vc.fromBufferAttribute(t,i-1),Wc.fromBufferAttribute(t,i),e[i]=e[i-1],e[i]+=Vc.distanceTo(Wc);n.setAttribute("lineDistance",new Vt(e,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else n.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this},raycast:function(n,t){const e=this.geometry,i=this.matrixWorld,r=n.params.Line.threshold;if(e.boundingSphere===null&&e.computeBoundingSphere(),gs.copy(e.boundingSphere),gs.applyMatrix4(i),gs.radius+=r,n.ray.intersectsSphere(gs)===!1)return;qc.copy(i).invert(),Vo.copy(n.ray).applyMatrix4(qc);const s=r/((this.scale.x+this.scale.y+this.scale.z)/3),o=s*s,a=new A,l=new A,c=new A,h=new A,u=this.isLineSegments?2:1;if(e.isBufferGeometry){const d=e.index,p=e.attributes.position;if(d!==null){const _=d.array;for(let x=0,g=_.length-1;x<g;x+=u){const m=_[x],S=_[x+1];if(a.fromBufferAttribute(p,m),l.fromBufferAttribute(p,S),Vo.distanceSqToSegment(a,l,h,c)>o)continue;h.applyMatrix4(this.matrixWorld);const v=n.ray.origin.distanceTo(h);v<n.near||v>n.far||t.push({distance:v,point:c.clone().applyMatrix4(this.matrixWorld),index:x,face:null,faceIndex:null,object:this})}}else for(let _=0,x=p.count-1;_<x;_+=u){if(a.fromBufferAttribute(p,_),l.fromBufferAttribute(p,_+1),Vo.distanceSqToSegment(a,l,h,c)>o)continue;h.applyMatrix4(this.matrixWorld);const m=n.ray.origin.distanceTo(h);m<n.near||m>n.far||t.push({distance:m,point:c.clone().applyMatrix4(this.matrixWorld),index:_,face:null,faceIndex:null,object:this})}}else e.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")},updateMorphTargets:function(){const n=this.geometry;if(n.isBufferGeometry){const t=n.morphAttributes,e=Object.keys(t);if(e.length>0){const i=t[e[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,s=i.length;r<s;r++){const o=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=r}}}}else{const t=n.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}});const jc=new A,Xc=new A;function Us(n,t){zr.call(this,n,t),this.type="LineSegments"}Us.prototype=Object.assign(Object.create(zr.prototype),{constructor:Us,isLineSegments:!0,computeLineDistances:function(){const n=this.geometry;if(n.isBufferGeometry)if(n.index===null){const t=n.attributes.position,e=[];for(let i=0,r=t.count;i<r;i+=2)jc.fromBufferAttribute(t,i),Xc.fromBufferAttribute(t,i+1),e[i]=i===0?0:e[i-1],e[i+1]=e[i]+jc.distanceTo(Xc);n.setAttribute("lineDistance",new Vt(e,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else n.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}});class Lx extends zr{constructor(t,e){super(t,e),this.type="LineLoop"}}Lx.prototype.isLineLoop=!0;class Uu extends Xt{constructor(t){super(),this.type="PointsMaterial",this.color=new pt(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.morphTargets=!1,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this.morphTargets=t.morphTargets,this}}Uu.prototype.isPointsMaterial=!0;const Yc=new dt,ba=new si,_s=new ji,xs=new A;function Zc(n=new Dt,t=new Uu){xt.call(this),this.type="Points",this.geometry=n,this.material=t,this.updateMorphTargets()}Zc.prototype=Object.assign(Object.create(xt.prototype),{constructor:Zc,isPoints:!0,copy:function(n){return xt.prototype.copy.call(this,n),this.material=n.material,this.geometry=n.geometry,this},raycast:function(n,t){const e=this.geometry,i=this.matrixWorld,r=n.params.Points.threshold;if(e.boundingSphere===null&&e.computeBoundingSphere(),_s.copy(e.boundingSphere),_s.applyMatrix4(i),_s.radius+=r,n.ray.intersectsSphere(_s)===!1)return;Yc.copy(i).invert(),ba.copy(n.ray).applyMatrix4(Yc);const s=r/((this.scale.x+this.scale.y+this.scale.z)/3),o=s*s;if(e.isBufferGeometry){const a=e.index,c=e.attributes.position;if(a!==null){const h=a.array;for(let u=0,d=h.length;u<d;u++){const f=h[u];xs.fromBufferAttribute(c,f),Jc(xs,f,o,i,n,t,this)}}else for(let h=0,u=c.count;h<u;h++)xs.fromBufferAttribute(c,h),Jc(xs,h,o,i,n,t,this)}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")},updateMorphTargets:function(){const n=this.geometry;if(n.isBufferGeometry){const t=n.morphAttributes,e=Object.keys(t);if(e.length>0){const i=t[e[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,s=i.length;r<s;r++){const o=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=r}}}}else{const t=n.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}});function Jc(n,t,e,i,r,s,o){const a=ba.distanceSqToPoint(n);if(a<e){const l=new A;ba.closestPointToPoint(n,l),l.applyMatrix4(i);const c=r.ray.origin.distanceTo(l);if(c<r.near||c>r.far)return;s.push({distance:c,distanceToRay:Math.sqrt(a),point:l,index:t,face:null,object:o})}}class Cx extends le{constructor(t,e,i,r,s,o,a,l,c){super(t,e,i,r,s,o,a,l,c),this.format=a!==void 0?a:Kn,this.minFilter=o!==void 0?o:oe,this.magFilter=s!==void 0?s:oe,this.generateMipmaps=!1;const h=this;function u(){h.needsUpdate=!0,t.requestVideoFrameCallback(u)}"requestVideoFrameCallback"in t&&t.requestVideoFrameCallback(u)}clone(){return new this.constructor(this.image).copy(this)}update(){const t=this.image;"requestVideoFrameCallback"in t===!1&&t.readyState>=t.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}Cx.prototype.isVideoTexture=!0;class Hu extends le{constructor(t,e,i,r,s,o,a,l,c,h,u,d){super(null,o,a,l,c,h,r,s,u,d),this.image={width:e,height:i},this.mipmaps=t,this.flipY=!1,this.generateMipmaps=!1}}Hu.prototype.isCompressedTexture=!0;class Rx extends le{constructor(t,e,i,r,s,o,a,l,c){super(t,e,i,r,s,o,a,l,c),this.needsUpdate=!0}}Rx.prototype.isCanvasTexture=!0;class Px extends le{constructor(t,e,i,r,s,o,a,l,c,h){if(h=h!==void 0?h:Fi,h!==Fi&&h!==Ir)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");i===void 0&&h===Fi&&(i=Fs),i===void 0&&h===Ir&&(i=wr),super(null,r,s,o,a,l,h,i,c),this.image={width:t,height:e},this.magFilter=a!==void 0?a:pe,this.minFilter=l!==void 0?l:pe,this.flipY=!1,this.generateMipmaps=!1}}Px.prototype.isDepthTexture=!0;new A;new A;new A;new Jt;const Dx={triangulate:function(n,t,e){e=e||2;const i=t&&t.length,r=i?t[0]*e:n.length;let s=Gu(n,0,r,e,!0);const o=[];if(!s||s.next===s.prev)return o;let a,l,c,h,u,d,f;if(i&&(s=Bx(n,t,s,e)),n.length>80*e){a=c=n[0],l=h=n[1];for(let p=e;p<r;p+=e)u=n[p],d=n[p+1],u<a&&(a=u),d<l&&(l=d),u>c&&(c=u),d>h&&(h=d);f=Math.max(c-a,h-l),f=f!==0?1/f:0}return kr(s,o,e,a,l,f),o}};function Gu(n,t,e,i,r){let s,o;if(r===Yx(n,t,e,i)>0)for(s=t;s<e;s+=i)o=Qc(s,n[s],n[s+1],o);else for(s=e-i;s>=t;s-=i)o=Qc(s,n[s],n[s+1],o);return o&&eo(o,o.next)&&(Hr(o),o=o.next),o}function On(n,t){if(!n)return n;t||(t=n);let e=n,i;do if(i=!1,!e.steiner&&(eo(e,e.next)||jt(e.prev,e,e.next)===0)){if(Hr(e),e=t=e.prev,e===e.next)break;i=!0}else e=e.next;while(i||e!==t);return t}function kr(n,t,e,i,r,s,o){if(!n)return;!o&&s&&Gx(n,i,r,s);let a=n,l,c;for(;n.prev!==n.next;){if(l=n.prev,c=n.next,s?Fx(n,i,r,s):Ix(n)){t.push(l.i/e),t.push(n.i/e),t.push(c.i/e),Hr(n),n=c.next,a=c.next;continue}if(n=c,n===a){o?o===1?(n=Nx(On(n),t,e),kr(n,t,e,i,r,s,2)):o===2&&Ox(n,t,e,i,r,s):kr(On(n),t,e,i,r,s,1);break}}}function Ix(n){const t=n.prev,e=n,i=n.next;if(jt(t,e,i)>=0)return!1;let r=n.next.next;for(;r!==n.prev;){if(Ri(t.x,t.y,e.x,e.y,i.x,i.y,r.x,r.y)&&jt(r.prev,r,r.next)>=0)return!1;r=r.next}return!0}function Fx(n,t,e,i){const r=n.prev,s=n,o=n.next;if(jt(r,s,o)>=0)return!1;const a=r.x<s.x?r.x<o.x?r.x:o.x:s.x<o.x?s.x:o.x,l=r.y<s.y?r.y<o.y?r.y:o.y:s.y<o.y?s.y:o.y,c=r.x>s.x?r.x>o.x?r.x:o.x:s.x>o.x?s.x:o.x,h=r.y>s.y?r.y>o.y?r.y:o.y:s.y>o.y?s.y:o.y,u=wa(a,l,t,e,i),d=wa(c,h,t,e,i);let f=n.prevZ,p=n.nextZ;for(;f&&f.z>=u&&p&&p.z<=d;){if(f!==n.prev&&f!==n.next&&Ri(r.x,r.y,s.x,s.y,o.x,o.y,f.x,f.y)&&jt(f.prev,f,f.next)>=0||(f=f.prevZ,p!==n.prev&&p!==n.next&&Ri(r.x,r.y,s.x,s.y,o.x,o.y,p.x,p.y)&&jt(p.prev,p,p.next)>=0))return!1;p=p.nextZ}for(;f&&f.z>=u;){if(f!==n.prev&&f!==n.next&&Ri(r.x,r.y,s.x,s.y,o.x,o.y,f.x,f.y)&&jt(f.prev,f,f.next)>=0)return!1;f=f.prevZ}for(;p&&p.z<=d;){if(p!==n.prev&&p!==n.next&&Ri(r.x,r.y,s.x,s.y,o.x,o.y,p.x,p.y)&&jt(p.prev,p,p.next)>=0)return!1;p=p.nextZ}return!0}function Nx(n,t,e){let i=n;do{const r=i.prev,s=i.next.next;!eo(r,s)&&Vu(r,i,i.next,s)&&Ur(r,s)&&Ur(s,r)&&(t.push(r.i/e),t.push(i.i/e),t.push(s.i/e),Hr(i),Hr(i.next),i=n=s),i=i.next}while(i!==n);return On(i)}function Ox(n,t,e,i,r,s){let o=n;do{let a=o.next.next;for(;a!==o.prev;){if(o.i!==a.i&&qx(o,a)){let l=Wu(o,a);o=On(o,o.next),l=On(l,l.next),kr(o,t,e,i,r,s),kr(l,t,e,i,r,s);return}a=a.next}o=o.next}while(o!==n)}function Bx(n,t,e,i){const r=[];let s,o,a,l,c;for(s=0,o=t.length;s<o;s++)a=t[s]*i,l=s<o-1?t[s+1]*i:n.length,c=Gu(n,a,l,i,!1),c===c.next&&(c.steiner=!0),r.push(Wx(c));for(r.sort(zx),s=0;s<r.length;s++)kx(r[s],e),e=On(e,e.next);return e}function zx(n,t){return n.x-t.x}function kx(n,t){if(t=Ux(n,t),t){const e=Wu(t,n);On(t,t.next),On(e,e.next)}}function Ux(n,t){let e=t;const i=n.x,r=n.y;let s=-1/0,o;do{if(r<=e.y&&r>=e.next.y&&e.next.y!==e.y){const d=e.x+(r-e.y)*(e.next.x-e.x)/(e.next.y-e.y);if(d<=i&&d>s){if(s=d,d===i){if(r===e.y)return e;if(r===e.next.y)return e.next}o=e.x<e.next.x?e:e.next}}e=e.next}while(e!==t);if(!o)return null;if(i===s)return o;const a=o,l=o.x,c=o.y;let h=1/0,u;e=o;do i>=e.x&&e.x>=l&&i!==e.x&&Ri(r<c?i:s,r,l,c,r<c?s:i,r,e.x,e.y)&&(u=Math.abs(r-e.y)/(i-e.x),Ur(e,n)&&(u<h||u===h&&(e.x>o.x||e.x===o.x&&Hx(o,e)))&&(o=e,h=u)),e=e.next;while(e!==a);return o}function Hx(n,t){return jt(n.prev,n,t.prev)<0&&jt(t.next,n,n.next)<0}function Gx(n,t,e,i){let r=n;do r.z===null&&(r.z=wa(r.x,r.y,t,e,i)),r.prevZ=r.prev,r.nextZ=r.next,r=r.next;while(r!==n);r.prevZ.nextZ=null,r.prevZ=null,Vx(r)}function Vx(n){let t,e,i,r,s,o,a,l,c=1;do{for(e=n,n=null,s=null,o=0;e;){for(o++,i=e,a=0,t=0;t<c&&(a++,i=i.nextZ,!!i);t++);for(l=c;a>0||l>0&&i;)a!==0&&(l===0||!i||e.z<=i.z)?(r=e,e=e.nextZ,a--):(r=i,i=i.nextZ,l--),s?s.nextZ=r:n=r,r.prevZ=s,s=r;e=i}s.nextZ=null,c*=2}while(o>1);return n}function wa(n,t,e,i,r){return n=32767*(n-e)*r,t=32767*(t-i)*r,n=(n|n<<8)&16711935,n=(n|n<<4)&252645135,n=(n|n<<2)&858993459,n=(n|n<<1)&1431655765,t=(t|t<<8)&16711935,t=(t|t<<4)&252645135,t=(t|t<<2)&858993459,t=(t|t<<1)&1431655765,n|t<<1}function Wx(n){let t=n,e=n;do(t.x<e.x||t.x===e.x&&t.y<e.y)&&(e=t),t=t.next;while(t!==n);return e}function Ri(n,t,e,i,r,s,o,a){return(r-o)*(t-a)-(n-o)*(s-a)>=0&&(n-o)*(i-a)-(e-o)*(t-a)>=0&&(e-o)*(s-a)-(r-o)*(i-a)>=0}function qx(n,t){return n.next.i!==t.i&&n.prev.i!==t.i&&!jx(n,t)&&(Ur(n,t)&&Ur(t,n)&&Xx(n,t)&&(jt(n.prev,n,t.prev)||jt(n,t.prev,t))||eo(n,t)&&jt(n.prev,n,n.next)>0&&jt(t.prev,t,t.next)>0)}function jt(n,t,e){return(t.y-n.y)*(e.x-t.x)-(t.x-n.x)*(e.y-t.y)}function eo(n,t){return n.x===t.x&&n.y===t.y}function Vu(n,t,e,i){const r=vs(jt(n,t,e)),s=vs(jt(n,t,i)),o=vs(jt(e,i,n)),a=vs(jt(e,i,t));return!!(r!==s&&o!==a||r===0&&ys(n,e,t)||s===0&&ys(n,i,t)||o===0&&ys(e,n,i)||a===0&&ys(e,t,i))}function ys(n,t,e){return t.x<=Math.max(n.x,e.x)&&t.x>=Math.min(n.x,e.x)&&t.y<=Math.max(n.y,e.y)&&t.y>=Math.min(n.y,e.y)}function vs(n){return n>0?1:n<0?-1:0}function jx(n,t){let e=n;do{if(e.i!==n.i&&e.next.i!==n.i&&e.i!==t.i&&e.next.i!==t.i&&Vu(e,e.next,n,t))return!0;e=e.next}while(e!==n);return!1}function Ur(n,t){return jt(n.prev,n,n.next)<0?jt(n,t,n.next)>=0&&jt(n,n.prev,t)>=0:jt(n,t,n.prev)<0||jt(n,n.next,t)<0}function Xx(n,t){let e=n,i=!1;const r=(n.x+t.x)/2,s=(n.y+t.y)/2;do e.y>s!=e.next.y>s&&e.next.y!==e.y&&r<(e.next.x-e.x)*(s-e.y)/(e.next.y-e.y)+e.x&&(i=!i),e=e.next;while(e!==n);return i}function Wu(n,t){const e=new Ma(n.i,n.x,n.y),i=new Ma(t.i,t.x,t.y),r=n.next,s=t.prev;return n.next=t,t.prev=n,e.next=r,r.prev=e,i.next=e,e.prev=i,s.next=i,i.prev=s,i}function Qc(n,t,e,i){const r=new Ma(n,t,e);return i?(r.next=i.next,r.prev=i,i.next.prev=r,i.next=r):(r.prev=r,r.next=r),r}function Hr(n){n.next.prev=n.prev,n.prev.next=n.next,n.prevZ&&(n.prevZ.nextZ=n.nextZ),n.nextZ&&(n.nextZ.prevZ=n.prevZ)}function Ma(n,t,e){this.i=n,this.x=t,this.y=e,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function Yx(n,t,e,i){let r=0;for(let s=t,o=e-i;s<e;s+=i)r+=(n[o]-n[s])*(n[s+1]+n[o+1]),o=s;return r}const ei={area:function(n){const t=n.length;let e=0;for(let i=t-1,r=0;r<t;i=r++)e+=n[i].x*n[r].y-n[r].x*n[i].y;return e*.5},isClockWise:function(n){return ei.area(n)<0},triangulateShape:function(n,t){const e=[],i=[],r=[];$c(n),Kc(e,n);let s=n.length;t.forEach($c);for(let a=0;a<t.length;a++)i.push(s),s+=t[a].length,Kc(e,t[a]);const o=Dx.triangulate(e,i);for(let a=0;a<o.length;a+=3)r.push(o.slice(a,a+3));return r}};function $c(n){const t=n.length;t>2&&n[t-1].equals(n[0])&&n.pop()}function Kc(n,t){for(let e=0;e<t.length;e++)n.push(t[e].x),n.push(t[e].y)}class no extends Dt{constructor(t,e){super(),this.type="ExtrudeGeometry",this.parameters={shapes:t,options:e},t=Array.isArray(t)?t:[t];const i=this,r=[],s=[];for(let a=0,l=t.length;a<l;a++){const c=t[a];o(c)}this.setAttribute("position",new Vt(r,3)),this.setAttribute("uv",new Vt(s,2)),this.computeVertexNormals();function o(a){const l=[],c=e.curveSegments!==void 0?e.curveSegments:12,h=e.steps!==void 0?e.steps:1;let u=e.depth!==void 0?e.depth:100,d=e.bevelEnabled!==void 0?e.bevelEnabled:!0,f=e.bevelThickness!==void 0?e.bevelThickness:6,p=e.bevelSize!==void 0?e.bevelSize:f-2,_=e.bevelOffset!==void 0?e.bevelOffset:0,x=e.bevelSegments!==void 0?e.bevelSegments:3;const g=e.extrudePath,m=e.UVGenerator!==void 0?e.UVGenerator:Zx;e.amount!==void 0&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),u=e.amount);let S,M=!1,v,y,T,D;g&&(S=g.getSpacedPoints(h),M=!0,d=!1,v=g.computeFrenetFrames(h,!1),y=new A,T=new A,D=new A),d||(x=0,f=0,p=0,_=0);const L=a.extractPoints(c);let F=L.shape;const N=L.holes;if(!ei.isClockWise(F)){F=F.reverse();for(let q=0,Z=N.length;q<Z;q++){const $=N[q];ei.isClockWise($)&&(N[q]=$.reverse())}}const I=ei.triangulateShape(F,N),C=F;for(let q=0,Z=N.length;q<Z;q++){const $=N[q];F=F.concat($)}function P(q,Z,$){return Z||console.error("THREE.ExtrudeGeometry: vec does not exist"),Z.clone().multiplyScalar($).add(q)}const O=F.length,G=I.length;function Y(q,Z,$){let lt,rt,E;const w=q.x-Z.x,V=q.y-Z.y,W=$.x-q.x,R=$.y-q.y,X=w*w+V*V,nt=w*R-V*W;if(Math.abs(nt)>Number.EPSILON){const st=Math.sqrt(X),j=Math.sqrt(W*W+R*R),ut=Z.x-V/st,ft=Z.y+w/st,at=$.x-R/j,ct=$.y+W/j,ht=((at-ut)*R-(ct-ft)*W)/(w*R-V*W);lt=ut+w*ht-q.x,rt=ft+V*ht-q.y;const Wt=lt*lt+rt*rt;if(Wt<=2)return new J(lt,rt);E=Math.sqrt(Wt/2)}else{let st=!1;w>Number.EPSILON?W>Number.EPSILON&&(st=!0):w<-Number.EPSILON?W<-Number.EPSILON&&(st=!0):Math.sign(V)===Math.sign(R)&&(st=!0),st?(lt=-V,rt=w,E=Math.sqrt(X)):(lt=w,rt=V,E=Math.sqrt(X/2))}return new J(lt/E,rt/E)}const Q=[];for(let q=0,Z=C.length,$=Z-1,lt=q+1;q<Z;q++,$++,lt++)$===Z&&($=0),lt===Z&&(lt=0),Q[q]=Y(C[q],C[$],C[lt]);const it=[];let et,wt=Q.concat();for(let q=0,Z=N.length;q<Z;q++){const $=N[q];et=[];for(let lt=0,rt=$.length,E=rt-1,w=lt+1;lt<rt;lt++,E++,w++)E===rt&&(E=0),w===rt&&(w=0),et[lt]=Y($[lt],$[E],$[w]);it.push(et),wt=wt.concat(et)}for(let q=0;q<x;q++){const Z=q/x,$=f*Math.cos(Z*Math.PI/2),lt=p*Math.sin(Z*Math.PI/2)+_;for(let rt=0,E=C.length;rt<E;rt++){const w=P(C[rt],Q[rt],lt);Ht(w.x,w.y,-$)}for(let rt=0,E=N.length;rt<E;rt++){const w=N[rt];et=it[rt];for(let V=0,W=w.length;V<W;V++){const R=P(w[V],et[V],lt);Ht(R.x,R.y,-$)}}}const ot=p+_;for(let q=0;q<O;q++){const Z=d?P(F[q],wt[q],ot):F[q];M?(T.copy(v.normals[0]).multiplyScalar(Z.x),y.copy(v.binormals[0]).multiplyScalar(Z.y),D.copy(S[0]).add(T).add(y),Ht(D.x,D.y,D.z)):Ht(Z.x,Z.y,0)}for(let q=1;q<=h;q++)for(let Z=0;Z<O;Z++){const $=d?P(F[Z],wt[Z],ot):F[Z];M?(T.copy(v.normals[q]).multiplyScalar($.x),y.copy(v.binormals[q]).multiplyScalar($.y),D.copy(S[q]).add(T).add(y),Ht(D.x,D.y,D.z)):Ht($.x,$.y,u/h*q)}for(let q=x-1;q>=0;q--){const Z=q/x,$=f*Math.cos(Z*Math.PI/2),lt=p*Math.sin(Z*Math.PI/2)+_;for(let rt=0,E=C.length;rt<E;rt++){const w=P(C[rt],Q[rt],lt);Ht(w.x,w.y,u+$)}for(let rt=0,E=N.length;rt<E;rt++){const w=N[rt];et=it[rt];for(let V=0,W=w.length;V<W;V++){const R=P(w[V],et[V],lt);M?Ht(R.x,R.y+S[h-1].y,S[h-1].x+$):Ht(R.x,R.y,u+$)}}}Et(),Ct();function Et(){const q=r.length/3;if(d){let Z=0,$=O*Z;for(let lt=0;lt<G;lt++){const rt=I[lt];Lt(rt[2]+$,rt[1]+$,rt[0]+$)}Z=h+x*2,$=O*Z;for(let lt=0;lt<G;lt++){const rt=I[lt];Lt(rt[0]+$,rt[1]+$,rt[2]+$)}}else{for(let Z=0;Z<G;Z++){const $=I[Z];Lt($[2],$[1],$[0])}for(let Z=0;Z<G;Z++){const $=I[Z];Lt($[0]+O*h,$[1]+O*h,$[2]+O*h)}}i.addGroup(q,r.length/3-q,0)}function Ct(){const q=r.length/3;let Z=0;H(C,Z),Z+=C.length;for(let $=0,lt=N.length;$<lt;$++){const rt=N[$];H(rt,Z),Z+=rt.length}i.addGroup(q,r.length/3-q,1)}function H(q,Z){let $=q.length;for(;--$>=0;){const lt=$;let rt=$-1;rt<0&&(rt=q.length-1);for(let E=0,w=h+x*2;E<w;E++){const V=O*E,W=O*(E+1),R=Z+lt+V,X=Z+rt+V,nt=Z+rt+W,st=Z+lt+W;Rt(R,X,nt,st)}}}function Ht(q,Z,$){l.push(q),l.push(Z),l.push($)}function Lt(q,Z,$){gt(q),gt(Z),gt($);const lt=r.length/3,rt=m.generateTopUV(i,r,lt-3,lt-2,lt-1);Pt(rt[0]),Pt(rt[1]),Pt(rt[2])}function Rt(q,Z,$,lt){gt(q),gt(Z),gt(lt),gt(Z),gt($),gt(lt);const rt=r.length/3,E=m.generateSideWallUV(i,r,rt-6,rt-3,rt-2,rt-1);Pt(E[0]),Pt(E[1]),Pt(E[3]),Pt(E[1]),Pt(E[2]),Pt(E[3])}function gt(q){r.push(l[q*3+0]),r.push(l[q*3+1]),r.push(l[q*3+2])}function Pt(q){s.push(q.x),s.push(q.y)}}}toJSON(){const t=Dt.prototype.toJSON.call(this),e=this.parameters.shapes,i=this.parameters.options;return Jx(e,i,t)}}const Zx={generateTopUV:function(n,t,e,i,r){const s=t[e*3],o=t[e*3+1],a=t[i*3],l=t[i*3+1],c=t[r*3],h=t[r*3+1];return[new J(s,o),new J(a,l),new J(c,h)]},generateSideWallUV:function(n,t,e,i,r,s){const o=t[e*3],a=t[e*3+1],l=t[e*3+2],c=t[i*3],h=t[i*3+1],u=t[i*3+2],d=t[r*3],f=t[r*3+1],p=t[r*3+2],_=t[s*3],x=t[s*3+1],g=t[s*3+2];return Math.abs(a-h)<.01?[new J(o,1-l),new J(c,1-u),new J(d,1-p),new J(_,1-g)]:[new J(a,1-l),new J(h,1-u),new J(f,1-p),new J(x,1-g)]}};function Jx(n,t,e){if(e.shapes=[],Array.isArray(n))for(let i=0,r=n.length;i<r;i++){const s=n[i];e.shapes.push(s.uuid)}else e.shapes.push(n.uuid);return t.extrudePath!==void 0&&(e.options.extrudePath=t.extrudePath.toJSON()),e}function Sa(n,t,e){Dt.call(this),this.type="ParametricGeometry",this.parameters={func:n,slices:t,stacks:e};const i=[],r=[],s=[],o=[],a=1e-5,l=new A,c=new A,h=new A,u=new A,d=new A;n.length<3&&console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");const f=t+1;for(let p=0;p<=e;p++){const _=p/e;for(let x=0;x<=t;x++){const g=x/t;n(g,_,c),r.push(c.x,c.y,c.z),g-a>=0?(n(g-a,_,h),u.subVectors(c,h)):(n(g+a,_,h),u.subVectors(h,c)),_-a>=0?(n(g,_-a,h),d.subVectors(c,h)):(n(g,_+a,h),d.subVectors(h,c)),l.crossVectors(u,d).normalize(),s.push(l.x,l.y,l.z),o.push(g,_)}}for(let p=0;p<e;p++)for(let _=0;_<t;_++){const x=p*f+_,g=p*f+_+1,m=(p+1)*f+_+1,S=(p+1)*f+_;i.push(x,g,S),i.push(g,m,S)}this.setIndex(i),this.setAttribute("position",new Vt(r,3)),this.setAttribute("normal",new Vt(s,3)),this.setAttribute("uv",new Vt(o,2))}Sa.prototype=Object.create(Dt.prototype);Sa.prototype.constructor=Sa;class Qx extends Dt{constructor(t,e=12){super(),this.type="ShapeGeometry",this.parameters={shapes:t,curveSegments:e};const i=[],r=[],s=[],o=[];let a=0,l=0;if(Array.isArray(t)===!1)c(t);else for(let h=0;h<t.length;h++)c(t[h]),this.addGroup(a,l,h),a+=l,l=0;this.setIndex(i),this.setAttribute("position",new Vt(r,3)),this.setAttribute("normal",new Vt(s,3)),this.setAttribute("uv",new Vt(o,2));function c(h){const u=r.length/3,d=h.extractPoints(e);let f=d.shape;const p=d.holes;ei.isClockWise(f)===!1&&(f=f.reverse());for(let x=0,g=p.length;x<g;x++){const m=p[x];ei.isClockWise(m)===!0&&(p[x]=m.reverse())}const _=ei.triangulateShape(f,p);for(let x=0,g=p.length;x<g;x++){const m=p[x];f=f.concat(m)}for(let x=0,g=f.length;x<g;x++){const m=f[x];r.push(m.x,m.y,0),s.push(0,0,1),o.push(m.x,m.y)}for(let x=0,g=_.length;x<g;x++){const m=_[x],S=m[0]+u,M=m[1]+u,v=m[2]+u;i.push(S,M,v),l+=3}}}toJSON(){const t=Dt.prototype.toJSON.call(this),e=this.parameters.shapes;return $x(e,t)}}function $x(n,t){if(t.shapes=[],Array.isArray(n))for(let e=0,i=n.length;e<i;e++){const r=n[e];t.shapes.push(r.uuid)}else t.shapes.push(n.uuid);return t}class Kx extends Xt{constructor(t){super(),this.type="ShadowMaterial",this.color=new pt(0),this.transparent=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this}}Kx.prototype.isShadowMaterial=!0;class ty extends Ue{constructor(t){super(t),this.type="RawShaderMaterial"}}ty.prototype.isRawShaderMaterial=!0;function Bn(n){Xt.call(this),this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new pt(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new pt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Wi,this.normalScale=new J(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.flatShading=!1,this.vertexTangents=!1,this.setValues(n)}Bn.prototype=Object.create(Xt.prototype);Bn.prototype.constructor=Bn;Bn.prototype.isMeshStandardMaterial=!0;Bn.prototype.copy=function(n){return Xt.prototype.copy.call(this,n),this.defines={STANDARD:""},this.color.copy(n.color),this.roughness=n.roughness,this.metalness=n.metalness,this.map=n.map,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.emissive.copy(n.emissive),this.emissiveMap=n.emissiveMap,this.emissiveIntensity=n.emissiveIntensity,this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.roughnessMap=n.roughnessMap,this.metalnessMap=n.metalnessMap,this.alphaMap=n.alphaMap,this.envMap=n.envMap,this.envMapIntensity=n.envMapIntensity,this.refractionRatio=n.refractionRatio,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.morphNormals=n.morphNormals,this.flatShading=n.flatShading,this.vertexTangents=n.vertexTangents,this};function Gi(n){Bn.call(this),this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoat=0,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new J(1,1),this.clearcoatNormalMap=null,this.reflectivity=.5,Object.defineProperty(this,"ior",{get:function(){return(1+.4*this.reflectivity)/(1-.4*this.reflectivity)},set:function(t){this.reflectivity=bt.clamp(2.5*(t-1)/(t+1),0,1)}}),this.sheen=null,this.transmission=0,this.transmissionMap=null,this.setValues(n)}Gi.prototype=Object.create(Bn.prototype);Gi.prototype.constructor=Gi;Gi.prototype.isMeshPhysicalMaterial=!0;Gi.prototype.copy=function(n){return Bn.prototype.copy.call(this,n),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=n.clearcoat,this.clearcoatMap=n.clearcoatMap,this.clearcoatRoughness=n.clearcoatRoughness,this.clearcoatRoughnessMap=n.clearcoatRoughnessMap,this.clearcoatNormalMap=n.clearcoatNormalMap,this.clearcoatNormalScale.copy(n.clearcoatNormalScale),this.reflectivity=n.reflectivity,n.sheen?this.sheen=(this.sheen||new pt).copy(n.sheen):this.sheen=null,this.transmission=n.transmission,this.transmissionMap=n.transmissionMap,this};class ll extends Xt{constructor(t){super(),this.type="MeshPhongMaterial",this.color=new pt(16777215),this.specular=new pt(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new pt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Wi,this.normalScale=new J(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Js,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.specular.copy(t.specular),this.shininess=t.shininess,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this.flatShading=t.flatShading,this}}ll.prototype.isMeshPhongMaterial=!0;class ey extends Xt{constructor(t){super(),this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new pt(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new pt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Wi,this.normalScale=new J(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.gradientMap=t.gradientMap,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this}}ey.prototype.isMeshToonMaterial=!0;class ny extends Xt{constructor(t){super(),this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Wi,this.normalScale=new J(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this.flatShading=t.flatShading,this}}ny.prototype.isMeshNormalMaterial=!0;class iy extends Xt{constructor(t){super(),this.type="MeshLambertMaterial",this.color=new pt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new pt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Js,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this}}iy.prototype.isMeshLambertMaterial=!0;class ry extends Xt{constructor(t){super(),this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new pt(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Wi,this.normalScale=new J(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.defines={MATCAP:""},this.color.copy(t.color),this.matcap=t.matcap,this.map=t.map,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this.flatShading=t.flatShading,this}}ry.prototype.isMeshMatcapMaterial=!0;class sy extends qr{constructor(t){super(),this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(t)}copy(t){return super.copy(t),this.scale=t.scale,this.dashSize=t.dashSize,this.gapSize=t.gapSize,this}}sy.prototype.isLineDashedMaterial=!0;const Gt={arraySlice:function(n,t,e){return Gt.isTypedArray(n)?new n.constructor(n.subarray(t,e!==void 0?e:n.length)):n.slice(t,e)},convertArray:function(n,t,e){return!n||!e&&n.constructor===t?n:typeof t.BYTES_PER_ELEMENT=="number"?new t(n):Array.prototype.slice.call(n)},isTypedArray:function(n){return ArrayBuffer.isView(n)&&!(n instanceof DataView)},getKeyframeOrder:function(n){function t(r,s){return n[r]-n[s]}const e=n.length,i=new Array(e);for(let r=0;r!==e;++r)i[r]=r;return i.sort(t),i},sortedArray:function(n,t,e){const i=n.length,r=new n.constructor(i);for(let s=0,o=0;o!==i;++s){const a=e[s]*t;for(let l=0;l!==t;++l)r[o++]=n[a+l]}return r},flattenJSON:function(n,t,e,i){let r=1,s=n[0];for(;s!==void 0&&s[i]===void 0;)s=n[r++];if(s===void 0)return;let o=s[i];if(o!==void 0)if(Array.isArray(o))do o=s[i],o!==void 0&&(t.push(s.time),e.push.apply(e,o)),s=n[r++];while(s!==void 0);else if(o.toArray!==void 0)do o=s[i],o!==void 0&&(t.push(s.time),o.toArray(e,e.length)),s=n[r++];while(s!==void 0);else do o=s[i],o!==void 0&&(t.push(s.time),e.push(o)),s=n[r++];while(s!==void 0)},subclip:function(n,t,e,i,r=30){const s=n.clone();s.name=t;const o=[];for(let l=0;l<s.tracks.length;++l){const c=s.tracks[l],h=c.getValueSize(),u=[],d=[];for(let f=0;f<c.times.length;++f){const p=c.times[f]*r;if(!(p<e||p>=i)){u.push(c.times[f]);for(let _=0;_<h;++_)d.push(c.values[f*h+_])}}u.length!==0&&(c.times=Gt.convertArray(u,c.times.constructor),c.values=Gt.convertArray(d,c.values.constructor),o.push(c))}s.tracks=o;let a=1/0;for(let l=0;l<s.tracks.length;++l)a>s.tracks[l].times[0]&&(a=s.tracks[l].times[0]);for(let l=0;l<s.tracks.length;++l)s.tracks[l].shift(-1*a);return s.resetDuration(),s},makeClipAdditive:function(n,t=0,e=n,i=30){i<=0&&(i=30);const r=e.tracks.length,s=t/i;for(let o=0;o<r;++o){const a=e.tracks[o],l=a.ValueTypeName;if(l==="bool"||l==="string")continue;const c=n.tracks.find(function(g){return g.name===a.name&&g.ValueTypeName===l});if(c===void 0)continue;let h=0;const u=a.getValueSize();a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(h=u/3);let d=0;const f=c.getValueSize();c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(d=f/3);const p=a.times.length-1;let _;if(s<=a.times[0]){const g=h,m=u-h;_=Gt.arraySlice(a.values,g,m)}else if(s>=a.times[p]){const g=p*u+h,m=g+u-h;_=Gt.arraySlice(a.values,g,m)}else{const g=a.createInterpolant(),m=h,S=u-h;g.evaluate(s),_=Gt.arraySlice(g.resultBuffer,m,S)}l==="quaternion"&&new me().fromArray(_).normalize().conjugate().toArray(_);const x=c.times.length;for(let g=0;g<x;++g){const m=g*f+d;if(l==="quaternion")me.multiplyQuaternionsFlat(c.values,m,_,0,c.values,m);else{const S=f-d*2;for(let M=0;M<S;++M)c.values[m+M]-=_[M]}}}return n.blendMode=_u,n}};function Be(n,t,e,i){this.parameterPositions=n,this._cachedIndex=0,this.resultBuffer=i!==void 0?i:new t.constructor(e),this.sampleValues=t,this.valueSize=e}Object.assign(Be.prototype,{evaluate:function(n){const t=this.parameterPositions;let e=this._cachedIndex,i=t[e],r=t[e-1];t:{e:{let s;n:{i:if(!(n<i)){for(let o=e+2;;){if(i===void 0){if(n<r)break i;return e=t.length,this._cachedIndex=e,this.afterEnd_(e-1,n,r)}if(e===o)break;if(r=i,i=t[++e],n<i)break e}s=t.length;break n}if(!(n>=r)){const o=t[1];n<o&&(e=2,r=o);for(let a=e-2;;){if(r===void 0)return this._cachedIndex=0,this.beforeStart_(0,n,i);if(e===a)break;if(i=r,r=t[--e-1],n>=r)break e}s=e,e=0;break n}break t}for(;e<s;){const o=e+s>>>1;n<t[o]?s=o:e=o+1}if(i=t[e],r=t[e-1],r===void 0)return this._cachedIndex=0,this.beforeStart_(0,n,i);if(i===void 0)return e=t.length,this._cachedIndex=e,this.afterEnd_(e-1,r,n)}this._cachedIndex=e,this.intervalChanged_(e,r,i)}return this.interpolate_(e,r,n,i)},settings:null,DefaultSettings_:{},getSettings_:function(){return this.settings||this.DefaultSettings_},copySampleValue_:function(n){const t=this.resultBuffer,e=this.sampleValues,i=this.valueSize,r=n*i;for(let s=0;s!==i;++s)t[s]=e[r+s];return t},interpolate_:function(){throw new Error("call to abstract method")},intervalChanged_:function(){}});Object.assign(Be.prototype,{beforeStart_:Be.prototype.copySampleValue_,afterEnd_:Be.prototype.copySampleValue_});function Ta(n,t,e,i){Be.call(this,n,t,e,i),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0}Ta.prototype=Object.assign(Object.create(Be.prototype),{constructor:Ta,DefaultSettings_:{endingStart:Li,endingEnd:Li},intervalChanged_:function(n,t,e){const i=this.parameterPositions;let r=n-2,s=n+1,o=i[r],a=i[s];if(o===void 0)switch(this.getSettings_().endingStart){case Ci:r=n,o=2*t-e;break;case zs:r=i.length-2,o=t+i[r]-i[r+1];break;default:r=n,o=e}if(a===void 0)switch(this.getSettings_().endingEnd){case Ci:s=n,a=2*e-t;break;case zs:s=1,a=e+i[1]-i[0];break;default:s=n-1,a=t}const l=(e-t)*.5,c=this.valueSize;this._weightPrev=l/(t-o),this._weightNext=l/(a-e),this._offsetPrev=r*c,this._offsetNext=s*c},interpolate_:function(n,t,e,i){const r=this.resultBuffer,s=this.sampleValues,o=this.valueSize,a=n*o,l=a-o,c=this._offsetPrev,h=this._offsetNext,u=this._weightPrev,d=this._weightNext,f=(e-t)/(i-t),p=f*f,_=p*f,x=-u*_+2*u*p-u*f,g=(1+u)*_+(-1.5-2*u)*p+(-.5+u)*f+1,m=(-1-d)*_+(1.5+d)*p+.5*f,S=d*_-d*p;for(let M=0;M!==o;++M)r[M]=x*s[c+M]+g*s[l+M]+m*s[a+M]+S*s[h+M];return r}});function Hs(n,t,e,i){Be.call(this,n,t,e,i)}Hs.prototype=Object.assign(Object.create(Be.prototype),{constructor:Hs,interpolate_:function(n,t,e,i){const r=this.resultBuffer,s=this.sampleValues,o=this.valueSize,a=n*o,l=a-o,c=(e-t)/(i-t),h=1-c;for(let u=0;u!==o;++u)r[u]=s[l+u]*h+s[a+u]*c;return r}});function Ea(n,t,e,i){Be.call(this,n,t,e,i)}Ea.prototype=Object.assign(Object.create(Be.prototype),{constructor:Ea,interpolate_:function(n){return this.copySampleValue_(n-1)}});class rn{constructor(t,e,i,r){if(t===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(e===void 0||e.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+t);this.name=t,this.times=Gt.convertArray(e,this.TimeBufferType),this.values=Gt.convertArray(i,this.ValueBufferType),this.setInterpolation(r||this.DefaultInterpolation)}static toJSON(t){const e=t.constructor;let i;if(e.toJSON!==this.toJSON)i=e.toJSON(t);else{i={name:t.name,times:Gt.convertArray(t.times,Array),values:Gt.convertArray(t.values,Array)};const r=t.getInterpolation();r!==t.DefaultInterpolation&&(i.interpolation=r)}return i.type=t.ValueTypeName,i}InterpolantFactoryMethodDiscrete(t){return new Ea(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodLinear(t){return new Hs(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodSmooth(t){return new Ta(this.times,this.values,this.getValueSize(),t)}setInterpolation(t){let e;switch(t){case Os:e=this.InterpolantFactoryMethodDiscrete;break;case Bs:e=this.InterpolantFactoryMethodLinear;break;case xo:e=this.InterpolantFactoryMethodSmooth;break}if(e===void 0){const i="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(t!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(i);return console.warn("THREE.KeyframeTrack:",i),this}return this.createInterpolant=e,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return Os;case this.InterpolantFactoryMethodLinear:return Bs;case this.InterpolantFactoryMethodSmooth:return xo}}getValueSize(){return this.values.length/this.times.length}shift(t){if(t!==0){const e=this.times;for(let i=0,r=e.length;i!==r;++i)e[i]+=t}return this}scale(t){if(t!==1){const e=this.times;for(let i=0,r=e.length;i!==r;++i)e[i]*=t}return this}trim(t,e){const i=this.times,r=i.length;let s=0,o=r-1;for(;s!==r&&i[s]<t;)++s;for(;o!==-1&&i[o]>e;)--o;if(++o,s!==0||o!==r){s>=o&&(o=Math.max(o,1),s=o-1);const a=this.getValueSize();this.times=Gt.arraySlice(i,s,o),this.values=Gt.arraySlice(this.values,s*a,o*a)}return this}validate(){let t=!0;const e=this.getValueSize();e-Math.floor(e)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),t=!1);const i=this.times,r=this.values,s=i.length;s===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),t=!1);let o=null;for(let a=0;a!==s;a++){const l=i[a];if(typeof l=="number"&&isNaN(l)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,a,l),t=!1;break}if(o!==null&&o>l){console.error("THREE.KeyframeTrack: Out of order keys.",this,a,l,o),t=!1;break}o=l}if(r!==void 0&&Gt.isTypedArray(r))for(let a=0,l=r.length;a!==l;++a){const c=r[a];if(isNaN(c)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,a,c),t=!1;break}}return t}optimize(){const t=Gt.arraySlice(this.times),e=Gt.arraySlice(this.values),i=this.getValueSize(),r=this.getInterpolation()===xo,s=t.length-1;let o=1;for(let a=1;a<s;++a){let l=!1;const c=t[a],h=t[a+1];if(c!==h&&(a!==1||c!==t[0]))if(r)l=!0;else{const u=a*i,d=u-i,f=u+i;for(let p=0;p!==i;++p){const _=e[u+p];if(_!==e[d+p]||_!==e[f+p]){l=!0;break}}}if(l){if(a!==o){t[o]=t[a];const u=a*i,d=o*i;for(let f=0;f!==i;++f)e[d+f]=e[u+f]}++o}}if(s>0){t[o]=t[s];for(let a=s*i,l=o*i,c=0;c!==i;++c)e[l+c]=e[a+c];++o}return o!==t.length?(this.times=Gt.arraySlice(t,0,o),this.values=Gt.arraySlice(e,0,o*i)):(this.times=t,this.values=e),this}clone(){const t=Gt.arraySlice(this.times,0),e=Gt.arraySlice(this.values,0),i=this.constructor,r=new i(this.name,t,e);return r.createInterpolant=this.createInterpolant,r}}rn.prototype.TimeBufferType=Float32Array;rn.prototype.ValueBufferType=Float32Array;rn.prototype.DefaultInterpolation=Bs;class Zi extends rn{}Zi.prototype.ValueTypeName="bool";Zi.prototype.ValueBufferType=Array;Zi.prototype.DefaultInterpolation=Os;Zi.prototype.InterpolantFactoryMethodLinear=void 0;Zi.prototype.InterpolantFactoryMethodSmooth=void 0;class qu extends rn{}qu.prototype.ValueTypeName="color";class Gs extends rn{}Gs.prototype.ValueTypeName="number";function Aa(n,t,e,i){Be.call(this,n,t,e,i)}Aa.prototype=Object.assign(Object.create(Be.prototype),{constructor:Aa,interpolate_:function(n,t,e,i){const r=this.resultBuffer,s=this.sampleValues,o=this.valueSize,a=(e-t)/(i-t);let l=n*o;for(let c=l+o;l!==c;l+=4)me.slerpFlat(r,0,s,l-o,s,l,a);return r}});class jr extends rn{InterpolantFactoryMethodLinear(t){return new Aa(this.times,this.values,this.getValueSize(),t)}}jr.prototype.ValueTypeName="quaternion";jr.prototype.DefaultInterpolation=Bs;jr.prototype.InterpolantFactoryMethodSmooth=void 0;class Ji extends rn{}Ji.prototype.ValueTypeName="string";Ji.prototype.ValueBufferType=Array;Ji.prototype.DefaultInterpolation=Os;Ji.prototype.InterpolantFactoryMethodLinear=void 0;Ji.prototype.InterpolantFactoryMethodSmooth=void 0;class Vs extends rn{}Vs.prototype.ValueTypeName="vector";class th{constructor(t,e=-1,i,r=nl){this.name=t,this.tracks=i,this.duration=e,this.blendMode=r,this.uuid=bt.generateUUID(),this.duration<0&&this.resetDuration()}static parse(t){const e=[],i=t.tracks,r=1/(t.fps||1);for(let o=0,a=i.length;o!==a;++o)e.push(ay(i[o]).scale(r));const s=new this(t.name,t.duration,e,t.blendMode);return s.uuid=t.uuid,s}static toJSON(t){const e=[],i=t.tracks,r={name:t.name,duration:t.duration,tracks:e,uuid:t.uuid,blendMode:t.blendMode};for(let s=0,o=i.length;s!==o;++s)e.push(rn.toJSON(i[s]));return r}static CreateFromMorphTargetSequence(t,e,i,r){const s=e.length,o=[];for(let a=0;a<s;a++){let l=[],c=[];l.push((a+s-1)%s,a,(a+1)%s),c.push(0,1,0);const h=Gt.getKeyframeOrder(l);l=Gt.sortedArray(l,1,h),c=Gt.sortedArray(c,1,h),!r&&l[0]===0&&(l.push(s),c.push(c[0])),o.push(new Gs(".morphTargetInfluences["+e[a].name+"]",l,c).scale(1/i))}return new this(t,-1,o)}static findByName(t,e){let i=t;if(!Array.isArray(t)){const r=t;i=r.geometry&&r.geometry.animations||r.animations}for(let r=0;r<i.length;r++)if(i[r].name===e)return i[r];return null}static CreateClipsFromMorphTargetSequences(t,e,i){const r={},s=/^([\w-]*?)([\d]+)$/;for(let a=0,l=t.length;a<l;a++){const c=t[a],h=c.name.match(s);if(h&&h.length>1){const u=h[1];let d=r[u];d||(r[u]=d=[]),d.push(c)}}const o=[];for(const a in r)o.push(this.CreateFromMorphTargetSequence(a,r[a],e,i));return o}static parseAnimation(t,e){if(!t)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const i=function(u,d,f,p,_){if(f.length!==0){const x=[],g=[];Gt.flattenJSON(f,x,g,p),x.length!==0&&_.push(new u(d,x,g))}},r=[],s=t.name||"default",o=t.fps||30,a=t.blendMode;let l=t.length||-1;const c=t.hierarchy||[];for(let u=0;u<c.length;u++){const d=c[u].keys;if(!(!d||d.length===0))if(d[0].morphTargets){const f={};let p;for(p=0;p<d.length;p++)if(d[p].morphTargets)for(let _=0;_<d[p].morphTargets.length;_++)f[d[p].morphTargets[_]]=-1;for(const _ in f){const x=[],g=[];for(let m=0;m!==d[p].morphTargets.length;++m){const S=d[p];x.push(S.time),g.push(S.morphTarget===_?1:0)}r.push(new Gs(".morphTargetInfluence["+_+"]",x,g))}l=f.length*(o||1)}else{const f=".bones["+e[u].name+"]";i(Vs,f+".position",d,"pos",r),i(jr,f+".quaternion",d,"rot",r),i(Vs,f+".scale",d,"scl",r)}}return r.length===0?null:new this(s,l,r,a)}resetDuration(){const t=this.tracks;let e=0;for(let i=0,r=t.length;i!==r;++i){const s=this.tracks[i];e=Math.max(e,s.times[s.times.length-1])}return this.duration=e,this}trim(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].trim(0,this.duration);return this}validate(){let t=!0;for(let e=0;e<this.tracks.length;e++)t=t&&this.tracks[e].validate();return t}optimize(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].optimize();return this}clone(){const t=[];for(let e=0;e<this.tracks.length;e++)t.push(this.tracks[e].clone());return new this.constructor(this.name,this.duration,t,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function oy(n){switch(n.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return Gs;case"vector":case"vector2":case"vector3":case"vector4":return Vs;case"color":return qu;case"quaternion":return jr;case"bool":case"boolean":return Zi;case"string":return Ji}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+n)}function ay(n){if(n.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const t=oy(n.type);if(n.times===void 0){const e=[],i=[];Gt.flattenJSON(n.keys,e,i,"value"),n.times=e,n.values=i}return t.parse!==void 0?t.parse(n):new t(n.name,n.times,n.values,n.interpolation)}const Vi={enabled:!1,files:{},add:function(n,t){this.enabled!==!1&&(this.files[n]=t)},get:function(n){if(this.enabled!==!1)return this.files[n]},remove:function(n){delete this.files[n]},clear:function(){this.files={}}};function ly(n,t,e){const i=this;let r=!1,s=0,o=0,a;const l=[];this.onStart=void 0,this.onLoad=n,this.onProgress=t,this.onError=e,this.itemStart=function(c){o++,r===!1&&i.onStart!==void 0&&i.onStart(c,s,o),r=!0},this.itemEnd=function(c){s++,i.onProgress!==void 0&&i.onProgress(c,s,o),s===o&&(r=!1,i.onLoad!==void 0&&i.onLoad())},this.itemError=function(c){i.onError!==void 0&&i.onError(c)},this.resolveURL=function(c){return a?a(c):c},this.setURLModifier=function(c){return a=c,this},this.addHandler=function(c,h){return l.push(c,h),this},this.removeHandler=function(c){const h=l.indexOf(c);return h!==-1&&l.splice(h,2),this},this.getHandler=function(c){for(let h=0,u=l.length;h<u;h+=2){const d=l[h],f=l[h+1];if(d.global&&(d.lastIndex=0),d.test(c))return f}return null}}const cy=new ly;function ge(n){this.manager=n!==void 0?n:cy,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}Object.assign(ge.prototype,{load:function(){},loadAsync:function(n,t){const e=this;return new Promise(function(i,r){e.load(n,i,t,r)})},parse:function(){},setCrossOrigin:function(n){return this.crossOrigin=n,this},setWithCredentials:function(n){return this.withCredentials=n,this},setPath:function(n){return this.path=n,this},setResourcePath:function(n){return this.resourcePath=n,this},setRequestHeader:function(n){return this.requestHeader=n,this}});const Xe={};function Ws(n){ge.call(this,n)}Ws.prototype=Object.assign(Object.create(ge.prototype),{constructor:Ws,load:function(n,t,e,i){n===void 0&&(n=""),this.path!==void 0&&(n=this.path+n),n=this.manager.resolveURL(n);const r=this,s=Vi.get(n);if(s!==void 0)return r.manager.itemStart(n),setTimeout(function(){t&&t(s),r.manager.itemEnd(n)},0),s;if(Xe[n]!==void 0){Xe[n].push({onLoad:t,onProgress:e,onError:i});return}const o=/^data:(.*?)(;base64)?,(.*)$/,a=n.match(o);let l;if(a){const c=a[1],h=!!a[2];let u=a[3];u=decodeURIComponent(u),h&&(u=atob(u));try{let d;const f=(this.responseType||"").toLowerCase();switch(f){case"arraybuffer":case"blob":const p=new Uint8Array(u.length);for(let x=0;x<u.length;x++)p[x]=u.charCodeAt(x);f==="blob"?d=new Blob([p.buffer],{type:c}):d=p.buffer;break;case"document":d=new DOMParser().parseFromString(u,c);break;case"json":d=JSON.parse(u);break;default:d=u;break}setTimeout(function(){t&&t(d),r.manager.itemEnd(n)},0)}catch(d){setTimeout(function(){i&&i(d),r.manager.itemError(n),r.manager.itemEnd(n)},0)}}else{Xe[n]=[],Xe[n].push({onLoad:t,onProgress:e,onError:i}),l=new XMLHttpRequest,l.open("GET",n,!0),l.addEventListener("load",function(c){const h=this.response,u=Xe[n];if(delete Xe[n],this.status===200||this.status===0){this.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),Vi.add(n,h);for(let d=0,f=u.length;d<f;d++){const p=u[d];p.onLoad&&p.onLoad(h)}r.manager.itemEnd(n)}else{for(let d=0,f=u.length;d<f;d++){const p=u[d];p.onError&&p.onError(c)}r.manager.itemError(n),r.manager.itemEnd(n)}},!1),l.addEventListener("progress",function(c){const h=Xe[n];for(let u=0,d=h.length;u<d;u++){const f=h[u];f.onProgress&&f.onProgress(c)}},!1),l.addEventListener("error",function(c){const h=Xe[n];delete Xe[n];for(let u=0,d=h.length;u<d;u++){const f=h[u];f.onError&&f.onError(c)}r.manager.itemError(n),r.manager.itemEnd(n)},!1),l.addEventListener("abort",function(c){const h=Xe[n];delete Xe[n];for(let u=0,d=h.length;u<d;u++){const f=h[u];f.onError&&f.onError(c)}r.manager.itemError(n),r.manager.itemEnd(n)},!1),this.responseType!==void 0&&(l.responseType=this.responseType),this.withCredentials!==void 0&&(l.withCredentials=this.withCredentials),l.overrideMimeType&&l.overrideMimeType(this.mimeType!==void 0?this.mimeType:"text/plain");for(const c in this.requestHeader)l.setRequestHeader(c,this.requestHeader[c]);l.send(null)}return r.manager.itemStart(n),l},setResponseType:function(n){return this.responseType=n,this},setMimeType:function(n){return this.mimeType=n,this}});function eh(n){ge.call(this,n)}eh.prototype=Object.assign(Object.create(ge.prototype),{constructor:eh,load:function(n,t,e,i){const r=this,s=[],o=new Hu,a=new Ws(this.manager);a.setPath(this.path),a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setWithCredentials(r.withCredentials);let l=0;function c(h){a.load(n[h],function(u){const d=r.parse(u,!0);s[h]={width:d.width,height:d.height,format:d.format,mipmaps:d.mipmaps},l+=1,l===6&&(d.mipmapCount===1&&(o.minFilter=oe),o.image=s,o.format=d.format,o.needsUpdate=!0,t&&t(o))},e,i)}if(Array.isArray(n))for(let h=0,u=n.length;h<u;++h)c(h);else a.load(n,function(h){const u=r.parse(h,!0);if(u.isCubemap){const d=u.mipmaps.length/u.mipmapCount;for(let f=0;f<d;f++){s[f]={mipmaps:[]};for(let p=0;p<u.mipmapCount;p++)s[f].mipmaps.push(u.mipmaps[f*u.mipmapCount+p]),s[f].format=u.format,s[f].width=u.width,s[f].height=u.height}o.image=s}else o.image.width=u.width,o.image.height=u.height,o.mipmaps=u.mipmaps;u.mipmapCount===1&&(o.minFilter=oe),o.format=u.format,o.needsUpdate=!0,t&&t(o)},e,i);return o}});class ju extends ge{constructor(t){super(t)}load(t,e,i,r){this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const s=this,o=Vi.get(t);if(o!==void 0)return s.manager.itemStart(t),setTimeout(function(){e&&e(o),s.manager.itemEnd(t)},0),o;const a=document.createElementNS("http://www.w3.org/1999/xhtml","img");function l(){a.removeEventListener("load",l,!1),a.removeEventListener("error",c,!1),Vi.add(t,this),e&&e(this),s.manager.itemEnd(t)}function c(h){a.removeEventListener("load",l,!1),a.removeEventListener("error",c,!1),r&&r(h),s.manager.itemError(t),s.manager.itemEnd(t)}return a.addEventListener("load",l,!1),a.addEventListener("error",c,!1),t.substr(0,5)!=="data:"&&this.crossOrigin!==void 0&&(a.crossOrigin=this.crossOrigin),s.manager.itemStart(t),a.src=t,a}}class hy extends ge{constructor(t){super(t)}load(t,e,i,r){const s=new Ks,o=new ju(this.manager);o.setCrossOrigin(this.crossOrigin),o.setPath(this.path);let a=0;function l(c){o.load(t[c],function(h){s.images[c]=h,a++,a===6&&(s.needsUpdate=!0,e&&e(s))},void 0,r)}for(let c=0;c<t.length;++c)l(c);return s}}function nh(n){ge.call(this,n)}nh.prototype=Object.assign(Object.create(ge.prototype),{constructor:nh,load:function(n,t,e,i){const r=this,s=new ol,o=new Ws(this.manager);return o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setPath(this.path),o.setWithCredentials(r.withCredentials),o.load(n,function(a){const l=r.parse(a);!l||(l.image!==void 0?s.image=l.image:l.data!==void 0&&(s.image.width=l.width,s.image.height=l.height,s.image.data=l.data),s.wrapS=l.wrapS!==void 0?l.wrapS:Le,s.wrapT=l.wrapT!==void 0?l.wrapT:Le,s.magFilter=l.magFilter!==void 0?l.magFilter:oe,s.minFilter=l.minFilter!==void 0?l.minFilter:oe,s.anisotropy=l.anisotropy!==void 0?l.anisotropy:1,l.encoding!==void 0&&(s.encoding=l.encoding),l.flipY!==void 0&&(s.flipY=l.flipY),l.format!==void 0&&(s.format=l.format),l.type!==void 0&&(s.type=l.type),l.mipmaps!==void 0&&(s.mipmaps=l.mipmaps,s.minFilter=Qs),l.mipmapCount===1&&(s.minFilter=oe),s.needsUpdate=!0,t&&t(s,l))},e,i),s}});function La(n){ge.call(this,n)}La.prototype=Object.assign(Object.create(ge.prototype),{constructor:La,load:function(n,t,e,i){const r=new le,s=new ju(this.manager);return s.setCrossOrigin(this.crossOrigin),s.setPath(this.path),s.load(n,function(o){r.image=o;const a=n.search(/\.jpe?g($|\?)/i)>0||n.search(/^data\:image\/jpeg/)===0;r.format=a?Kn:Ye,r.needsUpdate=!0,t!==void 0&&t(r)},e,i),r}});function Me(){this.type="Curve",this.arcLengthDivisions=200}Object.assign(Me.prototype,{getPoint:function(){return console.warn("THREE.Curve: .getPoint() not implemented."),null},getPointAt:function(n,t){const e=this.getUtoTmapping(n);return this.getPoint(e,t)},getPoints:function(n=5){const t=[];for(let e=0;e<=n;e++)t.push(this.getPoint(e/n));return t},getSpacedPoints:function(n=5){const t=[];for(let e=0;e<=n;e++)t.push(this.getPointAt(e/n));return t},getLength:function(){const n=this.getLengths();return n[n.length-1]},getLengths:function(n){if(n===void 0&&(n=this.arcLengthDivisions),this.cacheArcLengths&&this.cacheArcLengths.length===n+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const t=[];let e,i=this.getPoint(0),r=0;t.push(0);for(let s=1;s<=n;s++)e=this.getPoint(s/n),r+=e.distanceTo(i),t.push(r),i=e;return this.cacheArcLengths=t,t},updateArcLengths:function(){this.needsUpdate=!0,this.getLengths()},getUtoTmapping:function(n,t){const e=this.getLengths();let i=0;const r=e.length;let s;t?s=t:s=n*e[r-1];let o=0,a=r-1,l;for(;o<=a;)if(i=Math.floor(o+(a-o)/2),l=e[i]-s,l<0)o=i+1;else if(l>0)a=i-1;else{a=i;break}if(i=a,e[i]===s)return i/(r-1);const c=e[i],u=e[i+1]-c,d=(s-c)/u;return(i+d)/(r-1)},getTangent:function(n,t){let i=n-1e-4,r=n+1e-4;i<0&&(i=0),r>1&&(r=1);const s=this.getPoint(i),o=this.getPoint(r),a=t||(s.isVector2?new J:new A);return a.copy(o).sub(s).normalize(),a},getTangentAt:function(n,t){const e=this.getUtoTmapping(n);return this.getTangent(e,t)},computeFrenetFrames:function(n,t){const e=new A,i=[],r=[],s=[],o=new A,a=new dt;for(let d=0;d<=n;d++){const f=d/n;i[d]=this.getTangentAt(f,new A),i[d].normalize()}r[0]=new A,s[0]=new A;let l=Number.MAX_VALUE;const c=Math.abs(i[0].x),h=Math.abs(i[0].y),u=Math.abs(i[0].z);c<=l&&(l=c,e.set(1,0,0)),h<=l&&(l=h,e.set(0,1,0)),u<=l&&e.set(0,0,1),o.crossVectors(i[0],e).normalize(),r[0].crossVectors(i[0],o),s[0].crossVectors(i[0],r[0]);for(let d=1;d<=n;d++){if(r[d]=r[d-1].clone(),s[d]=s[d-1].clone(),o.crossVectors(i[d-1],i[d]),o.length()>Number.EPSILON){o.normalize();const f=Math.acos(bt.clamp(i[d-1].dot(i[d]),-1,1));r[d].applyMatrix4(a.makeRotationAxis(o,f))}s[d].crossVectors(i[d],r[d])}if(t===!0){let d=Math.acos(bt.clamp(r[0].dot(r[n]),-1,1));d/=n,i[0].dot(o.crossVectors(r[0],r[n]))>0&&(d=-d);for(let f=1;f<=n;f++)r[f].applyMatrix4(a.makeRotationAxis(i[f],d*f)),s[f].crossVectors(i[f],r[f])}return{tangents:i,normals:r,binormals:s}},clone:function(){return new this.constructor().copy(this)},copy:function(n){return this.arcLengthDivisions=n.arcLengthDivisions,this},toJSON:function(){const n={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return n.arcLengthDivisions=this.arcLengthDivisions,n.type=this.type,n},fromJSON:function(n){return this.arcLengthDivisions=n.arcLengthDivisions,this}});class io extends Me{constructor(t=0,e=0,i=1,r=1,s=0,o=Math.PI*2,a=!1,l=0){super(),this.type="EllipseCurve",this.aX=t,this.aY=e,this.xRadius=i,this.yRadius=r,this.aStartAngle=s,this.aEndAngle=o,this.aClockwise=a,this.aRotation=l}getPoint(t,e){const i=e||new J,r=Math.PI*2;let s=this.aEndAngle-this.aStartAngle;const o=Math.abs(s)<Number.EPSILON;for(;s<0;)s+=r;for(;s>r;)s-=r;s<Number.EPSILON&&(o?s=0:s=r),this.aClockwise===!0&&!o&&(s===r?s=-r:s=s-r);const a=this.aStartAngle+t*s;let l=this.aX+this.xRadius*Math.cos(a),c=this.aY+this.yRadius*Math.sin(a);if(this.aRotation!==0){const h=Math.cos(this.aRotation),u=Math.sin(this.aRotation),d=l-this.aX,f=c-this.aY;l=d*h-f*u+this.aX,c=d*u+f*h+this.aY}return i.set(l,c)}copy(t){return super.copy(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}toJSON(){const t=super.toJSON();return t.aX=this.aX,t.aY=this.aY,t.xRadius=this.xRadius,t.yRadius=this.yRadius,t.aStartAngle=this.aStartAngle,t.aEndAngle=this.aEndAngle,t.aClockwise=this.aClockwise,t.aRotation=this.aRotation,t}fromJSON(t){return super.fromJSON(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}}io.prototype.isEllipseCurve=!0;class Xu extends io{constructor(t,e,i,r,s,o){super(t,e,i,i,r,s,o),this.type="ArcCurve"}}Xu.prototype.isArcCurve=!0;function cl(){let n=0,t=0,e=0,i=0;function r(s,o,a,l){n=s,t=a,e=-3*s+3*o-2*a-l,i=2*s-2*o+a+l}return{initCatmullRom:function(s,o,a,l,c){r(o,a,c*(a-s),c*(l-o))},initNonuniformCatmullRom:function(s,o,a,l,c,h,u){let d=(o-s)/c-(a-s)/(c+h)+(a-o)/h,f=(a-o)/h-(l-o)/(h+u)+(l-a)/u;d*=h,f*=h,r(o,a,d,f)},calc:function(s){const o=s*s,a=o*s;return n+t*s+e*o+i*a}}}const bs=new A,Wo=new cl,qo=new cl,jo=new cl;class Yu extends Me{constructor(t=[],e=!1,i="centripetal",r=.5){super(),this.type="CatmullRomCurve3",this.points=t,this.closed=e,this.curveType=i,this.tension=r}getPoint(t,e=new A){const i=e,r=this.points,s=r.length,o=(s-(this.closed?0:1))*t;let a=Math.floor(o),l=o-a;this.closed?a+=a>0?0:(Math.floor(Math.abs(a)/s)+1)*s:l===0&&a===s-1&&(a=s-2,l=1);let c,h;this.closed||a>0?c=r[(a-1)%s]:(bs.subVectors(r[0],r[1]).add(r[0]),c=bs);const u=r[a%s],d=r[(a+1)%s];if(this.closed||a+2<s?h=r[(a+2)%s]:(bs.subVectors(r[s-1],r[s-2]).add(r[s-1]),h=bs),this.curveType==="centripetal"||this.curveType==="chordal"){const f=this.curveType==="chordal"?.5:.25;let p=Math.pow(c.distanceToSquared(u),f),_=Math.pow(u.distanceToSquared(d),f),x=Math.pow(d.distanceToSquared(h),f);_<1e-4&&(_=1),p<1e-4&&(p=_),x<1e-4&&(x=_),Wo.initNonuniformCatmullRom(c.x,u.x,d.x,h.x,p,_,x),qo.initNonuniformCatmullRom(c.y,u.y,d.y,h.y,p,_,x),jo.initNonuniformCatmullRom(c.z,u.z,d.z,h.z,p,_,x)}else this.curveType==="catmullrom"&&(Wo.initCatmullRom(c.x,u.x,d.x,h.x,this.tension),qo.initCatmullRom(c.y,u.y,d.y,h.y,this.tension),jo.initCatmullRom(c.z,u.z,d.z,h.z,this.tension));return i.set(Wo.calc(l),qo.calc(l),jo.calc(l)),i}copy(t){super.copy(t),this.points=[];for(let e=0,i=t.points.length;e<i;e++){const r=t.points[e];this.points.push(r.clone())}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,i=this.points.length;e<i;e++){const r=this.points[e];t.points.push(r.toArray())}return t.closed=this.closed,t.curveType=this.curveType,t.tension=this.tension,t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,i=t.points.length;e<i;e++){const r=t.points[e];this.points.push(new A().fromArray(r))}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}}Yu.prototype.isCatmullRomCurve3=!0;function ih(n,t,e,i,r){const s=(i-t)*.5,o=(r-e)*.5,a=n*n,l=n*a;return(2*e-2*i+s+o)*l+(-3*e+3*i-2*s-o)*a+s*n+e}function uy(n,t){const e=1-n;return e*e*t}function dy(n,t){return 2*(1-n)*n*t}function fy(n,t){return n*n*t}function Sr(n,t,e,i){return uy(n,t)+dy(n,e)+fy(n,i)}function py(n,t){const e=1-n;return e*e*e*t}function my(n,t){const e=1-n;return 3*e*e*n*t}function gy(n,t){return 3*(1-n)*n*n*t}function _y(n,t){return n*n*n*t}function Tr(n,t,e,i,r){return py(n,t)+my(n,e)+gy(n,i)+_y(n,r)}class hl extends Me{constructor(t=new J,e=new J,i=new J,r=new J){super(),this.type="CubicBezierCurve",this.v0=t,this.v1=e,this.v2=i,this.v3=r}getPoint(t,e=new J){const i=e,r=this.v0,s=this.v1,o=this.v2,a=this.v3;return i.set(Tr(t,r.x,s.x,o.x,a.x),Tr(t,r.y,s.y,o.y,a.y)),i}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}hl.prototype.isCubicBezierCurve=!0;class Zu extends Me{constructor(t=new A,e=new A,i=new A,r=new A){super(),this.type="CubicBezierCurve3",this.v0=t,this.v1=e,this.v2=i,this.v3=r}getPoint(t,e=new A){const i=e,r=this.v0,s=this.v1,o=this.v2,a=this.v3;return i.set(Tr(t,r.x,s.x,o.x,a.x),Tr(t,r.y,s.y,o.y,a.y),Tr(t,r.z,s.z,o.z,a.z)),i}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}Zu.prototype.isCubicBezierCurve3=!0;class ro extends Me{constructor(t=new J,e=new J){super(),this.type="LineCurve",this.v1=t,this.v2=e}getPoint(t,e=new J){const i=e;return t===1?i.copy(this.v2):(i.copy(this.v2).sub(this.v1),i.multiplyScalar(t).add(this.v1)),i}getPointAt(t,e){return this.getPoint(t,e)}getTangent(t,e){const i=e||new J;return i.copy(this.v2).sub(this.v1).normalize(),i}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}ro.prototype.isLineCurve=!0;class xy extends Me{constructor(t=new A,e=new A){super(),this.type="LineCurve3",this.isLineCurve3=!0,this.v1=t,this.v2=e}getPoint(t,e=new A){const i=e;return t===1?i.copy(this.v2):(i.copy(this.v2).sub(this.v1),i.multiplyScalar(t).add(this.v1)),i}getPointAt(t,e){return this.getPoint(t,e)}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class ul extends Me{constructor(t=new J,e=new J,i=new J){super(),this.type="QuadraticBezierCurve",this.v0=t,this.v1=e,this.v2=i}getPoint(t,e=new J){const i=e,r=this.v0,s=this.v1,o=this.v2;return i.set(Sr(t,r.x,s.x,o.x),Sr(t,r.y,s.y,o.y)),i}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}ul.prototype.isQuadraticBezierCurve=!0;class Ju extends Me{constructor(t=new A,e=new A,i=new A){super(),this.type="QuadraticBezierCurve3",this.v0=t,this.v1=e,this.v2=i}getPoint(t,e=new A){const i=e,r=this.v0,s=this.v1,o=this.v2;return i.set(Sr(t,r.x,s.x,o.x),Sr(t,r.y,s.y,o.y),Sr(t,r.z,s.z,o.z)),i}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}Ju.prototype.isQuadraticBezierCurve3=!0;class dl extends Me{constructor(t=[]){super(),this.type="SplineCurve",this.points=t}getPoint(t,e=new J){const i=e,r=this.points,s=(r.length-1)*t,o=Math.floor(s),a=s-o,l=r[o===0?o:o-1],c=r[o],h=r[o>r.length-2?r.length-1:o+1],u=r[o>r.length-3?r.length-1:o+2];return i.set(ih(a,l.x,c.x,h.x,u.x),ih(a,l.y,c.y,h.y,u.y)),i}copy(t){super.copy(t),this.points=[];for(let e=0,i=t.points.length;e<i;e++){const r=t.points[e];this.points.push(r.clone())}return this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,i=this.points.length;e<i;e++){const r=this.points[e];t.points.push(r.toArray())}return t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,i=t.points.length;e<i;e++){const r=t.points[e];this.points.push(new J().fromArray(r))}return this}}dl.prototype.isSplineCurve=!0;var yy=Object.freeze({__proto__:null,ArcCurve:Xu,CatmullRomCurve3:Yu,CubicBezierCurve:hl,CubicBezierCurve3:Zu,EllipseCurve:io,LineCurve:ro,LineCurve3:xy,QuadraticBezierCurve:ul,QuadraticBezierCurve3:Ju,SplineCurve:dl});class vy extends Me{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(t){this.curves.push(t)}closePath(){const t=this.curves[0].getPoint(0),e=this.curves[this.curves.length-1].getPoint(1);t.equals(e)||this.curves.push(new ro(e,t))}getPoint(t){const e=t*this.getLength(),i=this.getCurveLengths();let r=0;for(;r<i.length;){if(i[r]>=e){const s=i[r]-e,o=this.curves[r],a=o.getLength(),l=a===0?0:1-s/a;return o.getPointAt(l)}r++}return null}getLength(){const t=this.getCurveLengths();return t[t.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const t=[];let e=0;for(let i=0,r=this.curves.length;i<r;i++)e+=this.curves[i].getLength(),t.push(e);return this.cacheLengths=t,t}getSpacedPoints(t=40){const e=[];for(let i=0;i<=t;i++)e.push(this.getPoint(i/t));return this.autoClose&&e.push(e[0]),e}getPoints(t=12){const e=[];let i;for(let r=0,s=this.curves;r<s.length;r++){const o=s[r],a=o&&o.isEllipseCurve?t*2:o&&(o.isLineCurve||o.isLineCurve3)?1:o&&o.isSplineCurve?t*o.points.length:t,l=o.getPoints(a);for(let c=0;c<l.length;c++){const h=l[c];i&&i.equals(h)||(e.push(h),i=h)}}return this.autoClose&&e.length>1&&!e[e.length-1].equals(e[0])&&e.push(e[0]),e}copy(t){super.copy(t),this.curves=[];for(let e=0,i=t.curves.length;e<i;e++){const r=t.curves[e];this.curves.push(r.clone())}return this.autoClose=t.autoClose,this}toJSON(){const t=super.toJSON();t.autoClose=this.autoClose,t.curves=[];for(let e=0,i=this.curves.length;e<i;e++){const r=this.curves[e];t.curves.push(r.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.autoClose=t.autoClose,this.curves=[];for(let e=0,i=t.curves.length;e<i;e++){const r=t.curves[e];this.curves.push(new yy[r.type]().fromJSON(r))}return this}}class Ca extends vy{constructor(t){super(),this.type="Path",this.currentPoint=new J,t&&this.setFromPoints(t)}setFromPoints(t){this.moveTo(t[0].x,t[0].y);for(let e=1,i=t.length;e<i;e++)this.lineTo(t[e].x,t[e].y);return this}moveTo(t,e){return this.currentPoint.set(t,e),this}lineTo(t,e){const i=new ro(this.currentPoint.clone(),new J(t,e));return this.curves.push(i),this.currentPoint.set(t,e),this}quadraticCurveTo(t,e,i,r){const s=new ul(this.currentPoint.clone(),new J(t,e),new J(i,r));return this.curves.push(s),this.currentPoint.set(i,r),this}bezierCurveTo(t,e,i,r,s,o){const a=new hl(this.currentPoint.clone(),new J(t,e),new J(i,r),new J(s,o));return this.curves.push(a),this.currentPoint.set(s,o),this}splineThru(t){const e=[this.currentPoint.clone()].concat(t),i=new dl(e);return this.curves.push(i),this.currentPoint.copy(t[t.length-1]),this}arc(t,e,i,r,s,o){const a=this.currentPoint.x,l=this.currentPoint.y;return this.absarc(t+a,e+l,i,r,s,o),this}absarc(t,e,i,r,s,o){return this.absellipse(t,e,i,i,r,s,o),this}ellipse(t,e,i,r,s,o,a,l){const c=this.currentPoint.x,h=this.currentPoint.y;return this.absellipse(t+c,e+h,i,r,s,o,a,l),this}absellipse(t,e,i,r,s,o,a,l){const c=new io(t,e,i,r,s,o,a,l);if(this.curves.length>0){const u=c.getPoint(0);u.equals(this.currentPoint)||this.lineTo(u.x,u.y)}this.curves.push(c);const h=c.getPoint(1);return this.currentPoint.copy(h),this}copy(t){return super.copy(t),this.currentPoint.copy(t.currentPoint),this}toJSON(){const t=super.toJSON();return t.currentPoint=this.currentPoint.toArray(),t}fromJSON(t){return super.fromJSON(t),this.currentPoint.fromArray(t.currentPoint),this}}class fl extends Ca{constructor(t){super(t),this.uuid=bt.generateUUID(),this.type="Shape",this.holes=[]}getPointsHoles(t){const e=[];for(let i=0,r=this.holes.length;i<r;i++)e[i]=this.holes[i].getPoints(t);return e}extractPoints(t){return{shape:this.getPoints(t),holes:this.getPointsHoles(t)}}copy(t){super.copy(t),this.holes=[];for(let e=0,i=t.holes.length;e<i;e++){const r=t.holes[e];this.holes.push(r.clone())}return this}toJSON(){const t=super.toJSON();t.uuid=this.uuid,t.holes=[];for(let e=0,i=this.holes.length;e<i;e++){const r=this.holes[e];t.holes.push(r.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.uuid=t.uuid,this.holes=[];for(let e=0,i=t.holes.length;e<i;e++){const r=t.holes[e];this.holes.push(new Ca().fromJSON(r))}return this}}class nn extends xt{constructor(t,e=1){super(),this.type="Light",this.color=new pt(t),this.intensity=e}copy(t){return super.copy(t),this.color.copy(t.color),this.intensity=t.intensity,this}toJSON(t){const e=super.toJSON(t);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,this.groundColor!==void 0&&(e.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(e.object.distance=this.distance),this.angle!==void 0&&(e.object.angle=this.angle),this.decay!==void 0&&(e.object.decay=this.decay),this.penumbra!==void 0&&(e.object.penumbra=this.penumbra),this.shadow!==void 0&&(e.object.shadow=this.shadow.toJSON()),e}}nn.prototype.isLight=!0;class by extends nn{constructor(t,e,i){super(t,i),this.type="HemisphereLight",this.position.copy(xt.DefaultUp),this.updateMatrix(),this.groundColor=new pt(e)}copy(t){return nn.prototype.copy.call(this,t),this.groundColor.copy(t.groundColor),this}}by.prototype.isHemisphereLight=!0;const rh=new dt,sh=new A,oh=new A;class pl{constructor(t){this.camera=t,this.bias=0,this.normalBias=0,this.radius=1,this.mapSize=new J(512,512),this.map=null,this.mapPass=null,this.matrix=new dt,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new to,this._frameExtents=new J(1,1),this._viewportCount=1,this._viewports=[new Ft(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(t){const e=this.camera,i=this.matrix;sh.setFromMatrixPosition(t.matrixWorld),e.position.copy(sh),oh.setFromMatrixPosition(t.target.matrixWorld),e.lookAt(oh),e.updateMatrixWorld(),rh.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(rh),i.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),i.multiply(e.projectionMatrix),i.multiply(e.matrixWorldInverse)}getViewport(t){return this._viewports[t]}getFrameExtents(){return this._frameExtents}copy(t){return this.camera=t.camera.clone(),this.bias=t.bias,this.radius=t.radius,this.mapSize.copy(t.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const t={};return this.bias!==0&&(t.bias=this.bias),this.normalBias!==0&&(t.normalBias=this.normalBias),this.radius!==1&&(t.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}}class Qu extends pl{constructor(){super(new ue(50,1,.5,500)),this.focus=1}updateMatrices(t){const e=this.camera,i=bt.RAD2DEG*2*t.angle*this.focus,r=this.mapSize.width/this.mapSize.height,s=t.distance||e.far;(i!==e.fov||r!==e.aspect||s!==e.far)&&(e.fov=i,e.aspect=r,e.far=s,e.updateProjectionMatrix()),super.updateMatrices(t)}}Qu.prototype.isSpotLightShadow=!0;class wy extends nn{constructor(t,e,i=0,r=Math.PI/3,s=0,o=1){super(t,e),this.type="SpotLight",this.position.copy(xt.DefaultUp),this.updateMatrix(),this.target=new xt,this.distance=i,this.angle=r,this.penumbra=s,this.decay=o,this.shadow=new Qu}get power(){return this.intensity*Math.PI}set power(t){this.intensity=t/Math.PI}copy(t){return super.copy(t),this.distance=t.distance,this.angle=t.angle,this.penumbra=t.penumbra,this.decay=t.decay,this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}wy.prototype.isSpotLight=!0;const ah=new dt,hr=new A,Xo=new A;class $u extends pl{constructor(){super(new ue(90,1,.5,500)),this._frameExtents=new J(4,2),this._viewportCount=6,this._viewports=[new Ft(2,1,1,1),new Ft(0,1,1,1),new Ft(3,1,1,1),new Ft(1,1,1,1),new Ft(3,0,1,1),new Ft(1,0,1,1)],this._cubeDirections=[new A(1,0,0),new A(-1,0,0),new A(0,0,1),new A(0,0,-1),new A(0,1,0),new A(0,-1,0)],this._cubeUps=[new A(0,1,0),new A(0,1,0),new A(0,1,0),new A(0,1,0),new A(0,0,1),new A(0,0,-1)]}updateMatrices(t,e=0){const i=this.camera,r=this.matrix;hr.setFromMatrixPosition(t.matrixWorld),i.position.copy(hr),Xo.copy(i.position),Xo.add(this._cubeDirections[e]),i.up.copy(this._cubeUps[e]),i.lookAt(Xo),i.updateMatrixWorld(),r.makeTranslation(-hr.x,-hr.y,-hr.z),ah.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),this._frustum.setFromProjectionMatrix(ah)}}$u.prototype.isPointLightShadow=!0;class My extends nn{constructor(t,e,i=0,r=1){super(t,e),this.type="PointLight",this.distance=i,this.decay=r,this.shadow=new $u}get power(){return this.intensity*4*Math.PI}set power(t){this.intensity=t/(4*Math.PI)}copy(t){return super.copy(t),this.distance=t.distance,this.decay=t.decay,this.shadow=t.shadow.clone(),this}}My.prototype.isPointLight=!0;class Ku extends Hi{constructor(t=-1,e=1,i=1,r=-1,s=.1,o=2e3){super(),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=i,this.bottom=r,this.near=s,this.far=o,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=t.view===null?null:Object.assign({},t.view),this}setViewOffset(t,e,i,r,s,o){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=i,this.view.offsetY=r,this.view.width=s,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),i=(this.right+this.left)/2,r=(this.top+this.bottom)/2;let s=i-t,o=i+t,a=r+e,l=r-e;if(this.view!==null&&this.view.enabled){const c=(this.right-this.left)/this.view.fullWidth/this.zoom,h=(this.top-this.bottom)/this.view.fullHeight/this.zoom;s+=c*this.view.offsetX,o=s+c*this.view.width,a-=h*this.view.offsetY,l=a-h*this.view.height}this.projectionMatrix.makeOrthographic(s,o,a,l,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=xt.prototype.toJSON.call(this,t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,this.view!==null&&(e.object.view=Object.assign({},this.view)),e}}Ku.prototype.isOrthographicCamera=!0;class td extends pl{constructor(){super(new Ku(-5,5,5,-5,.5,500))}}td.prototype.isDirectionalLightShadow=!0;class ml extends nn{constructor(t,e){super(t,e),this.type="DirectionalLight",this.position.copy(xt.DefaultUp),this.updateMatrix(),this.target=new xt,this.shadow=new td}copy(t){return super.copy(t),this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}ml.prototype.isDirectionalLight=!0;class Sy extends nn{constructor(t,e){super(t,e),this.type="AmbientLight"}}Sy.prototype.isAmbientLight=!0;class Ty extends nn{constructor(t,e,i=10,r=10){super(t,e),this.type="RectAreaLight",this.width=i,this.height=r}copy(t){return super.copy(t),this.width=t.width,this.height=t.height,this}toJSON(t){const e=super.toJSON(t);return e.object.width=this.width,e.object.height=this.height,e}}Ty.prototype.isRectAreaLight=!0;class ed{constructor(){this.coefficients=[];for(let t=0;t<9;t++)this.coefficients.push(new A)}set(t){for(let e=0;e<9;e++)this.coefficients[e].copy(t[e]);return this}zero(){for(let t=0;t<9;t++)this.coefficients[t].set(0,0,0);return this}getAt(t,e){const i=t.x,r=t.y,s=t.z,o=this.coefficients;return e.copy(o[0]).multiplyScalar(.282095),e.addScaledVector(o[1],.488603*r),e.addScaledVector(o[2],.488603*s),e.addScaledVector(o[3],.488603*i),e.addScaledVector(o[4],1.092548*(i*r)),e.addScaledVector(o[5],1.092548*(r*s)),e.addScaledVector(o[6],.315392*(3*s*s-1)),e.addScaledVector(o[7],1.092548*(i*s)),e.addScaledVector(o[8],.546274*(i*i-r*r)),e}getIrradianceAt(t,e){const i=t.x,r=t.y,s=t.z,o=this.coefficients;return e.copy(o[0]).multiplyScalar(.886227),e.addScaledVector(o[1],2*.511664*r),e.addScaledVector(o[2],2*.511664*s),e.addScaledVector(o[3],2*.511664*i),e.addScaledVector(o[4],2*.429043*i*r),e.addScaledVector(o[5],2*.429043*r*s),e.addScaledVector(o[6],.743125*s*s-.247708),e.addScaledVector(o[7],2*.429043*i*s),e.addScaledVector(o[8],.429043*(i*i-r*r)),e}add(t){for(let e=0;e<9;e++)this.coefficients[e].add(t.coefficients[e]);return this}addScaledSH(t,e){for(let i=0;i<9;i++)this.coefficients[i].addScaledVector(t.coefficients[i],e);return this}scale(t){for(let e=0;e<9;e++)this.coefficients[e].multiplyScalar(t);return this}lerp(t,e){for(let i=0;i<9;i++)this.coefficients[i].lerp(t.coefficients[i],e);return this}equals(t){for(let e=0;e<9;e++)if(!this.coefficients[e].equals(t.coefficients[e]))return!1;return!0}copy(t){return this.set(t.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(t,e=0){const i=this.coefficients;for(let r=0;r<9;r++)i[r].fromArray(t,e+r*3);return this}toArray(t=[],e=0){const i=this.coefficients;for(let r=0;r<9;r++)i[r].toArray(t,e+r*3);return t}static getBasisAt(t,e){const i=t.x,r=t.y,s=t.z;e[0]=.282095,e[1]=.488603*r,e[2]=.488603*s,e[3]=.488603*i,e[4]=1.092548*i*r,e[5]=1.092548*r*s,e[6]=.315392*(3*s*s-1),e[7]=1.092548*i*s,e[8]=.546274*(i*i-r*r)}}ed.prototype.isSphericalHarmonics3=!0;class gl extends nn{constructor(t=new ed,e=1){super(void 0,e),this.sh=t}copy(t){return super.copy(t),this.sh.copy(t.sh),this}fromJSON(t){return this.intensity=t.intensity,this.sh.fromArray(t.sh),this}toJSON(t){const e=super.toJSON(t);return e.object.sh=this.sh.toArray(),e}}gl.prototype.isLightProbe=!0;const Ey={decodeText:function(n){if(typeof TextDecoder!="undefined")return new TextDecoder().decode(n);let t="";for(let e=0,i=n.length;e<i;e++)t+=String.fromCharCode(n[e]);try{return decodeURIComponent(escape(t))}catch{return t}},extractUrlBase:function(n){const t=n.lastIndexOf("/");return t===-1?"./":n.substr(0,t+1)}};function Ra(){Dt.call(this),this.type="InstancedBufferGeometry",this.instanceCount=1/0}Ra.prototype=Object.assign(Object.create(Dt.prototype),{constructor:Ra,isInstancedBufferGeometry:!0,copy:function(n){return Dt.prototype.copy.call(this,n),this.instanceCount=n.instanceCount,this},clone:function(){return new this.constructor().copy(this)},toJSON:function(){const n=Dt.prototype.toJSON.call(this);return n.instanceCount=this.instanceCount,n.isInstancedBufferGeometry=!0,n}});function lh(n,t,e,i){typeof e=="number"&&(i=e,e=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),Mt.call(this,n,t,e),this.meshPerAttribute=i||1}lh.prototype=Object.assign(Object.create(Mt.prototype),{constructor:lh,isInstancedBufferAttribute:!0,copy:function(n){return Mt.prototype.copy.call(this,n),this.meshPerAttribute=n.meshPerAttribute,this},toJSON:function(){const n=Mt.prototype.toJSON.call(this);return n.meshPerAttribute=this.meshPerAttribute,n.isInstancedBufferAttribute=!0,n}});function ch(n){typeof createImageBitmap=="undefined"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch=="undefined"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),ge.call(this,n),this.options={premultiplyAlpha:"none"}}ch.prototype=Object.assign(Object.create(ge.prototype),{constructor:ch,isImageBitmapLoader:!0,setOptions:function(t){return this.options=t,this},load:function(n,t,e,i){n===void 0&&(n=""),this.path!==void 0&&(n=this.path+n),n=this.manager.resolveURL(n);const r=this,s=Vi.get(n);if(s!==void 0)return r.manager.itemStart(n),setTimeout(function(){t&&t(s),r.manager.itemEnd(n)},0),s;const o={};o.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",o.headers=this.requestHeader,fetch(n,o).then(function(a){return a.blob()}).then(function(a){return createImageBitmap(a,Object.assign(r.options,{colorSpaceConversion:"none"}))}).then(function(a){Vi.add(n,a),t&&t(a),r.manager.itemEnd(n)}).catch(function(a){i&&i(a),r.manager.itemError(n),r.manager.itemEnd(n)}),r.manager.itemStart(n)}});class Ay extends gl{constructor(t,e,i=1){super(void 0,i);const r=new pt().set(t),s=new pt().set(e),o=new A(r.r,r.g,r.b),a=new A(s.r,s.g,s.b),l=Math.sqrt(Math.PI),c=l*Math.sqrt(.75);this.sh.coefficients[0].copy(o).add(a).multiplyScalar(l),this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(c)}}Ay.prototype.isHemisphereLightProbe=!0;class Ly extends gl{constructor(t,e=1){super(void 0,e);const i=new pt().set(t);this.sh.coefficients[0].set(i.r,i.g,i.b).multiplyScalar(2*Math.sqrt(Math.PI))}}Ly.prototype.isAmbientLightProbe=!0;new dt;new dt;class Cy{constructor(t,e,i){this.binding=t,this.valueSize=i;let r,s,o;switch(e){case"quaternion":r=this._slerp,s=this._slerpAdditive,o=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(i*6),this._workIndex=5;break;case"string":case"bool":r=this._select,s=this._select,o=this._setAdditiveIdentityOther,this.buffer=new Array(i*5);break;default:r=this._lerp,s=this._lerpAdditive,o=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(i*5)}this._mixBufferRegion=r,this._mixBufferRegionAdditive=s,this._setIdentity=o,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(t,e){const i=this.buffer,r=this.valueSize,s=t*r+r;let o=this.cumulativeWeight;if(o===0){for(let a=0;a!==r;++a)i[s+a]=i[a];o=e}else{o+=e;const a=e/o;this._mixBufferRegion(i,s,0,a,r)}this.cumulativeWeight=o}accumulateAdditive(t){const e=this.buffer,i=this.valueSize,r=i*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(e,r,0,t,i),this.cumulativeWeightAdditive+=t}apply(t){const e=this.valueSize,i=this.buffer,r=t*e+e,s=this.cumulativeWeight,o=this.cumulativeWeightAdditive,a=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,s<1){const l=e*this._origIndex;this._mixBufferRegion(i,r,l,1-s,e)}o>0&&this._mixBufferRegionAdditive(i,r,this._addIndex*e,1,e);for(let l=e,c=e+e;l!==c;++l)if(i[l]!==i[l+e]){a.setValue(i,r);break}}saveOriginalState(){const t=this.binding,e=this.buffer,i=this.valueSize,r=i*this._origIndex;t.getValue(e,r);for(let s=i,o=r;s!==o;++s)e[s]=e[r+s%i];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const t=this.valueSize*3;this.binding.setValue(this.buffer,t)}_setAdditiveIdentityNumeric(){const t=this._addIndex*this.valueSize,e=t+this.valueSize;for(let i=t;i<e;i++)this.buffer[i]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const t=this._origIndex*this.valueSize,e=this._addIndex*this.valueSize;for(let i=0;i<this.valueSize;i++)this.buffer[e+i]=this.buffer[t+i]}_select(t,e,i,r,s){if(r>=.5)for(let o=0;o!==s;++o)t[e+o]=t[i+o]}_slerp(t,e,i,r){me.slerpFlat(t,e,t,e,t,i,r)}_slerpAdditive(t,e,i,r,s){const o=this._workIndex*s;me.multiplyQuaternionsFlat(t,o,t,e,t,i),me.slerpFlat(t,e,t,e,t,o,r)}_lerp(t,e,i,r,s){const o=1-r;for(let a=0;a!==s;++a){const l=e+a;t[l]=t[l]*o+t[i+a]*r}}_lerpAdditive(t,e,i,r,s){for(let o=0;o!==s;++o){const a=e+o;t[a]=t[a]+t[i+o]*r}}}const _l="\\[\\]\\.:\\/",Ry=new RegExp("["+_l+"]","g"),xl="[^"+_l+"]",Py="[^"+_l.replace("\\.","")+"]",Dy=/((?:WC+[\/:])*)/.source.replace("WC",xl),Iy=/(WCOD+)?/.source.replace("WCOD",Py),Fy=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",xl),Ny=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",xl),Oy=new RegExp("^"+Dy+Iy+Fy+Ny+"$"),By=["material","materials","bones"];function nd(n,t,e){const i=e||ze.parseTrackName(t);this._targetGroup=n,this._bindings=n.subscribe_(t,i)}Object.assign(nd.prototype,{getValue:function(n,t){this.bind();const e=this._targetGroup.nCachedObjects_,i=this._bindings[e];i!==void 0&&i.getValue(n,t)},setValue:function(n,t){const e=this._bindings;for(let i=this._targetGroup.nCachedObjects_,r=e.length;i!==r;++i)e[i].setValue(n,t)},bind:function(){const n=this._bindings;for(let t=this._targetGroup.nCachedObjects_,e=n.length;t!==e;++t)n[t].bind()},unbind:function(){const n=this._bindings;for(let t=this._targetGroup.nCachedObjects_,e=n.length;t!==e;++t)n[t].unbind()}});function ze(n,t,e){this.path=t,this.parsedPath=e||ze.parseTrackName(t),this.node=ze.findNode(n,this.parsedPath.nodeName)||n,this.rootNode=n}Object.assign(ze,{Composite:nd,create:function(n,t,e){return n&&n.isAnimationObjectGroup?new ze.Composite(n,t,e):new ze(n,t,e)},sanitizeNodeName:function(n){return n.replace(/\s/g,"_").replace(Ry,"")},parseTrackName:function(n){const t=Oy.exec(n);if(!t)throw new Error("PropertyBinding: Cannot parse trackName: "+n);const e={nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]},i=e.nodeName&&e.nodeName.lastIndexOf(".");if(i!==void 0&&i!==-1){const r=e.nodeName.substring(i+1);By.indexOf(r)!==-1&&(e.nodeName=e.nodeName.substring(0,i),e.objectName=r)}if(e.propertyName===null||e.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+n);return e},findNode:function(n,t){if(!t||t===""||t==="."||t===-1||t===n.name||t===n.uuid)return n;if(n.skeleton){const e=n.skeleton.getBoneByName(t);if(e!==void 0)return e}if(n.children){const e=function(r){for(let s=0;s<r.length;s++){const o=r[s];if(o.name===t||o.uuid===t)return o;const a=e(o.children);if(a)return a}return null},i=e(n.children);if(i)return i}return null}});Object.assign(ze.prototype,{_getValue_unavailable:function(){},_setValue_unavailable:function(){},BindingType:{Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Versioning:{None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},GetterByBindingType:[function(t,e){t[e]=this.node[this.propertyName]},function(t,e){const i=this.resolvedProperty;for(let r=0,s=i.length;r!==s;++r)t[e++]=i[r]},function(t,e){t[e]=this.resolvedProperty[this.propertyIndex]},function(t,e){this.resolvedProperty.toArray(t,e)}],SetterByBindingTypeAndVersioning:[[function(t,e){this.targetObject[this.propertyName]=t[e]},function(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.needsUpdate=!0},function(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}],[function(t,e){const i=this.resolvedProperty;for(let r=0,s=i.length;r!==s;++r)i[r]=t[e++]},function(t,e){const i=this.resolvedProperty;for(let r=0,s=i.length;r!==s;++r)i[r]=t[e++];this.targetObject.needsUpdate=!0},function(t,e){const i=this.resolvedProperty;for(let r=0,s=i.length;r!==s;++r)i[r]=t[e++];this.targetObject.matrixWorldNeedsUpdate=!0}],[function(t,e){this.resolvedProperty[this.propertyIndex]=t[e]},function(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.needsUpdate=!0},function(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}],[function(t,e){this.resolvedProperty.fromArray(t,e)},function(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.needsUpdate=!0},function(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.matrixWorldNeedsUpdate=!0}]],getValue:function(t,e){this.bind(),this.getValue(t,e)},setValue:function(t,e){this.bind(),this.setValue(t,e)},bind:function(){let n=this.node;const t=this.parsedPath,e=t.objectName,i=t.propertyName;let r=t.propertyIndex;if(n||(n=ze.findNode(this.rootNode,t.nodeName)||this.rootNode,this.node=n),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!n){console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");return}if(e){let l=t.objectIndex;switch(e){case"materials":if(!n.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!n.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}n=n.material.materials;break;case"bones":if(!n.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}n=n.skeleton.bones;for(let c=0;c<n.length;c++)if(n[c].name===l){l=c;break}break;default:if(n[e]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}n=n[e]}if(l!==void 0){if(n[l]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,n);return}n=n[l]}}const s=n[i];if(s===void 0){const l=t.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+l+"."+i+" but it wasn't found.",n);return}let o=this.Versioning.None;this.targetObject=n,n.needsUpdate!==void 0?o=this.Versioning.NeedsUpdate:n.matrixWorldNeedsUpdate!==void 0&&(o=this.Versioning.MatrixWorldNeedsUpdate);let a=this.BindingType.Direct;if(r!==void 0){if(i==="morphTargetInfluences"){if(!n.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(n.geometry.isBufferGeometry){if(!n.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}n.morphTargetDictionary[r]!==void 0&&(r=n.morphTargetDictionary[r])}else{console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);return}}a=this.BindingType.ArrayElement,this.resolvedProperty=s,this.propertyIndex=r}else s.fromArray!==void 0&&s.toArray!==void 0?(a=this.BindingType.HasFromToArray,this.resolvedProperty=s):Array.isArray(s)?(a=this.BindingType.EntireArray,this.resolvedProperty=s):this.propertyName=i;this.getValue=this.GetterByBindingType[a],this.setValue=this.SetterByBindingTypeAndVersioning[a][o]},unbind:function(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}});Object.assign(ze.prototype,{_getValue_unbound:ze.prototype.getValue,_setValue_unbound:ze.prototype.setValue});class zy{constructor(t,e,i=null,r=e.blendMode){this._mixer=t,this._clip=e,this._localRoot=i,this.blendMode=r;const s=e.tracks,o=s.length,a=new Array(o),l={endingStart:Li,endingEnd:Li};for(let c=0;c!==o;++c){const h=s[c].createInterpolant(null);a[c]=h,h.settings=l}this._interpolantSettings=l,this._interpolants=a,this._propertyBindings=new Array(o),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=Qp,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(t){return this._startTime=t,this}setLoop(t,e){return this.loop=t,this.repetitions=e,this}setEffectiveWeight(t){return this.weight=t,this._effectiveWeight=this.enabled?t:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(t){return this._scheduleFading(t,0,1)}fadeOut(t){return this._scheduleFading(t,1,0)}crossFadeFrom(t,e,i){if(t.fadeOut(e),this.fadeIn(e),i){const r=this._clip.duration,s=t._clip.duration,o=s/r,a=r/s;t.warp(1,o,e),this.warp(a,1,e)}return this}crossFadeTo(t,e,i){return t.crossFadeFrom(this,e,i)}stopFading(){const t=this._weightInterpolant;return t!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}setEffectiveTimeScale(t){return this.timeScale=t,this._effectiveTimeScale=this.paused?0:t,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(t){return this.timeScale=this._clip.duration/t,this.stopWarping()}syncWith(t){return this.time=t.time,this.timeScale=t.timeScale,this.stopWarping()}halt(t){return this.warp(this._effectiveTimeScale,0,t)}warp(t,e,i){const r=this._mixer,s=r.time,o=this.timeScale;let a=this._timeScaleInterpolant;a===null&&(a=r._lendControlInterpolant(),this._timeScaleInterpolant=a);const l=a.parameterPositions,c=a.sampleValues;return l[0]=s,l[1]=s+i,c[0]=t/o,c[1]=e/o,this}stopWarping(){const t=this._timeScaleInterpolant;return t!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(t,e,i,r){if(!this.enabled){this._updateWeight(t);return}const s=this._startTime;if(s!==null){const l=(t-s)*i;if(l<0||i===0)return;this._startTime=null,e=i*l}e*=this._updateTimeScale(t);const o=this._updateTime(e),a=this._updateWeight(t);if(a>0){const l=this._interpolants,c=this._propertyBindings;switch(this.blendMode){case _u:for(let h=0,u=l.length;h!==u;++h)l[h].evaluate(o),c[h].accumulateAdditive(a);break;case nl:default:for(let h=0,u=l.length;h!==u;++h)l[h].evaluate(o),c[h].accumulate(r,a)}}}_updateWeight(t){let e=0;if(this.enabled){e=this.weight;const i=this._weightInterpolant;if(i!==null){const r=i.evaluate(t)[0];e*=r,t>i.parameterPositions[1]&&(this.stopFading(),r===0&&(this.enabled=!1))}}return this._effectiveWeight=e,e}_updateTimeScale(t){let e=0;if(!this.paused){e=this.timeScale;const i=this._timeScaleInterpolant;i!==null&&(e*=i.evaluate(t)[0],t>i.parameterPositions[1]&&(this.stopWarping(),e===0?this.paused=!0:this.timeScale=e))}return this._effectiveTimeScale=e,e}_updateTime(t){const e=this._clip.duration,i=this.loop;let r=this.time+t,s=this._loopCount;const o=i===$p;if(t===0)return s===-1?r:o&&(s&1)===1?e-r:r;if(i===Jp){s===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));t:{if(r>=e)r=e;else if(r<0)r=0;else{this.time=r;break t}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:t<0?-1:1})}}else{if(s===-1&&(t>=0?(s=0,this._setEndings(!0,this.repetitions===0,o)):this._setEndings(this.repetitions===0,!0,o)),r>=e||r<0){const a=Math.floor(r/e);r-=e*a,s+=Math.abs(a);const l=this.repetitions-s;if(l<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,r=t>0?e:0,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:t>0?1:-1});else{if(l===1){const c=t<0;this._setEndings(c,!c,o)}else this._setEndings(!1,!1,o);this._loopCount=s,this.time=r,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:a})}}else this.time=r;if(o&&(s&1)===1)return e-r}return r}_setEndings(t,e,i){const r=this._interpolantSettings;i?(r.endingStart=Ci,r.endingEnd=Ci):(t?r.endingStart=this.zeroSlopeAtStart?Ci:Li:r.endingStart=zs,e?r.endingEnd=this.zeroSlopeAtEnd?Ci:Li:r.endingEnd=zs)}_scheduleFading(t,e,i){const r=this._mixer,s=r.time;let o=this._weightInterpolant;o===null&&(o=r._lendControlInterpolant(),this._weightInterpolant=o);const a=o.parameterPositions,l=o.sampleValues;return a[0]=s,l[0]=e,a[1]=s+t,l[1]=i,this}}class ky extends kn{constructor(t){super(),this._root=t,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(t,e){const i=t._localRoot||this._root,r=t._clip.tracks,s=r.length,o=t._propertyBindings,a=t._interpolants,l=i.uuid,c=this._bindingsByRootAndName;let h=c[l];h===void 0&&(h={},c[l]=h);for(let u=0;u!==s;++u){const d=r[u],f=d.name;let p=h[f];if(p!==void 0)o[u]=p;else{if(p=o[u],p!==void 0){p._cacheIndex===null&&(++p.referenceCount,this._addInactiveBinding(p,l,f));continue}const _=e&&e._propertyBindings[u].binding.parsedPath;p=new Cy(ze.create(i,f,_),d.ValueTypeName,d.getValueSize()),++p.referenceCount,this._addInactiveBinding(p,l,f),o[u]=p}a[u].resultBuffer=p.buffer}}_activateAction(t){if(!this._isActiveAction(t)){if(t._cacheIndex===null){const i=(t._localRoot||this._root).uuid,r=t._clip.uuid,s=this._actionsByClip[r];this._bindAction(t,s&&s.knownActions[0]),this._addInactiveAction(t,r,i)}const e=t._propertyBindings;for(let i=0,r=e.length;i!==r;++i){const s=e[i];s.useCount++===0&&(this._lendBinding(s),s.saveOriginalState())}this._lendAction(t)}}_deactivateAction(t){if(this._isActiveAction(t)){const e=t._propertyBindings;for(let i=0,r=e.length;i!==r;++i){const s=e[i];--s.useCount===0&&(s.restoreOriginalState(),this._takeBackBinding(s))}this._takeBackAction(t)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const t=this;this.stats={actions:{get total(){return t._actions.length},get inUse(){return t._nActiveActions}},bindings:{get total(){return t._bindings.length},get inUse(){return t._nActiveBindings}},controlInterpolants:{get total(){return t._controlInterpolants.length},get inUse(){return t._nActiveControlInterpolants}}}}_isActiveAction(t){const e=t._cacheIndex;return e!==null&&e<this._nActiveActions}_addInactiveAction(t,e,i){const r=this._actions,s=this._actionsByClip;let o=s[e];if(o===void 0)o={knownActions:[t],actionByRoot:{}},t._byClipCacheIndex=0,s[e]=o;else{const a=o.knownActions;t._byClipCacheIndex=a.length,a.push(t)}t._cacheIndex=r.length,r.push(t),o.actionByRoot[i]=t}_removeInactiveAction(t){const e=this._actions,i=e[e.length-1],r=t._cacheIndex;i._cacheIndex=r,e[r]=i,e.pop(),t._cacheIndex=null;const s=t._clip.uuid,o=this._actionsByClip,a=o[s],l=a.knownActions,c=l[l.length-1],h=t._byClipCacheIndex;c._byClipCacheIndex=h,l[h]=c,l.pop(),t._byClipCacheIndex=null;const u=a.actionByRoot,d=(t._localRoot||this._root).uuid;delete u[d],l.length===0&&delete o[s],this._removeInactiveBindingsForAction(t)}_removeInactiveBindingsForAction(t){const e=t._propertyBindings;for(let i=0,r=e.length;i!==r;++i){const s=e[i];--s.referenceCount===0&&this._removeInactiveBinding(s)}}_lendAction(t){const e=this._actions,i=t._cacheIndex,r=this._nActiveActions++,s=e[r];t._cacheIndex=r,e[r]=t,s._cacheIndex=i,e[i]=s}_takeBackAction(t){const e=this._actions,i=t._cacheIndex,r=--this._nActiveActions,s=e[r];t._cacheIndex=r,e[r]=t,s._cacheIndex=i,e[i]=s}_addInactiveBinding(t,e,i){const r=this._bindingsByRootAndName,s=this._bindings;let o=r[e];o===void 0&&(o={},r[e]=o),o[i]=t,t._cacheIndex=s.length,s.push(t)}_removeInactiveBinding(t){const e=this._bindings,i=t.binding,r=i.rootNode.uuid,s=i.path,o=this._bindingsByRootAndName,a=o[r],l=e[e.length-1],c=t._cacheIndex;l._cacheIndex=c,e[c]=l,e.pop(),delete a[s],Object.keys(a).length===0&&delete o[r]}_lendBinding(t){const e=this._bindings,i=t._cacheIndex,r=this._nActiveBindings++,s=e[r];t._cacheIndex=r,e[r]=t,s._cacheIndex=i,e[i]=s}_takeBackBinding(t){const e=this._bindings,i=t._cacheIndex,r=--this._nActiveBindings,s=e[r];t._cacheIndex=r,e[r]=t,s._cacheIndex=i,e[i]=s}_lendControlInterpolant(){const t=this._controlInterpolants,e=this._nActiveControlInterpolants++;let i=t[e];return i===void 0&&(i=new Hs(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),i.__cacheIndex=e,t[e]=i),i}_takeBackControlInterpolant(t){const e=this._controlInterpolants,i=t.__cacheIndex,r=--this._nActiveControlInterpolants,s=e[r];t.__cacheIndex=r,e[r]=t,s.__cacheIndex=i,e[i]=s}clipAction(t,e,i){const r=e||this._root,s=r.uuid;let o=typeof t=="string"?th.findByName(r,t):t;const a=o!==null?o.uuid:t,l=this._actionsByClip[a];let c=null;if(i===void 0&&(o!==null?i=o.blendMode:i=nl),l!==void 0){const u=l.actionByRoot[s];if(u!==void 0&&u.blendMode===i)return u;c=l.knownActions[0],o===null&&(o=c._clip)}if(o===null)return null;const h=new zy(this,o,e,i);return this._bindAction(h,c),this._addInactiveAction(h,a,s),h}existingAction(t,e){const i=e||this._root,r=i.uuid,s=typeof t=="string"?th.findByName(i,t):t,o=s?s.uuid:t,a=this._actionsByClip[o];return a!==void 0&&a.actionByRoot[r]||null}stopAllAction(){const t=this._actions,e=this._nActiveActions;for(let i=e-1;i>=0;--i)t[i].stop();return this}update(t){t*=this.timeScale;const e=this._actions,i=this._nActiveActions,r=this.time+=t,s=Math.sign(t),o=this._accuIndex^=1;for(let c=0;c!==i;++c)e[c]._update(r,t,s,o);const a=this._bindings,l=this._nActiveBindings;for(let c=0;c!==l;++c)a[c].apply(o);return this}setTime(t){this.time=0;for(let e=0;e<this._actions.length;e++)this._actions[e].time=0;return this.update(t)}getRoot(){return this._root}uncacheClip(t){const e=this._actions,i=t.uuid,r=this._actionsByClip,s=r[i];if(s!==void 0){const o=s.knownActions;for(let a=0,l=o.length;a!==l;++a){const c=o[a];this._deactivateAction(c);const h=c._cacheIndex,u=e[e.length-1];c._cacheIndex=null,c._byClipCacheIndex=null,u._cacheIndex=h,e[h]=u,e.pop(),this._removeInactiveBindingsForAction(c)}delete r[i]}}uncacheRoot(t){const e=t.uuid,i=this._actionsByClip;for(const o in i){const a=i[o].actionByRoot,l=a[e];l!==void 0&&(this._deactivateAction(l),this._removeInactiveAction(l))}const r=this._bindingsByRootAndName,s=r[e];if(s!==void 0)for(const o in s){const a=s[o];a.restoreOriginalState(),this._removeInactiveBinding(a)}}uncacheAction(t,e){const i=this.existingAction(t,e);i!==null&&(this._deactivateAction(i),this._removeInactiveAction(i))}}ky.prototype._controlInterpolantsResultBuffer=new Float32Array(1);function hh(n,t,e){Oe.call(this,n,t),this.meshPerAttribute=e||1}hh.prototype=Object.assign(Object.create(Oe.prototype),{constructor:hh,isInstancedInterleavedBuffer:!0,copy:function(n){return Oe.prototype.copy.call(this,n),this.meshPerAttribute=n.meshPerAttribute,this},clone:function(n){const t=Oe.prototype.clone.call(this,n);return t.meshPerAttribute=this.meshPerAttribute,t},toJSON:function(n){const t=Oe.prototype.toJSON.call(this,n);return t.isInstancedInterleavedBuffer=!0,t.meshPerAttribute=this.meshPerAttribute,t}});function id(n,t,e,i,r){this.buffer=n,this.type=t,this.itemSize=e,this.elementSize=i,this.count=r,this.version=0}Object.defineProperty(id.prototype,"needsUpdate",{set:function(n){n===!0&&this.version++}});Object.assign(id.prototype,{isGLBufferAttribute:!0,setBuffer:function(n){return this.buffer=n,this},setType:function(n,t){return this.type=n,this.elementSize=t,this},setItemSize:function(n){return this.itemSize=n,this},setCount:function(n){return this.count=n,this}});function yl(n,t,e=0,i=1/0){this.ray=new si(n,t),this.near=e,this.far=i,this.camera=null,this.layers=new yu,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}},Object.defineProperties(this.params,{PointCloud:{get:function(){return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."),this.Points}}})}function uh(n,t){return n.distance-t.distance}function Pa(n,t,e,i){if(n.layers.test(t.layers)&&n.raycast(t,e),i===!0){const r=n.children;for(let s=0,o=r.length;s<o;s++)Pa(r[s],t,e,!0)}}Object.assign(yl.prototype,{set:function(n,t){this.ray.set(n,t)},setFromCamera:function(n,t){t&&t.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(n.x,n.y,.5).unproject(t).sub(this.ray.origin).normalize(),this.camera=t):t&&t.isOrthographicCamera?(this.ray.origin.set(n.x,n.y,(t.near+t.far)/(t.near-t.far)).unproject(t),this.ray.direction.set(0,0,-1).transformDirection(t.matrixWorld),this.camera=t):console.error("THREE.Raycaster: Unsupported camera type: "+t.type)},intersectObject:function(n,t=!1,e=[]){return Pa(n,this,e,t),e.sort(uh),e},intersectObjects:function(n,t=!1,e=[]){for(let i=0,r=n.length;i<r;i++)Pa(n[i],this,e,t);return e.sort(uh),e}});function qs(n){xt.call(this),this.material=n,this.render=function(){},this.hasPositions=!1,this.hasNormals=!1,this.hasColors=!1,this.hasUvs=!1,this.positionArray=null,this.normalArray=null,this.colorArray=null,this.uvArray=null,this.count=0}qs.prototype=Object.create(xt.prototype);qs.prototype.constructor=qs;qs.prototype.isImmediateRenderObject=!0;const Sn=new A,ws=new dt,Yo=new dt;class Uy extends Us{constructor(t){const e=rd(t),i=new Dt,r=[],s=[],o=new pt(0,0,1),a=new pt(0,1,0);for(let c=0;c<e.length;c++){const h=e[c];h.parent&&h.parent.isBone&&(r.push(0,0,0),r.push(0,0,0),s.push(o.r,o.g,o.b),s.push(a.r,a.g,a.b))}i.setAttribute("position",new Vt(r,3)),i.setAttribute("color",new Vt(s,3));const l=new qr({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(i,l),this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=t,this.bones=e,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(t){const e=this.bones,i=this.geometry,r=i.getAttribute("position");Yo.copy(this.root.matrixWorld).invert();for(let s=0,o=0;s<e.length;s++){const a=e[s];a.parent&&a.parent.isBone&&(ws.multiplyMatrices(Yo,a.matrixWorld),Sn.setFromMatrixPosition(ws),r.setXYZ(o,Sn.x,Sn.y,Sn.z),ws.multiplyMatrices(Yo,a.parent.matrixWorld),Sn.setFromMatrixPosition(ws),r.setXYZ(o+1,Sn.x,Sn.y,Sn.z),o+=2)}i.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(t)}}function rd(n){const t=[];n&&n.isBone&&t.push(n);for(let e=0;e<n.children.length;e++)t.push.apply(t,rd(n.children[e]));return t}class Hy extends Us{constructor(t=10,e=10,i=4473924,r=8947848){i=new pt(i),r=new pt(r);const s=e/2,o=t/e,a=t/2,l=[],c=[];for(let d=0,f=0,p=-a;d<=e;d++,p+=o){l.push(-a,0,p,a,0,p),l.push(p,0,-a,p,0,a);const _=d===s?i:r;_.toArray(c,f),f+=3,_.toArray(c,f),f+=3,_.toArray(c,f),f+=3,_.toArray(c,f),f+=3}const h=new Dt;h.setAttribute("position",new Vt(l,3)),h.setAttribute("color",new Vt(c,3));const u=new qr({vertexColors:!0,toneMapped:!1});super(h,u),this.type="GridHelper"}}const Gy=new Float32Array(1);new Int32Array(Gy.buffer);const Vy=new il({side:Kt,depthWrite:!1,depthTest:!1});new ne(new rl,Vy);Me.create=function(n,t){return console.log("THREE.Curve.create() has been deprecated"),n.prototype=Object.create(Me.prototype),n.prototype.constructor=n,n.prototype.getPoint=t,n};Ca.prototype.fromPoints=function(n){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(n)};Hy.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")};Uy.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")};ge.prototype.extractUrlBase=function(n){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),Ey.extractUrlBase(n)};ge.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}};Ge.prototype.center=function(n){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(n)};Ge.prototype.empty=function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()};Ge.prototype.isIntersectionBox=function(n){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(n)};Ge.prototype.isIntersectionSphere=function(n){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(n)};Ge.prototype.size=function(n){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(n)};ji.prototype.empty=function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()};to.prototype.setFromMatrix=function(n){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(n)};bt.random16=function(){return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."),Math.random()};bt.nearestPowerOfTwo=function(n){return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."),bt.floorPowerOfTwo(n)};bt.nextPowerOfTwo=function(n){return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."),bt.ceilPowerOfTwo(n)};ae.prototype.flattenToArrayOffset=function(n,t){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(n,t)};ae.prototype.multiplyVector3=function(n){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),n.applyMatrix3(this)};ae.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")};ae.prototype.applyToBufferAttribute=function(n){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),n.applyMatrix3(this)};ae.prototype.applyToVector3Array=function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")};ae.prototype.getInverse=function(n){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(n).invert()};dt.prototype.extractPosition=function(n){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(n)};dt.prototype.flattenToArrayOffset=function(n,t){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(n,t)};dt.prototype.getPosition=function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),new A().setFromMatrixColumn(this,3)};dt.prototype.setRotationFromQuaternion=function(n){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(n)};dt.prototype.multiplyToArray=function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")};dt.prototype.multiplyVector3=function(n){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),n.applyMatrix4(this)};dt.prototype.multiplyVector4=function(n){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),n.applyMatrix4(this)};dt.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")};dt.prototype.rotateAxis=function(n){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),n.transformDirection(this)};dt.prototype.crossVector=function(n){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),n.applyMatrix4(this)};dt.prototype.translate=function(){console.error("THREE.Matrix4: .translate() has been removed.")};dt.prototype.rotateX=function(){console.error("THREE.Matrix4: .rotateX() has been removed.")};dt.prototype.rotateY=function(){console.error("THREE.Matrix4: .rotateY() has been removed.")};dt.prototype.rotateZ=function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")};dt.prototype.rotateByAxis=function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")};dt.prototype.applyToBufferAttribute=function(n){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),n.applyMatrix4(this)};dt.prototype.applyToVector3Array=function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")};dt.prototype.makeFrustum=function(n,t,e,i,r,s){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(n,t,i,e,r,s)};dt.prototype.getInverse=function(n){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(n).invert()};Ke.prototype.isIntersectionLine=function(n){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(n)};me.prototype.multiplyVector3=function(n){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),n.applyQuaternion(this)};me.prototype.inverse=function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()};si.prototype.isIntersectionBox=function(n){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(n)};si.prototype.isIntersectionPlane=function(n){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(n)};si.prototype.isIntersectionSphere=function(n){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(n)};Jt.prototype.area=function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()};Jt.prototype.barycoordFromPoint=function(n,t){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(n,t)};Jt.prototype.midpoint=function(n){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(n)};Jt.prototypenormal=function(n){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(n)};Jt.prototype.plane=function(n){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(n)};Jt.barycoordFromPoint=function(n,t,e,i,r){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),Jt.getBarycoord(n,t,e,i,r)};Jt.normal=function(n,t,e,i){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),Jt.getNormal(n,t,e,i)};fl.prototype.extractAllPoints=function(n){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(n)};fl.prototype.extrude=function(n){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new no(this,n)};fl.prototype.makeGeometry=function(n){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new Qx(this,n)};J.prototype.fromAttribute=function(n,t,e){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(n,t,e)};J.prototype.distanceToManhattan=function(n){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(n)};J.prototype.lengthManhattan=function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};A.prototype.setEulerFromRotationMatrix=function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")};A.prototype.setEulerFromQuaternion=function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")};A.prototype.getPositionFromMatrix=function(n){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(n)};A.prototype.getScaleFromMatrix=function(n){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(n)};A.prototype.getColumnFromMatrix=function(n,t){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(t,n)};A.prototype.applyProjection=function(n){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(n)};A.prototype.fromAttribute=function(n,t,e){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(n,t,e)};A.prototype.distanceToManhattan=function(n){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(n)};A.prototype.lengthManhattan=function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};Ft.prototype.fromAttribute=function(n,t,e){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(n,t,e)};Ft.prototype.lengthManhattan=function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};xt.prototype.getChildByName=function(n){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(n)};xt.prototype.renderDepth=function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")};xt.prototype.translate=function(n,t){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(t,n)};xt.prototype.getWorldRotation=function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")};xt.prototype.applyMatrix=function(n){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(n)};Object.defineProperties(xt.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(n){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=n}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}});ne.prototype.setDrawMode=function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")};Object.defineProperties(ne.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),Kp},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}});va.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")};Object.defineProperty(Me.prototype,"__arcLengthDivisions",{get:function(){return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),this.arcLengthDivisions},set:function(n){console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),this.arcLengthDivisions=n}});ue.prototype.setLens=function(n,t){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),t!==void 0&&(this.filmGauge=t),this.setFocalLength(n)};Object.defineProperties(nn.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(n){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=n}},shadowCameraLeft:{set:function(n){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=n}},shadowCameraRight:{set:function(n){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=n}},shadowCameraTop:{set:function(n){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=n}},shadowCameraBottom:{set:function(n){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=n}},shadowCameraNear:{set:function(n){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=n}},shadowCameraFar:{set:function(n){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=n}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(n){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=n}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(n){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=n}},shadowMapHeight:{set:function(n){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=n}}});Object.defineProperties(Mt.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===Fr},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(Fr)}}});Mt.prototype.setDynamic=function(n){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(n===!0?Fr:$s),this};Mt.prototype.copyIndicesArray=function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},Mt.prototype.setArray=function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")};Dt.prototype.addIndex=function(n){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(n)};Dt.prototype.addAttribute=function(n,t){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),!(t&&t.isBufferAttribute)&&!(t&&t.isInterleavedBufferAttribute)?(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(n,new Mt(arguments[1],arguments[2]))):n==="index"?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(t),this):this.setAttribute(n,t)};Dt.prototype.addDrawCall=function(n,t,e){e!==void 0&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(n,t)};Dt.prototype.clearDrawCalls=function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()};Dt.prototype.computeOffsets=function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")};Dt.prototype.removeAttribute=function(n){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(n)};Dt.prototype.applyMatrix=function(n){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(n)};Object.defineProperties(Dt.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}});Object.defineProperties(Ra.prototype,{maxInstancedCount:{get:function(){return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),this.instanceCount},set:function(n){console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),this.instanceCount=n}}});Object.defineProperties(yl.prototype,{linePrecision:{get:function(){return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),this.params.Line.threshold},set:function(n){console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),this.params.Line.threshold=n}}});Object.defineProperties(Oe.prototype,{dynamic:{get:function(){return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),this.usage===Fr},set:function(n){console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),this.setUsage(n)}}});Oe.prototype.setDynamic=function(n){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(n===!0?Fr:$s),this};Oe.prototype.setArray=function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")};no.prototype.getArrays=function(){console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")};no.prototype.addShapeList=function(){console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")};no.prototype.addShape=function(){console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")};al.prototype.dispose=function(){console.error("THREE.Scene: .dispose() has been removed.")};Object.defineProperties(Xt.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new pt}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(n){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=n===Ja}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(n){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=n}}});Object.defineProperties(ll.prototype,{metal:{get:function(){return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."),!1},set:function(){console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")}}});Object.defineProperties(Gi.prototype,{transparency:{get:function(){return console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),this.transmission},set:function(n){console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),this.transmission=n}}});Object.defineProperties(Ue.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(n){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=n}}});Nt.prototype.clearTarget=function(n,t,e,i){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(n),this.clear(t,e,i)};Nt.prototype.animate=function(n){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(n)};Nt.prototype.getCurrentRenderTarget=function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()};Nt.prototype.getMaxAnisotropy=function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()};Nt.prototype.getPrecision=function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision};Nt.prototype.resetGLState=function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()};Nt.prototype.supportsFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")};Nt.prototype.supportsHalfFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")};Nt.prototype.supportsStandardDerivatives=function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")};Nt.prototype.supportsCompressedTextureS3TC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")};Nt.prototype.supportsCompressedTexturePVRTC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")};Nt.prototype.supportsBlendMinMax=function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")};Nt.prototype.supportsVertexTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures};Nt.prototype.supportsInstancedArrays=function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")};Nt.prototype.enableScissorTest=function(n){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(n)};Nt.prototype.initMaterial=function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")};Nt.prototype.addPrePlugin=function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")};Nt.prototype.addPostPlugin=function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")};Nt.prototype.updateShadowMap=function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")};Nt.prototype.setFaceCulling=function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")};Nt.prototype.allocTextureUnit=function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")};Nt.prototype.setTexture=function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")};Nt.prototype.setTexture2D=function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")};Nt.prototype.setTextureCube=function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")};Nt.prototype.getActiveMipMapLevel=function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()};Object.defineProperties(Nt.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(n){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=n}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(n){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=n}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(n){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=n===!0?xu:Wr}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}}});Object.defineProperties(Ou.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}});Object.defineProperties(ti.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(n){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=n}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(n){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=n}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(n){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=n}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(n){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=n}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(n){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=n}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(n){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=n}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(n){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=n}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(n){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=n}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(n){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=n}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(n){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=n}}});sl.prototype.updateCubeMap=function(n,t){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(n,t)};sl.prototype.clear=function(n,t,e,i){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(n,t,e,i)};qi.crossOrigin=void 0;qi.loadTexture=function(n,t,e,i){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const r=new La;r.setCrossOrigin(this.crossOrigin);const s=r.load(n,e,void 0,i);return t&&(s.mapping=t),s};qi.loadTextureCube=function(n,t,e,i){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const r=new hy;r.setCrossOrigin(this.crossOrigin);const s=r.load(n,e,void 0,i);return t&&(s.mapping=t),s};qi.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")};qi.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")};typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:du}}));typeof window!="undefined"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=du);document.addEventListener("DOMContentLoaded",function(){var n=document.getElementById("button_enter"),t=document.getElementById("enter_container");setTimeout(()=>{n.classList.add("button-enter"),n.classList.remove("op-0"),t.classList.add("enter-container"),t.classList.remove("op-0")},3e3)});const dh=new yl,so=new al,Zn=new ue(85,innerWidth/innerHeight,.1,1e3),oo=new Nt,Da=document.getElementById("app");oo.setSize(innerWidth,innerHeight);oo.setPixelRatio(devicePixelRatio);Da.appendChild(oo.domElement);Zn.position.z=50;const Wy=new Su(200,200,50,50),qy=new ll({side:Vr,flatShading:Ja,vertexColors:!0}),Ze=new ne(Wy,qy);so.add(Ze);const{array:qn}=Ze.geometry.attributes.position,sd=[];for(let n=0;n<Object.keys(qn).length;n++){if(n%3===0){const t=qn[n],e=qn[n+1],i=qn[n+2];qn[n]=t+(Math.random()-.5)*3,qn[n+1]=e+(Math.random()-.5)*3,qn[n+2]=i+(Math.random()-.5)*3}sd.push(Math.random()*Math.PI*2)}Ze.geometry.attributes.position.originalPosition=Ze.geometry.attributes.position.array;Ze.geometry.attributes.position.randomValues=sd;const od=[];for(let n=0;n<Ze.geometry.attributes.position.count;n++)od.push(0,.6,0);Ze.geometry.setAttribute("color",new Mt(new Float32Array(od),3));const ad=new ml(4626431,1);ad.position.set(0,1,1);so.add(ad);const ld=new ml(4626431,1);ld.position.set(0,0,-1);so.add(ld);const Ia={x:void 0,y:void 0};let Zo=0;function cd(){requestAnimationFrame(cd),oo.render(so,Zn),dh.setFromCamera(Ia,Zn),Zo+=.01;const{array:n,originalPosition:t,randomValues:e}=Ze.geometry.attributes.position;for(let r=0;r<n.length;r+=3)n[r]=t[r]+Math.cos(Zo+e[r])*.001,n[r+1]=t[r+1]+Math.sin(Zo+e[r+1])*.003;Ze.geometry.attributes.position.needsUpdate=!0;const i=dh.intersectObject(Ze);if(i.length>0){const{color:r}=i[0].object.geometry.attributes;r.needsUpdate=!0;const s={r:0,g:.1,b:0},o={r:0,g:.5,b:0};uu.to(o,{r:s.r,g:s.g,b:s.b,duration:1,onUpdate:()=>{r.setX(i[0].face.a,o.r),r.setY(i[0].face.a,o.g),r.setZ(i[0].face.a,o.b),r.setX(i[0].face.b,o.r),r.setY(i[0].face.b,o.g),r.setZ(i[0].face.b,o.r),r.setX(i[0].face.c,o.r),r.setY(i[0].face.c,o.g),r.setZ(i[0].face.c,o.r),r.needsUpdate=!0}})}}cd();let jy=document.getElementById("button_enter");jy.addEventListener("click",function(){for(let n=0;n<130;n++)setTimeout(()=>{Ze.rotation.x+=-.01,Zn.position.z+=-.3,Zn.position.y+=.2},n*9);setTimeout(()=>{for(let n=0;n<2e3;n++)setTimeout(()=>{Zn.position.z+=-.3,Zn.position.y+=.01},n*3)},1200),setTimeout(()=>{Da.classList.add("opacity-zero")},1e3),setTimeout(()=>{Da.innerHTML=""},2700),setTimeout(()=>{var n=document.getElementById("background_space");n.classList.add("enter-space"),n.classList.remove("d-none");var t=document.getElementById("main");t.classList.add("main_weather_container"),t.classList.remove("d-none");var e=document.getElementById("crystal_weather_container_1");e.classList.add("main_weather_container_1"),e.classList.remove("d-none");var i=document.getElementById("crystal_weather_container_2");i.classList.add("main_weather_container_2"),i.classList.remove("d-none")},3e3)},!1);addEventListener("mousemove",n=>{Ia.x=n.clientX/innerWidth*2-1,Ia.y=-(n.clientY/innerHeight)*2+1});const Xy="https://api.open-meteo.com/v1/forecast",Yy=new URLSearchParams({latitude:"52.52",longitude:"13.41",current:"temperature_2m",hourly:"temperature_2m",timezone:"America/Los_Angeles",forecast_days:"1"});var Jo;const Fa=document.getElementById("weatherChart"),hd=Fa.getContext("2d");document.addEventListener("DOMContentLoaded",()=>{if(Fa.width=600,Fa.height=150,!hd){console.error("Canvas not loaded");return}ud(Yy)});async function ud(n){await fetch(`${Xy}?${n}`).then(t=>t.json()).then(t=>{Jo&&Jo.destroy();const e=t.hourly,r=e.temperature_2m,s=e.time.map(o=>o.split("T")[1]);Jo=new Chart(hd,{type:"line",data:{labels:s,datasets:[{label:"",data:r,borderColor:"rgba(255, 124, 0, 1)",backgroundColor:"rgba(255, 124, 0, 2)",borderWidth:1}]},options:{plugins:{legend:{display:!1}},scales:{x:{title:{display:!0,text:"Time"}},y:{title:{display:!0,text:"Temperature (\xB0C)"}}}}})}).catch(t=>console.error("Error fetching weather data:",t))}const Zy="prj_test_pk_3d00dceaab6b3dd8142567ff19565bcf79df6489",dd=new Headers;dd.append("Authorization",Zy);var fd={method:"GET",headers:dd,redirect:"follow"},Ms=localStorage.getItem("current_city"),Qo=document.getElementById("search_bar"),ni=document.getElementById("input_city_selector");let Jy=document.getElementById("daily_container"),fh=document.getElementById("hourlyContainer");var Qy=document.getElementById("background_space"),$y=document.getElementById("weather_code_text");document.addEventListener("DOMContentLoaded",function(){Ms!==null?(Ms=JSON.parse(Ms),js(Ms)):rv(),Qo.addEventListener("keyup",function(){Qo.value.length>3?(ni.classList.remove("d-none"),Ky(Qo.value)):ni.classList.add("d-none")})});async function js(n){let t=n.latitude,e=n.longitude,i=document.getElementById("current_city"),r=document.getElementById("current_temperature");const s=new URLSearchParams({latitude:t,longitude:e,current:"temperature_2m",hourly:"temperature_2m",timezone:"America/Los_Angeles",forecast_days:"1"});ud(s),await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${t}&longitude=${e}&current=temperature_2m,relative_humidity_2m,apparent_temperature,precipitation,weather_code,wind_speed_10m&hourly=temperature_2m,relative_humidity_2m,weather_code&daily=weather_code,temperature_2m_max,temperature_2m_min&timezone=America%2FLos_Angeles&limit=8`).then(o=>o.json()).then(o=>{var a=ov(o.current.weather_code);console.log(a),Qy.src=a.image,$y.innerHTML=a.text,localStorage.setItem("current_city",JSON.stringify({name:n.name,latitude:t,longitude:e,temperature_2m:o.current.temperature_2m})),i.textContent=n.name,r.textContent=o.current.temperature_2m+"\xB0C",nv(o),iv(o)}).catch(o=>console.log(o))}async function Ky(n){await fetch(`https://api.radar.io/v1/search/autocomplete?query=${n}`,fd).then(t=>t.text()).then(e=>{var e=JSON.parse(e);ni.innerHTML="",tv(e.addresses)}).catch(t=>console.error(t))}function tv(n){n.length>0?(ni.innerHTML="",n.forEach(t=>{var e=document.createElement("option");e.id=t.formattedAddress,e.longitude=t.longitude,e.latitude=t.latitude,e.name=t.formattedAddress,e.value=t.formattedAddress,e.innerHTML=t.formattedAddress,e.setAttribute("style","text-align: start;padding: 5px 0px 3px 15px;cursor: pointer;"),e.classList.add("selector_option"),ni.append(e)}),ev()):ni.classList.add("d-none")}function ev(){var n=document.getElementsByClassName("selector_option");for(let t=0;t<n.length;t++)n[t].addEventListener("click",function(i){js(i.target),ni.classList.add("d-none")})}function nv(n){Jy.innerHTML="",console.log(n.daily)}function iv(n){fh.innerHTML="";for(let o=0;o<24;o++){var t=n.hourly.temperature_2m[o],e=document.createElement("div"),i=document.createElement("h4");i.innerHTML=n.hourly.time[o].split("T")[1],i.classList.add("black-background"),i.setAttribute("style","margin-bottom:0;text-align:center;");var r=document.createElement("p");r.innerHTML=t+" \xB0C",r.classList.add("black-background"),r.setAttribute("style","font-size: 16px;margin-top:0;margin-bottom:0;text-align:center;");var s=document.createElement("div");s.setAttribute("style","max-width: 100px;display: flex;flex-direction: column;justify-content: space-between;"),s.classList.add("glass-card"),s.append(r),s.append(i),e.append(s),fh.append(e),o=o+2}}async function rv(){return new Promise((n,t)=>{if(navigator.geolocation)navigator.geolocation.getCurrentPosition(e=>{let i={latitude:e.coords.latitude,longitude:e.coords.longitude,name:"",stateCode:"",countryCode:"",formattedAddress:""};sv(i.latitude,i.longitude).then(r=>{var s,o,a;i.name=(s=r.city)!=null?s:"Vancouver",i.stateCode=(o=r.stateCode)!=null?o:"BC",i.countryCode=(a=r.countryCode)!=null?a:"CA",i.formattedAddress=i.name+", "+i.stateCode+" "+i.countryCode,js(i),n(i)})},e=>{t(new Error("Error getting location: "+e.message))},{enableHighAccuracy:!0,timeout:5e3,maximumAge:0});else{let e={latitude:49.2819,longitude:-123.11874,name:"Vancouver",stateCode:"BC",countryCode:"CA",formattedAddress:"Vancouver, BC CA"};js(e),n(e)}})}async function sv(n,t){return await fetch(`https://api.radar.io/v1/geocode/reverse?coordinates=${n},${t}`,fd).then(e=>e.json()).then(e=>e.addresses[0]).catch(e=>console.error(e))}function ov(n){switch(n){case 0:var t="/src/media/images/sunny.jpg",e="Clear sky";break;case 1:case 2:case 3:var t="/src/media/images/cloudy.jpg",e="Mainly clear and partly cloudy";break;case 45:case 48:var t="/src/media/images/cloudy.jpg",e="Fog and depositing rime fog";break;case 51:case 53:case 55:var t="/src/media/images/rain.jpg",e="Moderate drizzle";break;case 56:case 57:var t="/src/media/images/storm.jpg",e="Freezing drizzle";break;case 61:case 63:case 65:var t="/src/media/images/rain.jpg",e="Moderate rain";break;case 66:case 67:var t="/src/media/images/storm.jpg",e="Freezing rain";break;case 71:case 73:case 75:var t="/src/media/images/rain.jpg",e="Snow fall";break;case 77:var t="/src/media/images/rain.jpg",e="Snow grains";break;case 80:case 81:case 82:var t="/src/media/images/rain.jpg",e="Rain showers";break;case 85:case 86:var t="/src/media/images/storm.jpg",e="Snow showers";break;case 95:case 96:case 99:var t="/src/media/images/rain.jpg",e="Thunderstorm";break;default:var t="/src/media/images/sunny.jpg",e="Clear sky";break}return{image:t,text:e}}
